[{"title":"Ruby基础语法","url":"/2021/11/14/ruby-01/","content":"\n## 数字\n\n整型分两种，如果在31位以内（四字节），那为Fixnum实例。如果超过，即为Bignum实例。\n\n![](ruby-01/1.jpg)\n\n## 字符串\n\n双引号标记的字符串允许替换和使用反斜线符号，单引号标记的字符串不允许替换，且只允许使用 \\\\ 和 \\' 两个反斜线符号。\n\n```ruby\nname = 'zhangyuzhen'\nputs \"i am #{name}\"\n\n# i am zhangyuzhen\n```\n\n字符串常用方法：\n\n```ruby\nputs \"hello\".reverse # olleh\n\n# method? 表示方法返回布尔类型\nputs \"hello\".include?('o') # true\n\nputs \"hello\".sub('h', 'H') # Hello\n\n# method! 表示会改变原来的字符串\nputs \"hello\".sub!('h', 'H') # Hello\n\nputs \"hello\".size\n\nputs \"hello\".index('o')\n```\n\n## 数组\n\nRuby 数组不需要指定大小，当向数组添加元素时，Ruby 数组会自动增长。\n\n创建方式：\n\n```ruby\narr = Array.new(3,\"aaa\")\narr[0][0]='b'\nputs arr # baa baa baa\n\narr1 = Array.new(3){\"aaa\"}\narr1[0][0]='b'\nputs arr1 # baa aaa aaa\n```\n\n常用方法：\n\n```ruby\n# 获取元素 不存在时返回默认值\nputs arr2.fetch('1','数字1不存在')\nputs arr2.empty?()# false\n\narr3=['a','b','c']\nputs arr3.delete_at(2) # c\nputs arr3 # a b\nputs arr3.delete('b') # b\nputs arr3 # a\n```\n\n","tags":["Ruby"],"categories":["Ruby基础语法"]},{"title":"秒杀案例","url":"/2021/10/27/rabbitmq-03/","content":"\n使用Springboot+MyBatis+Redis+Rabbit+Mysql实现商品秒杀的功能。<!--more-->\n\n# 项目的整体流程\n\n在秒杀开始之前，将数据库中的参加秒杀的商品同步至Redis中。秒杀开始，用户发起请求，为了流程简洁，直接在网关层中的Controller中负责对部分请求进行过滤，与Redis进行交互。然后发送消息，即将用户请求信息放入Rabbitmq中。在serivce项目中消费消息，即获取到Rabbitmq中的用户请求信息，随后完成与Mysql的交互，将信息持久化到数据库中。\n<img src=\"rabbitmq-03/1.png\" style=\"zoom: 50%;\" />\n\n# 网关项目中的Controller\n\n```java\n@RestController\npublic class SpikeController {\n\n    @Autowired\n    private MyBloomFilter bloomFilter;\n    @Autowired\n    private RedisTemplate redisTemplate;\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @GetMapping(\"/doSpike\")\n    public String doSpike(Long productId, Long userId) {\n        String key = productId + \":\" + userId;\n        // 使用bloomFilter快速判断key值是否存在\n        if (bloomFilter.isExist(key)) {\n            return \"已经参与抢购，不能重复参加！\";\n        }\n        // 请求次数累计\n        Long count = redisTemplate.opsForValue().increment(\"requestCount:productId:userId:\" + productId + \"_\" + userId);\n        if (count != null && count > 500) {\n            return \"该商品已被抢完！\";\n        }\n        // 更新redis中的数据\n        Long finalStock = redisTemplate.opsForValue().decrement(\"product:\" + productId);\n        if ( finalStock < 0) {\n            return \"该商品已被抢完！\";\n        }\n        // 将请求信息存入mq\n        Map<String, Object> map = new HashMap<>(16);\n        map.put(\"userId\", userId);\n        map.put(\"productId\", productId);\n        rabbitTemplate.convertAndSend(\"spike.queue\", JSON.toJSONString(map));\n        return \"抢购成功！\";\n    }\n}\n```\n\n布隆过滤器工具类：\n\n```java\n@Component\npublic class MyBloomFilter {\n\n    @Autowired\n    private StringRedisTemplate redisTemplate;\n    /**\n     * 范围\n     */\n    private int size = 2 << 29;\n    /**\n     * 质数的数组\n     */\n    private int[] seeds = {7, 11, 13, 17, 19};\n    /**\n     * 特征函数的个数\n     */\n    private final int HASH_FUN_NUM = 5;\n    /**\n     * 搞一个数组 专门放特征函数\n     */\n    private HashFun[] hashFuns = new HashFun[HASH_FUN_NUM];\n\n    public MyBloomFilter() {\n        for (int i = 0; i < HASH_FUN_NUM; i++) {\n            hashFuns[i] = new HashFun(size, seeds[i]);\n        }\n    }\n    /**\n     * 把字符串做特征函数 然后添加到位图中去\n     * @param str\n     */\n    public void addBloom(String str) {\n        // 循环特征函数的数组\n        for (HashFun hashFun : hashFuns) {\n            // 每次计算出一个点位\n            int pos = hashFun.getPos(str);\n            System.out.println(pos);\n            // 把点位存起来  存在redis的bitmap中去 map<String,BitMap>\n            redisTemplate.opsForValue().setBit(\"SPIKE\", pos, true);\n        }\n    }\n\n    /**\n     * 判断是否重复\n     * @param str\n     * @return\n     */\n    public Boolean isExist(String str) {\n        // 计算五次\n        for (HashFun hashFun : hashFuns) {\n            int pos = hashFun.getPos(str);\n            // 从位图中判断是否存在\n            Boolean flag = redisTemplate.opsForValue().getBit(\"SPIKE\", pos);\n            if (null != flag && !flag) {\n                // 只要有一个点位 不存在 说明不重复\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```java\npublic class HashFun {\n    /**\n     * 范围\n     */\n    private int size;\n\n    /**\n     * seed 种子\n     */\n    private int seed;\n\n\n    public HashFun(int size, int seed) {\n        this.size = size;\n        this.seed = seed;\n    }\n\n    /**\n     * hash值\n     * @param str\n     * @return\n     */\n    public int hash(String str) {\n        int h = 0;\n        if (!StringUtils.hasText(str)) {\n            // 空字符串的hash值就是0\n            return h;\n        }\n        char[] chars = str.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            h = seed * h + chars[i];\n        }\n        return h;\n    }\n    /**\n     * 得到位置\n     * @param str\n     * @return\n     */\n    public int getPos(String str) {\n        int hash = hash(str);\n        return hash & (size - 1);\n    }\n}\n```\n\n# Service项目\n\n## 数据同步类\n\n可写成任务调度的形式，需要在主启动类上添加注解`@EnableScheduling`，开启任务调度功能。\n\n这里采用每次项目启动时进行数据同步。\n\n```java\n@Component\npublic class MysqlToRedis implements CommandLineRunner {\n\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n    @Autowired\n    private ProductMapper productMapper;\n\n    /**\n     * 实现CommandLineRunner接口\n     * springboot启动后会自动调用重写的 run 方法\n     * @param args\n     * @throws Exception\n     */\n    @Override\n    public void run(String... args) throws Exception {\n        // 查询秒杀商品\n        List<Product> spikeProducts = productMapper.listSpikeProducts();\n        // 存入redis\n        if (CollectionUtils.isEmpty(spikeProducts)) {\n            return;\n        }\n        spikeProducts.forEach(p -> stringRedisTemplate.opsForValue().set(\"product:\" + p.getId(), String.valueOf(p.getStock())));\n    }\n\n//    /**\n//     * 每天12点执行\n//     */\n//    @Scheduled(cron=\"0 0 12 * * ? *\")\n//    public void spikeTask(){\n//\n//    }\n\n//    /**\n//     * 项目执行完成后执行\n//     */\n//    @PostConstruct\n//    public void spikeTask(){\n//\n//    }\n}\n```\n\n## 消息监视类\n\n用来监听消息和获取消息，从消息队列中获取请求信息，完成与数据库的交互。\n\n```java\n@Component\npublic class SpikeListener {\n\n    @Autowired\n    private IOrderService orderService;\n\n    @Autowired\n    private MyBloomFilter bloomFilter;\n\n    @RabbitListener(queues = \"spike.queue\",concurrency=\"3-5\")\n    public void handleSpike(Channel channel, Message message) throws Exception {\n        // 获取消息队列中的数据\n        String msg = new String(message.getBody());\n        JSONObject jsonObject = JSON.parseObject(msg);\n        Long userId = jsonObject.getLong(\"userId\");\n        Long productId = jsonObject.getLong(\"productId\");\n        // 生成订单记录 减少库存\n        orderService.handleOrderAndStock(userId,productId);\n        // 将商品id和用户id信息对应的key加入bloomFilter\n        bloomFilter.addBloom(productId + \":\" + userId);\n        // 签收\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);\n    }\n}\n```\n\n## 处理秒杀业务方法\n\n```java\n@Transactional(rollbackFor = RuntimeException.class)\npublic void handleOrderAndStock(Long userId, Long productId) {\n    int time = 0;\n    // 自旋拿锁\n    while (time < waitTime) {\n        // 使用redis分布式锁 防止线程安全问题\n        String lockKey = \"lock:\" + productId;\n        String uuid = UUIDUtils.getUUID().toString();\n        Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, uuid, 3, TimeUnit.SECONDS);\n        if (null != lock && !lock) {\n            // 没拿到锁\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            time++;\n        } else {\n            try {\n                Product product = productMapper.selectById(productId);\n                long finalStock = product.getStock() - 1;\n                if (finalStock < 0) {\n                    log.info(\"库存不足!\");\n                    return;\n                } else {\n                    product.setStock(finalStock);\n                    productMapper.update(product);\n                    insert(new Order(null, userId, productId));\n                    return;\n                }\n            } finally {\n                // 释放锁 使用uuid校验防止误删\n                if (uuid.equals(stringRedisTemplate.opsForValue().get(lockKey))) {\n                    stringRedisTemplate.delete(lockKey);\n                }\n            }\n        }\n    }\n}\n```\n\n## 业务方法的优化\n\n使用Redisson解决分布式锁问题，保证线程操作的原子性，防止线程释放掉其他线程获取的锁。\n\n引入Redisson依赖\n\n```xml\n<dependency>\n    <groupId>org.redisson</groupId>\n    <artifactId>redisson-spring-boot-starter</artifactId>\n    <version>3.13.6</version>\n</dependency>\n```\n\n编写配置类\n\n```java\n@Configuration\npublic class RedissonConfig {\n\n    @Bean\n    public RedissonClient redissonClient(){\n        Config config = new Config();\n        config.useSingleServer().setTimeout(50000).setAddress(\"redis://127.0.0.1:6379\");\n        return Redisson.create(config);\n    }\n}\n```\n\n改写业务方法\n\n```java\n@Transactional(rollbackFor = RuntimeException.class)\npublic void handleOrderAndStock(Long userId, Long productId) {\n\n    RLock lock = redissonClient.getLock(\"lock:\" + productId);\n    lock.lock(30, TimeUnit.SECONDS);\n    try {\n        Product product = productMapper.selectById(productId);\n        long finalStock = product.getStock() - 1;\n        if (finalStock < 0) {\n            log.info(\"库存不足!\");\n            return;\n        } else {\n            product.setStock(finalStock);\n            productMapper.update(product);\n            insert(new Order(null, userId, productId));\n            return;\n        }\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n","tags":["RabbitMQ"],"categories":["中间件"]},{"title":"Dockor","url":"/2021/10/26/dockor/","content":"\n# Docker概述\n\n用于构建和发布应用的**容器技术**。\n\n- Docker将程序和运行环境直接打包在一起，可保证一致运行环境，更轻松的迁移。\n- 对进程进行隔离封装，容器与容器之间互不影响，更高效的利用系统资源。\n- 通过镜像复制N多个环境一致的容器，方便部署。<!--more-->\n\n# Linux下安装\n\n```bash\ncurl -fsSL get.docker.com -o get-docker.sh\nsudo sh get-docker.sh --mirror Aliyun\n\n# 查看状态\nservice docker status\n# 启动\nsudo service docker start\n```\n\n# 相关概念\n\n>  镜像 image\n\n一个镜像代表一个软件\n\n> 容器 container\n\n基于某个镜像运行一次就是生成一个容器\n\n> 仓库 repository\n\n用来存储docker中的所有镜像的具体位置。\n\n远程仓库：docker在世界范围维护一个唯一的远程仓库\n\n本地仓库：当前自己机器中下载镜像的存储位置\n\n# hello-world\n\n```bash\ndocker run hello-world\n```\n\n1、`docker run 镜像名` 根据run后面的镜像运行一个容器\n\n2、在运行之前先在自己本地仓库查找对应的镜像直接使用，找不到再去远程仓库下载使用。\n\n# Docker相关命令\n\n> docker引擎以及帮助相关\n\n```bash\ndocker info\n\ndocker version\n\ndocker --help\n```\n\n> images相关\n\n```bash\n# 查看本地仓库的所有镜像\ndocker images\n# 查看本地仓库的所有镜像id\ndocker images -q\n# 下载镜像\ndocker pull 镜像名:版本号\n# 搜索镜像版本\ndocker search 镜像名\n# 删除镜像(简写docker rmi) -f强制删除 \ndocker image rm -f 镜像名:版本号或容器名称\n# 清空本地仓库\ndocker rmi -f $(docker images -q)\n# 载入镜像\ndocker load -i 文件名\n# 导出镜像压缩包\ndocker save -o 文件名.tar 镜像名:版本号\n```\n\n> container相关\n\n```bash\n# 运行容器\ndocker run 镜像名:版本号\ndocker run 镜像id\n# 查看运行的容器\ndocker ps\n# 查看所有的容器\ndocker ps -a\n# 查看所有的容器id\ndocker ps -q\n#启动 关闭 重启 容器\ndocker start 容器名或者容器id\ndocker stop 容器名或者容器id\ndocker restart 容器名或者容器id\n# 立即停止\ndocker kill 容器名或者容器id\n# 删除容器\ndocker rm -f 容器名或者容器id\n# 容器日志\ndocker logs -f 容器名或者容器id\n# 容器内进程\ndocker top 容器名或者容器id\n# 容器内部交互\ndocker exec -it 容器名或者容器id bash\n```\n\n> 常见软件的启动\n\n```bash\n#启动tomcat -d后台运行 -p端口映射 --name 容器命名\ndocker run -d -p 8081:8080 --name 容器名 镜像:版本号\n\n# 启动mysql -v 持久化数据到宿主机\ndocker run -d -p 3307:3306 --name 容器名 -e MYSQL_ROOT_PASSWORD=设置密码 -v mysqlData:/var/lib/mysql 镜像:版本号\n# 查看数据卷映射信息\ndocker volume inspect mysqlData\n\n# 启动redis -v 持久化数据到宿主机 开启AOF\n# 配置文件数据卷映射 docker run -p 6379:6379 --name myRedis -v d:/docker/redis/conf:/usr/local/etc/redis redis:6.2 redis-server /usr/local/etc/redis/redis.conf\ndocker run -p 6379:6379 --name 容器名 -v redisData:/data -d 镜像:版本号 redis-server --appendonly yes\n\n```\n\n# Docker中的网络\n\nDocker允许通过外部访问容器或容器互联的方式来提供网络服务。\n\n一般在使用docker网桥实现容器与容器之间通信时，都是站在一个应用的角度进行容器通信。\n\n```bash\n# 查看docker网桥配置\ndocker network ls\n# 创建自定义网桥\ndocker create 网桥名称\n# 指定网桥启动\ndocker run --network 网桥名称 --name 容器名称 镜像名:版本\n# 删除网桥\ndocker network rm 网桥名\n```\n\n# Dockerfile\n\n用于构建自定义镜像\n\n编写Dockfile文件：\n\n```dockerfile\nFROM openjdk:8-jdk \nWORKDIR /app\nADD redis_springboot-0.0.1-SNAPSHOT.jar app.jar\nEXPOSE 8081\nENTRYPOINT [\"java\",\"-jar\"]\nCMD  [\"app.jar\"]\n```\n\n- FROM 基于哪个镜像进行构建\n- WORKDIR 定义静进入容器时的默认位置，接下来后续操作的工作空间\n- ADD 将上下文中的jar文件复制到工作空间\n- EXPOSE 暴露端口\n- ENTRYPOINT 添加启动应用的固定命令\n- CMD 执行jar\n\n执行构建命令：\n\n```bash\ndocker build -t 镜像名:版本 Dockerfile所在目录\n```\n\n","tags":["Dockor"],"categories":["工具"]},{"title":"Redis主从复制，集群","url":"/2021/10/24/redis-07/","content":"\n主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，**Master以写为主，Slave以读为主**。\n\n好处：\n\n- 读写分离，性能扩展\n- 容灾快速恢复<!--more-->\n\n缺点：\n\n- 复制延迟\n  - 由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。\n\n指定主机命令：`slaveof 主机ip 主机端口`\n![](redis-07/1.png)\n\n- 一主二仆\n  - 从服务器挂掉后重启时，变为主服务器\n  - 从服务器挂掉后重启时，再加入从服务器中，会把主服务器中的数据从头到尾复制一遍\n  - 主服务器挂掉后，从服务器不会变成主服务器\n  - 主服务器挂掉后重启，还是主服务器\n  \n- 薪火相传\n  - 上一个Slave可以是下一个Slave的Master，Slave同样可以接收其他 slaves的连接和同步请求， 可以有效减轻master的写压力,去中心化降低风险。\n  \n- 反客为主\n  - `slaveof no one` 当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。\n\n# 复制原理\n\n1、从服务器连接上主服务器之后，就会发送进行数据同步的消息。\n\n2、主服务器收到从服务器发送过来的消息后，把主服务器中的数据进行持久化为RDB文件，把RDB文件发送给从服务器。\n\n3、每次主服务器写操作时，主动和从服务器同步。\n\n# 哨兵模式\n\n**反客为主的自动版**，能够后台监控主机，如果主机挂掉了根据投票数自动将从服务器转换为主服务器。\nsentinel.conf\n\n```bash\n# 其中mymaster为监控对象起的服务器名称， 1 表示至少有多少个哨兵同意重新选取主机。\nsentinel monitor mymaster 127.0.0.1 6379 1\n```\n\n运行哨兵\n\n```bash\nredis-sentinel sentinel.conf\n```\n\n选取主机原则：\n\n- 优先级最高的 ，replica-priority 值越小优先级越高\n- 偏移量最大 ，即优先选择同步数据最全的从机\n- runid最小的\n\n# 集群\n\nRedis 集群实现了对Redis的水平**扩容**，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。\n\nRedis 集群通过分区（partition）来提供一定程度的**可用性**（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。\n\n无中心化配置，任何一台主机或从机都能成为集群的入口，它们之间都能相互通信。\n\n集群配置：\n\n`cluster-enabled yes` 打开集群模式\n\n`cluster-config-file nodes-6379.conf` 设定节点配置文件名\n\n`cluster-node-timeout 15000`  设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换\n\nreids6179.conf\n\n```bash\ninclude /home/bigdata/redis.conf # 公共配置\nport 6379\npidfile \"/var/run/redis_6379.pid\"\ndbfilename \"dump6379.rdb\"\ndir \"/home/bigdata/redis_cluster\"\nlogfile \"/home/bigdata/redis_cluster/redis_err_6379.log\"\ncluster-enabled yes\ncluster-config-file nodes-6379.conf\ncluster-node-timeout 15000\n```\n\n合并：\n\n```bash\ncd /opt/redis-6.2.1/src\n\n redis-cli --cluster  create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380  192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390  192.168.11.101:6391 \n```\n\n**使用实际ip !**\n\n- 通过插槽slot来实现数据分布存储\n- 主节点下线，从节点自动升为主节点\n- 某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉\n\n # 应用问题解决\n\n## 缓存穿透\n\nreids命中率降低，一直查询数据库。\n\n解决方案：\n\n- 空值缓存，并设置过期时间\n- 设置白名单 \n  - 使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。\n- 采用布隆过滤器\n  - 布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。\n  \n    将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。\n- 进行实时监控\n  - 当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务\n\n## 缓存击穿\n\nredis中的某个key过期，同时有大量请求访问这个key，最终请求到数据库，造成数据库崩溃。\n\n解决方案：\n\n- 预先设置热点数据\n\n  在redis达到访问高峰前，把这些热点数据存入redis中，加大这些热点数据key的时长\n\n- 实时调整\n\n  现场监控那些数据是热点数据，实时调整key的时长\n\n- 设置锁\n\n  在缓存中查不到数据时，上锁，然后再去查询数据库，查询完成后释放锁\n\n## 缓存雪崩\n\n短时间内查询大量key集中过期，大量请求直接指向数据库。\n\n解决方案：\n\n- 构建多级缓存 nginx缓存 + redis缓存 +其他缓存（ehcache等）\n\n- 使用锁或队列\n\n  用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况\n\n- 设置过期标志更新缓存：\n\n  记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存\n\n- 将缓存失效时间分散开：\n\n  比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件\n\n# 分布式锁\n\n随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！\n\n分布式锁主流的实现方案：\n\n1. 基于数据库实现分布式锁\n\n2. 基于缓存（Redis等）\n\n3. 基于Zookeeper\n\n每一种分布式锁解决方案都有各自的优缺点：\n\n1. 性能：redis最高\n2. 可靠性：zookeeper最高\n\n```java\n@GetMapping(\"/testLock\")\npublic void testLock() {\n    // 设置锁 通过uuid标识应用 防止误删\n    String uuid = UUID.randomUUID().toString();\n    Boolean lock = redisTemplate.opsForValue().setIfAbsent(\"lock\",uuid ,3, TimeUnit.SECONDS);\n    //2获取锁成功、查询num的值\n    if(lock!=null&& lock){\n        Object value =  redisTemplate.opsForValue().get(\"num\");\n        //判断num为空return\n        if(ObjectUtils.isEmpty(value)){\n            return;\n        }\n        //有值就转成成int\n        int num = Integer.parseInt(value+\"\");\n        //把redis的num加1\n        redisTemplate.opsForValue().set(\"num\", ++num);\n        //释放锁，del\n        if(uuid.equals((String) redisTemplate.opsForValue().get(\"lock\"))){\n            redisTemplate.delete(\"lock\");\n        }\n    }else{\n        //获取锁失败、每隔0.1秒再获取\n        try {\n            Thread.sleep(100);\n            testLock();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n# 删除策略\n\n- 惰性删除\n\n  数据到达超时时间的，不立即处理，等下次访问该数据的时候，再去删除。\n\n- 定时删除\n\n  当 key设置过期时间的时候，创建一个定时器事件，当 key 过期时间到达时，由定时器任务立即执行对 key 的删除操作，删除操作先删除存储空间，再移除掉过期的key。\n\n- 定期删除\n\n  周期性轮询 Redis 库中的时效性数据，采取随机抽取的策略，利用过期数据占比的方式控制删除频度。\n\n# 淘汰策略\n\n加入键的时候如果过限时采用淘汰策略删除键：\n\n- LRU 最近最少使用\n- LFU 使用频率最少\n\n","tags":["Redis"],"categories":["中间件"]},{"title":"SpringCloud入门","url":"/2021/10/20/springcloud-01/","content":"\n# 微服务概述\n\n微服务化就是将传统的一站式应用，根据业务进行拆分成一个一个服务，彻底地去耦合，每个微服务提供单个业务服务，一个服务做一件事。<!--more-->\n\n微服务：强调的时候服务的大小，关注的是某一个点，是**具体解决某一个问题/提供对应服务的一个服务应用**。\n\n微服务架构：一种架构模式，提供将单一应用程序划分成一组小的服务，服务之间相互协调、相互配合，为用户提供最终价值。每个服务运行在其**独立的进程**中，服务与服务之间采用轻量级的通信机制相互协作（通常是基于Http协议的RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境中。另外，**应当尽量避免统一的、集中式的服务管理机制**，对具体的服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。\n\n## 微服务优缺点\n\n优点：足够内聚，易于维护；开发简单开发效率高，一个服务可能就是专一的只干一件事情。\n\n缺点：需要分布式系统的复杂性；多服务运维难度；服务之间的通信成本；数据一致性；性能监控\n\n## 微服务技术栈\n\n多种技术的集合体\n\n服务开发：Springboot 、Spring 、 SpringMVC\n\n服务配置与管理：Archaius、Diamond\n\n服务注册与发现：Eureka、Consul、Zookeeper\n\n服务调用：Rest、RPC\n\n服务熔断器：Hystrix、Envoy\n\n负载均衡：Ribbon、Nginx\n\n服务接口调用：Feign\n\n消息队列：Kafka、RabbitMQ、ActiveMQ\n\n服务配置中心管理：SpringCloudConfig、Chef\n\n服务路由：Zuul\n\n# SpringCloud\n\n基于SpringBoot提供了一套微服务解决方案，是各个微服务架构技术落地实现的集合体，包含服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件。\n\n> SpringBoot与SpringCloud\n\nSpringBoot专注于快速方便的开发单个个体微服务。\n\nSpringCloud关注于微服务的协调与治理，也就是对springboot开发的项目进行整合与管理。\n\n> Dubbo与SpringCloud\n\nDubbo的定位是一款RPC框架\n\nSpringCloud提供的是微服务架构下的一站式解决方案\n\n# Eureka\n\nCAP理论：服务的一致性，可用性，容错性。\n\nEureka与Zookeeper区别：\n\n- Zookeeper注重服务的一致性，主机挂了，集群整体不对外提供服务，需要120s重选才能对外提供服务；\n\n- Eureka注重服务的可用性，只要有一台主机活着，就能对外提供服务。\n\n服务注册：当项目（eureka客户端）启动时，就会向eureka-serever发送自己的元数据（运行的ip，端口port，健康状态的监控等），Eureka会保存这些元数据，通过RestFul api提供调用\n\n服务续约：项目启动成功后，除了向eureka-server注册自己成功，还会向eureka-server汇报自己，表示自己还活着。\n\n服务下线：当项目关闭时，会给eureka-server报告，说明自己要下机了。\n\n服务的剔除：当项目没有在指定时间汇报自己的情况，eureka-server会认为此节点死掉了，会将其剔除。\n\n服务发现：\n\n将ClienA，ClientB注册到Eureka中，在ClientA中调用ClientB中的接口：\n\neuraka-server：\n\n```yml\nserver:\n  port:\n    8761\n\nspring:\n  application:\n    name:\n      eureka-server\n\neureka:\n  client:\n    service-url:\n      defaultZone:\n        http://localhost:8761/eureka\n      instance:\n        instance-id: ${eureka.instance.hostName}${spring.application.name}:${server.port}\n```\n\nclientA：\n\n```yml\nserver:\n  port:\n    9091\n\nspring:\n  application:\n    name:\n      clientA\n\neureka:\n  client:\n    service-url:\n      defaultZone:\n        http://localhost:8761/eureka\n```\n\nclientB：\n\n```yml\nserver:\n  port:\n    9092\n\nspring:\n  application:\n    name:\n      clientB\n\neureka:\n  client:\n    service-url:\n      defaultZone:\n        http://localhost:8761/eureka\n```\n\n![](springcloud-01/1.png)\n\nClientA中的Controller：\n\n```java\n@RestController\npublic class ClientAController {\n\n    @Autowired\n    private DiscoveryClient discoveryClient;\n\n    @GetMapping(\"/callClientB/{serviceName}/{path}\")\n    public String clientA(@PathVariable String serviceName, @PathVariable String path) {\n        // 根据服务名称找到ip和端口\n        List<ServiceInstance> instances = discoveryClient.getInstances(serviceName);\n        ServiceInstance serviceInstance = instances.get(0);\n        String url = \"http://\"+serviceInstance.getHost() + \":\" + serviceInstance.getPort()+\"/\"+path;\n        // 发起http请求\n        RestTemplate template = new RestTemplate();\n        return template.getForObject(url,String.class);\n    }\n}\n```\n\nClientB中的Controller：\n\n```java\n@RestController\npublic class ClientBController {\n\n    @GetMapping(\"hello\")\n    public String hello(){\n        return \"hello from ClientB\";\n    }\n}\n```\n\n![](springcloud-01/2.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["SpringCloud"],"categories":["JavaEE"]},{"title":".Net Core基础知识","url":"/2021/10/17/dotnetcore-01/","content":"\n# IOC\n\n## IOC基本介绍\n\nIOC的实现方式：\n\n- 服务定位器(ServiceLocator)，例如： `ServiceLocator.GetService<XXXService>`\n- DI (Dependency Injection)\n\nIOC中的一些概念：<!--more-->\n\n- 服务：我们需要容器帮我们创建的对象\n- 注册服务：将对象注册到容器中\n- 服务容器：负责管理注册的对象\n- 查询服务：创建和关联对象\n- 对象生命周期：\n  - Transient：瞬态，用完就销毁，每次获取都是重新创建一个新的对象\n  - Scoped：范围，用完不销毁，指定范围内获取的都是同一个对象\n  - Singleton：单例，全局获取的都是同一个对象。建议在创建无状态对象时使用\n\n## .NET Core中IOC的使用\n\n.NET控制服务反转组件取名为DependencyInjection，同时包含了ServiceLocator的功能。\n\n### ServiceLocator\n\n1、Install-Package\nMicrosoft.Extensions.DependencyInjection\n\n2、获取服务 \n创建`ServiceCollection`对象，注册服务，调用`ServiceCollection`中的`BuilderServiceProvider()`方法，创建`ServiceProvider`容器，获取服务。\n\n```c++\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // 1、创建ServiceCollection对象\n        ServiceCollection services = new ServiceCollection();\n        // 2、注册服务\n        services.AddTransient<IUserService,UserService>();\n        // 3、创建SerivceProvider容器\n        using (ServiceProvider provider = services.BuildServiceProvider())\n        {\n            // 4、从容器中获取服务\n            UserInfo user = new() { Name=\"zhangyuzhen\",Age=22 };\n            var userInfo = provider.GetService<IUserService>().ShowUserInfo(user);\n            Console.WriteLine(userInfo);\n        }\n    }\n}\n```\n\n### DI\n\n1.依赖注入是具有传染性的，如果一个类的实例对象是通过DI创建的，那么这个类的构造器中所有声明的服务都将会使用DI创建\n\n2.默认构造函数注入\n\n```c++\npublic class UserController\n{\n\n    private readonly IUserService _userService;\n    private readonly ILogService _logService;\n    \n    // Core DI\n    public UserController(IUserService userService, ILogService logService)\n    {\n        _userService = userService;\n        _logService = logService;\n    }\n\n    public void Test()\n    {\n        _userService.Print(\"调用userService接口!\");\n        _logService.Log(\"调用LogService接口！\");\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        ServiceCollection services = new ServiceCollection();\n        services.AddSingleton<ILogService,LogService>();\n        services.AddSingleton<IUserService,UserService>();\n        services.AddSingleton<UserController>();\n        using (ServiceProvider provider = services.BuildServiceProvider())\n        {\n            provider.GetService<UserController>().Test();\n        }\n    }\n}\n```\n\n# 配置系统\n\n## Json文件配置\n\n1、Install Package\n\nMicrosoft.Extensions.Configuration\n\nMicrosoft.Extensions.Configuration.Json\n绑定读取配置，可将配置文件内容封装到类中：Microsoft.Extensions.Configuration.Binder\n\n2、读取配置文件\n\n```json\n{\n  \"Name\": \"张昱侦\",\n  \"Age\": 22,\n  \"Address\": {\n    \"used\": \"武汉\",\n    \"now\": \"成都\"\n  },\n  \"Server\": {\"Ip\": \"127.0.0.1\",\"Port\": 8801}\n}\n```\n\n```c++\nclass Program\n{\n    static void Main(string[] args)\n    {\n        ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();\n        configurationBuilder.AddJsonFile(\"config.json\",optional:true,reloadOnChange:true);\n        IConfigurationRoot config = configurationBuilder.Build();\n        string name = config[\"Name\"];\n        Console.WriteLine(\"Name: \"+ name);\n        int age = int.Parse(config[\"Age\"]);\n        Console.WriteLine(\"Age: \" + age);\n        string addressNow = config.GetSection(\"Address:now\").Value;\n        Console.WriteLine(\"AddressNow: \"+ addressNow);\n        // 绑定读取配置\n        Server server = config.GetSection(\"Server\").Get<Server>();\n        Console.WriteLine(server);// 服务器地址为：127.0.0.1:8801\n    }\n}\nclass Server\n{\n    public string Ip { get; set; }\n    public int Port { get; set; }\n\n    public override string ToString()\n    {\n        return $\"服务器地址为：{Ip}:{Port}\";\n    }\n}\n```\n\n## 选项方式读取（推荐使用）\n\n1、Install Package\nMicrosoft.Extensions.Options\nMicrosoft.Extensions.Configuration\nMicrosoft.Extensions.Configuration.Json\nMicrosoft.Extensions.Configuration.Binder\n\n```c++\npublic class ConfigService\n{\n    private readonly IOptionsSnapshot<Server> _option;\n    // Core DI\n    public ConfigService(IOptionsSnapshot<Server> option)\n    {\n        _option = option;\n    }\n\n    public Server GetServer()\n    {\n        return _option.Value;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();\n        configurationBuilder.AddJsonFile(\"config.json\",optional:true,reloadOnChange:true);\n        IConfigurationRoot config = configurationBuilder.Build();\n\n        ServiceCollection services = new ServiceCollection();\n        // 绑定配置源到指定对象上\n        services.AddOptions().Configure<Server>(s => config.GetSection(\"Server\").Bind(s));\n        services.AddScoped<ConfigService>();\n        using(ServiceProvider serviceProvider = services.BuildServiceProvider())\n        {\n            Server server = serviceProvider.GetService<ConfigService>().GetServer();\n            Console.WriteLine(server);\n        }\n    }\n}\n\npublic class Server\n{\n    public string Ip { get; set; }\n    public int Port { get; set; }\n\n    public override string ToString()\n    {\n        return $\"服务器地址为：{Ip}:{Port}\";\n    }\n}\n```\n\n# 日志系统\n\n明天再学，累了。\n","tags":[".Net Core"],"categories":[".Net Core基础"]},{"title":"异步编程","url":"/2021/10/10/csharp-08/","content":"\n# Thread\n\n线程是一个可执行路径，可以独立于其他线程执行。\n\n线程被抢占：当前线程与另外一个线程执行交织的那一刻。<!--more-->\n\n## 线程的属性\n\n- IsAlive：线程一旦开始执行，IsAlive就是True，线程结束就变成了False。线程结束的条件，线程构造函数传入的委托方法执行结束。\n- 线程一旦结束就无法再开启。\n- Name：只能设置一次，以后再更改就会抛出异常。\n- CurrentThread：返回当前执行的线程。\n\n## 常用方法\n\n- Join()：等待当前线程执行完成后再开始后续的执行。可设置一个超时时间，执行超时返回False。\n- Thread.Sleep()：暂停当前线程，并等待指定的毫秒数。Thread.Sleep(0)会导致当前线程立即放弃当前的时间片，自动将cpu执行权移交给其他线程。\n- Thread.Yield()：把当前线程的执行权交给同一处理器上的其他线程\n- Sleep()，Join()会让线程处于阻塞状态。\n\n## 线程执行状态\n\n<img src=\"csharp-08/1.png\" style=\"zoom: 33%;\" />\n\n阻塞（block）：被阻塞的线程会立即将cpu的时间片生成给其他线程，从此不再消耗cpu时间，直到满足其阻塞条件为止才开始继续执行。\n\n- 阻塞判断：\n\n  ```c++\n  bool blocked = (thread1.ThreadState & ThreadState.WaitSleepJoin) != 0;\n  ```\n\n- 解除阻塞：\n\n  - 阻塞条件被满足\n  - 操作超时\n  - Thread.Interrput()\n  - Thread.Abort()\n  \n- 阻塞或接触阻塞，操作系统会执行上下文切换，会产生少量开销，通常为1或2微秒。\n\n- I/O-bound与Cpu-bound\n\n  - I/O-bound：花费大部分时间等待某事发生的操作，例如输入输出，Thead.Sleep()。\n\n  - Cpu-bound：花费大部分时间执行cpu密集型工作的操作。\n\n## 线程安全\n\n本地（Local）与共享（Shared）\n\n- Local：CLR为每个线程分配自己的内存栈（Stack），以便使**本地变量**保持独立。\n- Shared：\n  - 多个线程引用**同一个对象的实例**，那么他们就共享了数据。\n  \n  - 被**Lambda表达式或匿名委托**所捕获的**本地变量**，会被编译器转化为字段（field）,所以也会被共享。\n  \n  - **静态字段**（field）也会在线程间共享数据。\n  \n\n在读取和写入共享数据的时候，通过使用互斥锁（exclusive lock），来解决线程安全问题。\n\nC#中使用lock语句来加锁，当两个线程同时竞争一个锁（锁可以基于任何引用对象）时，其中一个线程就会等待或阻塞，直到锁变成可用状态。\n\n```c++\nclass TestThreadSafe\n{\n    static bool flag;\n    static readonly object _lock = new object();\n\n    static void Go()\n    {\n        lock (_lock)\n        {\n            if (!flag)\n            {\n                Console.WriteLine(flag);\n                // Thread.Sleep(1000);\n                flag = true;\n            }\n        }\n    }\n\n    static void Main(string[] args)\n    {\n        new Thread(Go).Start();\n        Go();\n    }\n}\n```\n\n## 前台线程与后台线程\n\n- 默认情况下，手动创建的线程就是前台线程。只要前台线程在运行，应用程序就还在运行；前台线程终止后，其余的后台线程也会全部终止，程序就会退出。\n- 以在任何时候将前台线程修改为后台线程，方式是设置Thread.IsBackground = true。\n\n## 信号\n\n让线程一直处于等待状态，直到接受到其他线程发来的信号（signaling）,才会继续执行。\n\n```c++\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var signal = new ManualResetEvent(false);\n        new Thread(()=> {\n            Console.WriteLine(\"等待信号~\");\n            signal.WaitOne();\n            signal.Dispose();\n            Console.WriteLine(\"获取到了信号！\");\n        }).Start();\n        Thread.Sleep(3000);\n        signal.Set();// 打开信号\n        // signal.Reset();// 关闭信号\n    }\n}\n```\n\n## 线程池\n\n- 不可以设置线程池的Name\n- 池线程都是后台线程\n- 阻塞池线程可使性能降级\n- Thread.CurrentThread.IsThreadPoolThread 判断是否执行在池线程上\n\n# Task\n\n## Thread的问题\n\n线程是用来创建并发的一种低级别工具，它有一些限制。尤其是：\n\n- 虽然开始线程的时候可以方便的传入数据，但是当Join的时候，很难从线程中获得返回值。\n  - 可能需要设置一些共享字段\n  - 如果操作抛出异常，捕获和传播该异常都很麻烦\n- 无法告诉线程在结束时开始做另外的工作，必须进行Join操作（在进程中阻塞当前线程）。\n- 很难使用较小的并发来组件大型的并发。\n- 导致了对手动同步的更大依赖以及随之而来的问题。\n\n## Task类\n\nTask类可以很好的解决Thread的问题。它代表了一个并发操作（可能由Thread支持，或不由Thread支持）。\n\n- Task.Run()开启一个任务\n- Task默认使用线程池，也就是后台线程。主线程结束，创建的所有Task都会结束\n- Task.Run()返回一个Task对象，可以用来监视其过程\n- Task.Wait()会阻塞当前线程，直到Task执行完成\n\n默认情况下，CLR在线程池中运行Task，这非常适合短时间运行的Cpu-Bound类工作。\n针对长时间运行的任务或者是阻塞操作，可以不采用线程池的方式来创建任务：\n\n```c++\n class Program\n {\n     static void Main(string[] args)\n     {\n         // 执行短时间的任务 采用默认的线程池创建方式\n         Task task = Task.Run(() =>  Console.WriteLine(\"执行Task~\"));\n         task.Wait();\n\n         // 执行长时间的任务 不采用线程池\n         Task taskLong = Task.Factory.StartNew(() => {\n             Console.WriteLine(\"执行长时间任务~\");\n             Thread.Sleep(3000);\n         }, TaskCreationOptions.LongRunning);\n\n     }\n }\n```\n\n如果同时运行多个long-running tasks，尤其是由处于阻塞状态的，那么性能就会受到很大的影响，这时可采用：\n\n- 如果任务是IO-Bound，等待一个在 `async` 方法中返回 `Task` 或 `Task<T>` 的操作。\n- 如果任务是Cpu-Bound，等待一个使用 Task.Run方法在后台线程启动的操作。\n\n# 同步与异步\n\n- 同步操作会在返回调用者之前完成它的工作\n- 异步操作会在返回调用者之后去做它的（大部分）工作\n  - 异步方法会启用并发，因为它的工作会与调用者并行执行\n  - 异步方法通常很快就会返回到调用者，所以叫非阻塞方法\n- 异步不会提升单个应用程序的运行速度，但是能提升服务器的并发访问量。\n\n## async\n\n- 用`async`关键字修饰的方法称为异步方法。\n- 异步方法的返回值一般是`Task<T>`，T是真正的返回值类型。惯例：异步方法名称一般以Async结尾。\n- 即使异步方法没有返回值，也最好声明为非泛型的`Task`。\n- 调用泛型方法时，一般在方法前加上`await`关键字，这样拿到的返回值直接就是泛型指定的T类型。\n- 一个方法使用`await`关键字后，这个方法必须声明使用`async`修饰。\n\n## await\n\nawait关键字简化了附加continuation的过程\n<img src=\"csharp-08/2.png\" style=\"zoom: 33%;\" />\n\nawait关键字后面expression会马上返回，直接执行expression后续的语句，expression执行完成后自动回调。\n\nawait调用的等待期间，.NET会把当前的线程返还给线程池，等异步方法调用执行完毕后，再从线程池中取出一个线程执行后续的代码。\n\n## Task 与async Task\n\nTask：在方法前面加`Task`或是`Task<T> `，就是表明方法是可等待的。也是C#中的一种Task异步编程模式，结合`await`可方便的进行异步并发编程。\n\nasync Task：表明方法就是异步方法。\n\n","tags":["C#"],"categories":["C#高级"]},{"title":"Attribute","url":"/2021/10/06/csharp-07/","content":"\nAttribute的作用是为元数据添加内容，即可用来标注一段程序，可以是类，属性，方法等。可利用反射机制获取标注或者获取标注的属性，类或者方法等，用来执行不同的操作，例如数据的校验等。<!--more-->\n\n# 自定义特性\n\n类名必须以`Attribute`结尾，需要继承.NET提供的`Attribute`抽象类。\n\n> C#中的 字段（Field）与属性（Property）\n>\n> - 字段是值私有属性。\n>\n> - 属性是指访问器，含get{}或set{}的代码块的特殊“方法”。\n\n```c++\n // 定义特性可以使用的目标\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property,AllowMultiple = true)]\nclass LengthAttribute : Attribute\n{\n    public int MinimumLength { get; set; }\n    public int Maximum { get; set; }\n\n    public LengthAttribute(int minimumLength, int maximum)\n    {\n        MinimumLength = minimumLength;\n        Maximum = maximum;\n    }\n\n    // 验证特性\n    public bool Validate(object value)\n    {\n        if (!string.IsNullOrWhiteSpace((string)value))\n        {\n            if(value.ToString().Length>= MinimumLength && value.ToString().Length <= Maximum)\n            {\n                return true;\n            }\n        }\n        return false; \n    }\n}\n```\n\n# 验证特性\n\n```c++\npublic class Validatettribute\n{\n    public static bool Validate<T>(T t)\n    {\n        // 获取所有属性\n        var propertyInfos = typeof(T).GetProperties();\n        // 遍历所有属性\n        foreach(var property in propertyInfos)\n        {\n            // 判断特性是否定义（注：多个特性可以继承自一个抽象类，直接判断抽象类是否定义）\n            if (property.IsDefined(typeof(LengthAttribute), true))\n            {\n                // 获取属性上的所有特性\n                var attributes = property.GetCustomAttributes();\n                // 遍历所有特性\n                foreach(var attribute in attributes)\n                {\n                    LengthAttribute lengthAttribute = (LengthAttribute)attribute;\n                    // 调用特性的验证方法 传入属性的值\n                    return lengthAttribute.Validate(property.GetValue(t));\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n# 使用特性\n\n```c++\npublic class Student\n {\n     public int Id { get; set; }\n     [Length(1,50)]// 字符串长度校验\n     public string Name { get; set; }\n }\n```\n\n```c++\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Student stu = new Student { Name = \"\" };\n        Console.WriteLine(Validatettribute.Validate<Student>(stu));// False\n        Student stu1 = new Student { Name = \"zhang\" };\n        Console.WriteLine(Validatettribute.Validate<Student>(stu1));// True\n    }\n}\n```\n\n","tags":["C#"],"categories":["C#高级"]},{"title":"C#连接数据库","url":"/2021/10/05/csharp-06/","content":"\n # ADO.NET\n\n是一组用于和数据源进行交互的面向对象类库\n1、建立连接；2、打开连接；3、发送sql命令；4、执行命令；5、关闭连接<!--more-->\n<img src=\"csharp-06/1.png\" style=\"zoom:60%;\" />\n\n- DataReader是一个向前的指针，本身并不包含数据，调用一次Read()方法它就向前到下一条记录，一个DataReader必须单独占用一个打开的数据库连接。一般用于大型数据处理。\n- DataAdapter象一座桥梁，一头连起数据库表，一头连起一个DataSet或者DataTable，在把数据库中的数据填充到DataSet或DataTable后就可以“过河拆桥”，不用再连接到数据库，而可以直接从DataSet或DataTable中获取数据。一般用于小型数据处理。\n\n# 连接MySql数据库\n\n常用的sql执行函数：\n\n- `ExecuteReader()`：用于查询数据库。查询结果是返回`MySqlDataReader`对象，`MySqlDataReader`包含sql语句执行的结果，并提供`Read()`方法从结果中阅读一行。\n\n- `ExecuteNonQuery()`：用于插入、更新和删除数据。\n- `ExecuteScalar()`：用于查询数据时，返回查询结果集中第一行第一列的值，即只返回一个值。\n\n```c++\nnamespace TestMysql\n{\n    class Program\n    {   \n        // 连接字符串  用于连接数据库\n        private static readonly string connectionString = \"server=localhost;port=3306;user=root;password=2824199842;database=test\";\n\n        // 创建连接\n        private static readonly MySqlConnection connection = new MySqlConnection(connectionString);\n        \n        private static void TestSelect()\n        {\n            string sql = \"select * from student\";\n            MySqlCommand cmd = new MySqlCommand(sql, connection);\n            MySqlDataReader reader = cmd.ExecuteReader();\n            while (reader.Read())// 初始索引为-1 执行读取下一条数据\n            {\n                // 键值对方式获取值\n                Console.WriteLine(\"id:{0} name:{1} age:{2}\", reader.GetInt64(\"id\"), reader.GetString(\"name\"), reader.GetInt32(\"age\"));\n            }\n        }\n\n        private static void TestInsert()\n        {\n            string sql = \"insert into student(id,name,age) values(2017004,'张小伟',34)\";\n            MySqlCommand cmd = new MySqlCommand(sql, connection);\n            int rows = cmd.ExecuteNonQuery();// 返回受影响的行数\n            Console.WriteLine(\"添加成功！\");\n        }\n\n        private static void TestUpdate()\n        {\n            string sql = \"update student set name='张伟' where id=2017004\";\n            MySqlCommand cmd = new MySqlCommand(sql, connection);\n            int rows = cmd.ExecuteNonQuery();\n            Console.WriteLine(\"修改成功！\");\n        }\n\n        private static void TestDelete()\n        {\n            string sql = \"delete from student where id=2017004\";\n            MySqlCommand cmd = new MySqlCommand(sql, connection);\n            int rows = cmd.ExecuteNonQuery();\n            Console.WriteLine(\"删除成功！\");\n        }\n\n        static void Main(string[] args)\n        {           \n            try\n            {\n                // 打开连接\n                connection.Open();\n                // 执行sql\n                // TestSelect();\n                TestInsert();\n                // TestUpdate();\n                // TestDelete();\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);         \n            }\n            finally\n            {\n                // 关闭连接\n                connection.Close();\n            }\n        }\n    }\n}\n```\n","tags":["ADO.NET"],"categories":["C#高级"]},{"title":"Linq","url":"/2021/10/05/csharp-05/","content":"\n# IEnumerable\n\nIEnumerable：可枚举类型，一个方法GetEnumerato()，实现该接口的类就可以对它进行遍历。\nIEnumerator：枚举器，一个属性Current，两个方法MoveNext()，Reset()。<!--more-->\n\n# 扩展方法\n\n在不改变源码的基础上为类添加新的方法\n\n```c++\nnamespace LinqTest\n{\n    public class Caculate\n    {\n        public int Add(int num1,int num2)\n        {\n            return num1 + num2;\n        }\n    }\n\n    // 拓展Caculate类\n    public static class CaculateExt\n    {\n        public static int AddExt(this Caculate caculate,int num1, int num2,int num3)\n        {\n            return num1 + num2 + num3;\n        }\n    }\n    \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Caculate caculate = new Caculate();\n            int num1 = caculate.Add(1, 1);\n            int num2 = caculate.AddExt(1, 1, 1);\n            Console.WriteLine(num1);// 2\n            Console.WriteLine(num2);// 3\n        }\n    }\n}\n```\n\n# Linq\n\n- linq to object 查询内存中的数据\n- linq to sql 查询数据库中的数据\n- linq to xml 查询xml文件\n\n```c++\n// 原始数据\nList<Student> studentList = new List<Student>()\n{\n    new Student(){Id=001,Name=\"张三\",Age=21,ClassId=1},\n    new Student(){Id=002,Name=\"李四\",Age=18,ClassId=1},\n    new Student(){Id=003,Name=\"王五\",Age=24,ClassId=2},\n    new Student(){Id=004,Name=\"赵六\",Age=16,ClassId=3},\n    new Student(){Id=005,Name=\"陈小\",Age=22,ClassId=3},\n    new Student(){Id=006,Name=\"刘麻子\",Age=28,ClassId=1}\n};\nList<StuClass> stuClasses = new List<StuClass>()\n{\n    new StuClass(){Id=1,ClassName=\"计科1班\"},\n    new StuClass(){Id=2,ClassName=\"计科2班\"},\n    new StuClass(){Id=3,ClassName=\"计科3班\"}\n};\n```\n\n> Where 指定条件查询数据\n\n```c++\nList<Student> students1 = studentList.Where(stu => stu.Age > 18).ToList();\n```\n\n>  ForEach 遍历数据\n\n```c++\nstudents1.ForEach(stu => Console.WriteLine(stu));\n```\n\n> Select 投影 将原始类（一般为po）的属性投影到新的类（一般为dto）的属性中\n\n```c++\nvar studentsWithIdAndName = studentList.Select(stu => new {Id=stu.Id,Name=stu.Name}).ToList();\n```\n\n<img src=\"csharp-05/1.png\" style=\"zoom: 60%;\" />\n\n> Join 内连接\n\n```c++\nvar studentsWithClass = studentList.Join(stuClasses,stu=>stu.ClassId,clazz =>clazz.Id,\n                                         (stu,clazz)=>new StudentWithClass()\n                                         { \n                                             Id=stu.Id,\n                                             Name=stu.Name,\n                                             Age=stu.Age,\n                                             ClassId=stu.ClassId,\n                                             ClassName=clazz.ClassName\n                                         }).ToList();\n\n // 表达式写法 用于处理大于2个list的连接查询\nvar studentsWithClass2 = (from s in studentList join c in stuClasses on s.ClassId equals c.Id \n                          select new StudentWithClass()\n                          {\n                              Id = s.Id,\n                              Name = s.Name,\n                              Age = s.Age,\n                              ClassId = s.ClassId,\n                              ClassName = c.ClassName\n                          }).ToList();\n\n```\n\n<img src=\"csharp-05/2.png\" style=\"zoom:70%;\" />\n\n> Take 获取指定数量的数据\n\n> Skip 跳过指定数量的数据\n\n> OrderBy 根据指定元素升序排列\n\n> OrderByDescending 根据指定元素降序排列\n\n> Where + Contains 模糊查询\n\n```C++\nvar students2 = studentList.Where(stu => stu.Name.Contains(\"张\")).OrderByDescending(stu => stu.Age).ToList();\n```\n\n> GroupBy 指定属性进行分组\n\n```c++\nIEnumerable<IGrouping<int,Student>> items = studentList.GroupBy(s => s.Age);\nforeach(IGrouping<int,Student> studentByAge in items)\n{\n    Console.WriteLine(studentByAge.Key);\n    foreach(Student s in studentByAge)\n    {\n        Console.WriteLine(s);\n    }\n    Console.WriteLine(\"*************\");\n}\n```\n\n","tags":["C#"],"categories":["C#高级"]},{"title":"委托","url":"/2021/10/04/csharp-04/","content":"\n委托也是一种类型，初始化时需要一个方法支持。委托是记录方法信息的一种类型，调用委托时就是调用初始化委托的方法。当委托作为函数参数时，就是将方法作为参数传入，而这种方法可通过Lambda表达式对进行改写，可极大加快编程的灵活性。<!--more-->\n\n# 简单委托\n\n```c++\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // 实例化委托 传入委托方法的方法名 可以不用new\n        DelegateHello delegateHello = new DelegateHello(Hello);\n        // 调用委托\n        // delegateHello.Invoke(\"委托调用\");\n        delegateHello(\"委托调用\");\n    }\n\n    // 定义委托方法 需要与委托返回值、参数类型相同\n    static void Hello(string msg)\n    {\n        Console.WriteLine(\"Hello,\"+msg);\n    }\n\n}\n\n// 定义委托 和定义接口中的方法一样，只需要加上 delagate 关键字\ndelegate void DelegateHello(string msg);\n```\n\n# 泛型委托\n\n可定义一个委托，用来调用多个方法。\n\n```c++\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // 直接传递方法名 不用new\n        // DelegateAdd<int> delegateAddInt = new DelegateAdd<int>(Add);\n        DelegateAdd<int> delegateAddInt = Add;\n        delegateAddInt(1, 1);\n\n        DelegateAdd<double> delegateAddDouble = Add;\n        delegateAddDouble(1.5, 1.6);\n    }\n\n    static void Add(int num1,int num2)\n    {\n        Console.WriteLine(num2+num1);\n    }\n    static void Add(double num1, double num2)\n    {\n        Console.WriteLine(num2 + num1);\n    }\n}\n// 定义泛型委托\ndelegate void DelegateAdd<T>(T num1, T num2);\n```\n\n# 预定义委托\n\n不用事先定义委托就可以使用方法对委托进行初始化，在.net Core中被大量使用。\n\n```c++\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // 无返回值 16个\n        //Action<string, string> action = new Action<string, string>(ConcatStr);\n        Action<string, string> action = ConcatStr;\n        action(\"hello\",\"world\");\n        // 有返回值 17个 前面的string表示输入参数类型 后面最后一个string表示返回结果类型\n        //Func<string,string> function = new Func<string,string>(PrintStr);\n        Func<string,string> function = PrintStr\n        Console.WriteLine(function(\"hello\"));\n        // Lambda表达式改写\n        Action<string> action1 = new Action<string>(msg => Console.WriteLine(msg));\n        action1(\"Lambda表达改写委托\");\n    }\n\n    static void ConcatStr(string str1,string str2)\n    {\n        Console.WriteLine(str1+str2);\n    }\n    static string PrintStr(string str)\n    {\n        return str;\n    }\n}\n```\n\n","tags":["C#"],"categories":["C#高级"]},{"title":"C#反射","url":"/2021/10/03/csharp-03/","content":"\n反射就是操作C#代码编译后的dll文件，可以获取程序集中的所有数据，并调用运行时类的方法。<!--more-->\n\n```c++\nstatic void Main(string[] args)\n{\n    // 方式一：通过加载dll文件获取指定Type\n    Assembly assembly = Assembly.LoadFrom(\"Library.dll\");\n    Type type = assembly.GetType(\"Libaray.Student\");\n\n    // 获取所有Type\n    var types = assembly.GetTypes();\n    foreach (Type t in types)\n    {\n        Console.WriteLine(t.Name);\n    }\n\n    // 方式二：通过typeof() 获取Type \n    Type type1 = typeof(Libaray.Student);\n\n    // 调用无参构造\n    object student = Activator.CreateInstance(type);\n    Console.WriteLine(student);\n\n    // 调用有参构造\n    object student1 = Activator.CreateInstance(type, new object[] { \"2017001\", \"zhangyuzhen\", 22 });\n    Console.WriteLine(student1);\n\n    // 调用私有构造\n    object student2 = Activator.CreateInstance(type, true);\n    Console.WriteLine(student2);\n\n    // 调用方法\n    var method = type.GetMethod(\"Print\", BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);\n    method.Invoke(student2,new object[] { \"zyz\",22});\n\n    // 调用泛型方法\n    var method1 = type.GetMethod(\"Func\", BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);\n    var genericMethod = method1.MakeGenericMethod(new Type[] { typeof(int) });\n    genericMethod.Invoke(student2, new object[] {});\n\n    // 获取所有属性并设置值\n    var properties = type.GetProperties();\n    foreach(var property in properties){\n        if (property.Name == \"Id\")\n        {\n            property.SetValue(student, \"001\");\n        }else if (property.Name == \"Name\")\n        {\n            property.SetValue(student, \"zhangsan\");\n        }\n        else\n        {\n            property.SetValue(student, 18);\n        }\n    }\n    Console.WriteLine(student);\n}\n```\n\n","tags":["C#"],"categories":["C#高级"]},{"title":"MongoDB基础","url":"/2021/08/27/mongodb/","content":"\n# 介绍\n\nMongoDB是由C++编写，基于分布式文件存储的开源数据库管理系统。\n由多节点实现负载均衡，保证服务器性能。\n旨在为web应用提供可拓展的高性能数据存储方案。\n将数据存储为一个文档，数据结构由键值对构成。类似json对象。字段可以包含其他文档，数据和文档数据。<!--more-->\n\nMongoDB是一个介于关系数据库（mysql，oracle，sqlserver）和非关系数据库（redis，Memrcache）之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。\n\nMongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库。\n\n# 基本概念\n\n默认端口：27017\n\ncollection：数据库表、集合，类似于关系型数据库中的表。\n\n- 没有固定的结构，可以插入不同格式和不同类型的数据。\n- 当第一个文档插入时，集合就会被创建。\n\ndocument：数据记录行、文档\n\n# 数据类型\n\nString\n\nInteger\n\nBoolean\n\nDouble\n\nArray\n\nTimestamp\n\nObjectId\n\nDate\n\nBinaryData\n\n# 数据库操作\n\n1.创建数据库\n\n```js\nuse databaseName\n// 创建集合才会创建数据库\ndb.createCollection(tableName)\n```\n\n2.删除数据库\n\n```js\nuse databaseName\ndb.dropDatabase()\n```\n\n3.删除集合\n\n```js\ndb.collectionName.drop()\n```\n\n4.插入数据\n\n```js\ndb.collectionName.insert({\"\":\"\"})\n```\n\n5.查询所有数据\n\n```js\ndb.collectionName.find()\n```\n\n6.更新数据\n\n```js\ndb.collectionName.update({查询参数},{$set:{更新数据}})\n```\n\n7.不存在就插入，存在就替换\n\n```js\ndb.collectionName.save()\n```\n\n8.条件查询\n\n小于：{\"Key\":{$lt:\"Value\"}}\n\n大于：{\"Key\":{$gt:\"Value\"}}\n\n小于等于：{\"Key\":{$lte:\"Value\"}}\n\n大于等于：{\"Key\":{$gte:\"Value\"}}\n\n不等于：{\"Key\":{$ne:\"Value\"}}\n\nand条件：,连接即可\n\nor条件：\n\n```js\ndb.collectionName.find({$or:[{key1:value1},{key2:value2}]})\n```\n\n分页：\n\n```js\ndb.collectionName.find().limit(pageSize).skip((pageNum-1)*pageSize)\n```\n\n排序：\n\n```js\n// 1:升序   -1:降序\ndb.collectionName.find().sort({key:1})\n```\n\n# 索引\n\n创建索引\n\n```js\n// key:索引字段  options: 1 升序创建 -1逆序创建\ndb.collectionName.createIndex(key,options)\n```\n\n删除索引\n\n```js\ndb.collectionName.dropIndex(key,options)\n```\n\n删除所有索引\n\n```js\ndb.collectionName.dropIndexs()\n```\n\n# 应用场景\n\n- 千万级数据存储\n- 日志记录\n- 搜索的历史记录\n- 时刻需要修改的数据\n\n\n\n","tags":["MongDB"],"categories":["中间件"]},{"title":"Oracle基础","url":"/2021/08/23/oracle/","content":"\n默认端口：1521\n\n# 数据类型\n\nchar(length)：存储固定长度，默认1位，不超过2000位\n\nvarchar2(length)：存储可变长度，默认1位，不超过4000位\n\nnumber(p,s)：既可以存储整型，又可以存储浮点型，p表示数字的最大位数，s表示小数位数\n\ndate\n\ntimestamp\n\n# 批量插入\n\n```sql\nINSERT ALL\nINTO Student VALUES('zhangyuzhen1',22);\nINTO Student VALUES('zhangyuzhen2',22);\nSELECT 1 FROM DUAL;\n```\n\n# 分页查询\n\n两个查询条件：\n\n- 条件1，rownum<=pageNum*pageSize\n- 条件2，rn>=(pageNum-1)*pageSize+1\n- 查询过程：\n  - 首先查询指定页数以及指定页数前的所有记录（包含数据和行号rownum） `where rownum<=pageNum*pageSize `\n  - 然后对查询到的记录进行子查询，查询到指定页数的所有记录`where rn>=(pageNum-1)*pageSize+1`\n- **注意：第二次查询需要使用别名rn进行查询**\n\n```sql\n# 分页查询 pageNum:1  pageSize:5\nSELECT * FROM \n(SELECT rownum rn,Student.* FROM Student WHERE rownum<=1*5)\nWHERE rn>= (1-1)*5+1\n```\n\n# 单引号与双引号\n\n- 单引号：1.引用字符串常量；2.转义符\n- 双引号：修饰关键字，对象名，字段名和别名\n\n# null值处理\n\nnvl(value1,value2)：value1为null时取value2\n","tags":["Oracle"],"categories":["数据库"]},{"title":"C#面向对象","url":"/2021/08/04/csharp-02/","content":"\n# 访问修饰符与字段修饰符\n\n**访问修饰符**\n\n- 修饰类主要有2个，即 `internal` 和 `public`，如果省略了访问修饰符，即为` internal`。\n\n- 修饰成员变量有 4 个，具体用法如下：<!--more-->\n\n  ( 1) public\n\n  成员可以被任何代码访问。\n\n  (2) internal\n\n  成员仅能被同一个项目中的代码访问。\n\n  (3) protected\n\n  成员只能由类或派生类中的代码访问。\n\n  (4) private\n\n  成员仅能被同一个类中的代码访问，如果在类成员前未使用任何访问修饰符，则默认为 `private`。\n\n**字段修饰符**\n\n主要有2个，`readonly`和`static`\n\n- 使用 `readonly `修饰字段意味着只能读取该字段的值而不能给字段赋值。\n\n- 使用 `static `修饰的字段是静态字段，可以直接通过类名访问该字段。**常量不能使用` static `修饰符修饰**。\n\n字段在类中定义完成后，在类加载时，会自动为字段赋值，不同数据类型的字段默认值不同， 如下表所示。\n\n| 数据类型      | 默认值 |\n| :------------ | ------ |\n| int           | 0      |\n| float、double | 0      |\n| string        | 空值   |\n| char          | a      |\n| bool          | False  |\n| 其他引用类型  | 空值   |\n\n# 方法参数\n\n方法中的参数除了定义数据类型外，还可以定义**引用参数**和**输出参数**。引用参数使用 `ref `关键字定义，输出参数使用 `out` 关键字定义。\n\n- 引用参数在方法使用时，必须是由变量赋予的值，不能是常量或表达式；\n- 在需要在每一个参数前面加上 `ref` 关键字修饰。\n\n```c++\npublic int Add(ref int num1, ref int num2)\n{\n     return num1 + num2;\n}\n\n// 调用时\nint num1 = 2;\nint num2 = 3;\nint sum = Add(ref num1,ref num2);\n```\n\n- 在使用输出参数时，必须在方法操作结束前为带输出参数的形式参数赋值；\n- 在调用含有带输出参数的方法时，必须在传递参数时使用 `out` 关键字，但不必给输出参数赋值。\n\n``` c++\npublic int Add(int num1, int num2, out int sum)\n{\n    sum = num1 + num2;\n    return sum;\n}\n// 调用时\nint sum = Add(1, 1, sum);\n```\n\n# partial部分类\n\n用于表示一个类中的一部分，一个类可以由多个部分类构成，定义部分类的语法形式如下：\n\n```markdown\n访问修饰符 修饰符   partial class 类名{……}\n```\n\n```c++\nnamespace TestClass\n{\n    partial class Person\n    {\n        private string name;\n        private char gender;\n        private int age;\n\n        public string Name { get => name; set => name = value; }\n        public char Gender { get => gender; set => gender = value; }\n        public int Age { get => age; set => age = value; }\n    }\n\n    partial class Person\n    {\n        public void Print()\n        {\n            Console.WriteLine(\"Name: \"+ name);\n            Console.WriteLine(\"Gender: \"+ gender);\n            Console.WriteLine(\"Age: \"+ age);\n        }\n    }\n}\n\n// 创建类并调用类方法\nnamespace TestClass\n{\n\tclass Program\n\t{\n    \tstatic void Main(string[] args)\n    \t{\n        \tPerson person = new Person();\n       \t\tperson.Name = \"zhangyuzhen\";\n        \tperson.Gender = '男';\n        \tperson.Age = 21;\n        \tperson.Print();\n    \t}\n    }\n}\n```\n\n在“不同”的部分类中可以直接互相访问其成员，相当于所有的代码都写到一个类中。\n\n# sealed\n\n通过在类定义前面放置关键字 **sealed**，可以将类声明为**密封类**。当一个类被声明为 **sealed** 时，它不能被继承。抽象类不能被声明为 sealed。\n\n# virtual\n\n虚方法是使用关键字 **virtual** 声明的。\n\n虚方法可以在不同的继承类中有不同的实现。\n\n对虚方法的调用是在运行时发生的。\n\n- 动态多态性是通过 **抽象类**(abstract) 和 **虚方法**(virtual) 实现的。\n\n- 静态多态性通过**方法重载**和**运算符重载**实现\n\n> 重载运算符是具有特殊名称的函数，是通过关键字 **operator** 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。\n>\n> ```c++\n> public static Box operator+ (Box b, Box c)\n> {\n>    Box box = new Box();\n>    box.length = b.length + c.length;\n>    box.height = b.height + c.height;\n>    return box;\n> }\n> ```\n\n# 异常类\n\n\n\nC# 异常是使用类来表示的。C# 中的异常类主要是直接或间接地派生于 **System.Exception** 类。**System.ApplicationException** 和 **System.SystemException** 类是派生于 System.Exception 类的异常类。**System.ApplicationException** 类支持由应用程序生成的异常。所以程序员定义的异常都应派生自该类。**System.SystemException** 类是所有预定义的系统异常的基类。\n\n","tags":["C#"],"categories":["C#基础"]},{"title":"C#基础","url":"/2021/08/01/csharp-01/","content":"\n# C#语言特点\n\n- C#是微软发布发一种面向对象的、运行于.NET Framework和.NET Core(开源，跨平台)之上的高级语言。\n- C#是一种**安全**的、**稳定**的、**简单**的、**优雅**的，由C和C++衍生出来的面向对象语言，它在继承C和C++强大功能的同时去掉了一些它们复杂的特性。<!--more-->\n\n#  C#与.NET的关系\n\n.NET是一个开发平台，而C#是一种在.NET开发平台上使用最多的编程语言。\n\n# .NET Framework\n\n.NET Framework 是一个可以快速开发、部署网站服务及应用程序的开发平台，是 Windows 中的一个组件，主要包括**公共语言运行库 CLR**（Common Language Runtime）和 **.NET Framework 类库FCL**（Framework Class Library）。\n\n- 在 .NET Framework 框架中支持的编程语言包括 C#、VB、C++、J# 等， 但目前使用最多的是 C# 语言。\n\n- **CLS**（Common Language Specification, 公共语言运行规范）定义了一组规则，即可以通过不同的编程语言（C#、VB、J# 等）来创建 Windows 应用程序、ASP.NET 网站程序以及在 .NET Framework 中所有支持的程序。\n\n- **CLR** 是 .NET Framework 的基础。用户可以将 CLR 看作一个在执行时管理代码的代码，它提供内存管理、线程管理和远程处理等核心服务，并且还强制实施严格类型安全以及可提高安全性和可靠性的管理。\n\n  它与 JVM类似。以公共语言运行库为目标的代码称为托管代码，不以公共语言运行库为目标的代码称为非托管代码。\n\n- **FCL** 中包括 Windows Forms （Windows 窗体程序）、ASP.NET（网站程序）、WPF（Windows 的界面程序的框架）、 WCF（Windows 平台上的工作流程序）等程序所用到的类库文件。\n\n- C# 6.0 版本已经能在多个操作系统上使用，例如在 Mac、Linux 等。此外，还能将其应用到手机、PDA 等设备上。\n\n# .Net Core\n\n.NET Core是一个**开源**的，**跨平台**的Framework，不管是开发web或移动设备都在同一个Framework（.NET Core）下运行，而且 .NET Core也可在不同的操作系统上运行，包括Windows、Linux、MacOS，实现了跨平台跨设备。\n.NET Core 在发布程序时不用事先安装Framework而是通过Nuget下载，这样在初次部署时就不用安装一个复杂而庞大Framework，而是按需下载。这种基于Nuget的按需加载铸就了.NET Core 跨平台。\n\n> NuGet 是免费、开源的包管理开发工具，专注于在 .NET 应用开发过程中，简单地合并第三方的组件库。\n\n# 数据类型\n\nC#数据类型分为：值类型、引用类型、指针类型。\n\n**值类型（Value types）**\n\n| **类型**   | **描述**                              | **范围**                                                | **默认值** |\n| :--------- | :------------------------------------ | :------------------------------------------------------ | :--------- |\n| **bool**   | 布尔值                                | True 或 False                                           | False      |\n| **byte**   | 1字节 无符号整数                      | 0 到 255                                                | 0          |\n| **char**   | 2字节 Unicode 字符                    | U +0000 到 U +ffff                                      | '\\0'       |\n| **short**  | 2字节 有符号整数类型                  | -32,768 到 32,767                                       | 0          |\n| **int**    | 4字节 有符号整数类型                  | -2,147,483,648 到 2,147,483,647                         | 0          |\n| **float**  | 4字节 单精度浮点型                    | -3.4 x 10<sup>38</sup> 到 + 3.4 x 10<sup>38</sup>       | 0.0F       |\n| **long**   | 8字节 有符号整数类型                  | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 0          |\n| **double** | 8字节 双精度浮点型                    | (+/-)5.0 x 10-324 到 (+/-)1.7 x 10308                   | 0.0D       |\n| decimal    | 16字节 精确的十进制值，28-29 有效位数 | (-7.9 x 1028 到 7.9 x 1028) / 100 到 28                 | 0.0M       |\n\n**引用类型（Reference types）**\n\n引用类型指的是一个内存位置，如果内存位置的数据是由一个变量改变的，则该引用类型变量会自动反应这种值的变化。内置的引用类型有：`object`、`dynamic` 和 `string`。\n\n- object 对象类型， 是 C# 所有数据类型的终极基类。object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。\n\n  当一个值类型转换为对象类型时，则被称为 **装箱**；另一方面，当一个对象类型转换为值类型时，则被称为 **拆箱**。\n\n- dynamic 动态数据类型， 用于存储任何类型的值，折现变量的类型检查发生在运行时。\n\n   动态类型与对象类型相似，但是对象类型的变量类型检查发生在编译时，而动态类型变量的类型检查发生在运行时。\n\n- string 字符串类型，是 System.String 类的别名。它是从对象（Object）类型派生的。String类型的值可以通过两种形式进行分配：引号和 @引号（加 @（称作\"逐字字符串\"）将转义字符（\\）当作普通字符对待）。\n\n**指针类型（Pointer types）**\n\n指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。\n\n# 类型转换\n\n- **隐式类型转换** - 这些转换是 C# 默认的以安全方式进行的转换, 不会导致数据丢失。例如，从小的整数类型转换为大的整数类型，从派生类转换为基类。小范围转大范围时使用。\n\n- **显式类型转换** - 强制类型转换。显式转换需要强制转换运算符，而且强制转换会造成数据丢失。\n\n  大范围转小范围时使用。\n\n```c++\n// 数值类型转换\nint intNum;\nlong longNum = 1;\nintNum = (int) longNum;// 大范围转小范围 需要强制类型转换\nlongNum = intNum;// 小范围转大范围 自动类型转换\nConsole.WriteLine(intNum);// 1\nConsole.WriteLine(longNum);// 1\n\n// 字符串转换数值\n// 方式一 int.Parse()\nint num1 = int.Parse(\"111\");\nConsole.WriteLine(num1);// 111\n// int num2 = int.Parse(\"a\");// 抛System.FormatException\n// 方式二 int.TryParse()\nbool isSuccess = int.TryParse(\"a\", out int num3);\nConsole.WriteLine(isSuccess);// False\nConsole.WriteLine(num3);// 0\n// 方式三 Convert.ToInt32()\n//int num4 = Convert.ToInt32(\"a\"); // 抛System.FormatException\n//Console.WriteLine(num4);\n\n// 引用类型之间的转换\nStudent student = new Student();\nobject obj = student as object;\nConsole.WriteLine(obj);\nobject obj1 = new object();\nStudent student1 = obj1 as Student;\nConsole.WriteLine(student1==null);// True 转换失败返回null\nobject obj2 = null as object;\nConsole.WriteLine(obj2 == null);// True\n```\n\n# 常量\n\n**整数常量**\n\n整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，没有前缀则表示十进制。\n\n整数常量也可以有后缀，可以是 U 和 L 的组合，其中，U 和 L 分别表示 unsigned 和 long。后缀可以是大写或者小写，多个后缀以任意顺序进行组合。\n\n定义常量：使用`const`关键字\n\n> const与readonly\n>\n> - const定义时就必须赋值且后续不能更改；\n> - readonly定义时可以不赋值，后续只能进行一次赋值。\n\n\n\n# 可空类型\n\n**?** 单问号用于对 **int、double、bool** 等无法直接赋值为 null 的数据类型进行 null 的赋值，意思是这个数据类型是 Nullable 类型的。\n\n```C++\nint i; //默认值0\nint? ii; //默认值null\n```\n\nNull合并运算符(**??**)，如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。\n\n```c++\nint? num1 = null;\nint? num2 = 666;\nint num3;\nnum3 = num1 ?? num2; // num1为空，所以返回num2。即num3的值为666\n```\n\n# 泛型约束\n\n默认情况下，泛型的类型参数可以是任何类型，通过泛型约束，可以只允许使用特定类型的泛型参数。\n![](csharp-01/1.png)\n\n# 协变、逆变、不变\n\n- 协变：当值作为返回值/out输出\n  - `public interface IEnumerable<out T>`\n\n- 逆变：当值作为输入/in\n  - `public delegate void Action<in T>`\n\n- 不变：当值既作为输入又作为输出\n  - `public interface List<T>`\n\n协变和逆变可以发生类型之间的转换。例如，`string`转`object`，而不变则不行。\n\n","tags":["C#"],"categories":["C#基础"]},{"title":"Nginx学习笔记","url":"/2021/02/21/nginx/","content":"\n## Nginx简介\n\nNginx是一个高性能的Http和反向代理服务器，特点是占有内存少，并发性能强。<!--more-->\n\n### 正向代理与反向代理\n\n**正向代理：**例如用户通过浏览器访问Google，直接访问是访问不到的，我们所使用的科学上网工具访问Google，就是一种正向代理：用户通过科学上网工具访问代理服务器，然后代理服务器去访问Google，将获取到的数据再返回给用户。\n\n**反向代理：**用户通过访问反向代理服务器，由反向代理服务器将请求分发给不同的服务器。用户对真正提供服务的服务器是无感知的，暴露给用户的是反向代理服务器，隐藏了真正提供服务的服务器。\n\n### 负载均衡\n\n随着访问网站访问并发量的增大，可以将原来的单体架构进行拆分，增加多台服务器，在用户访问服务器之前先访问反向代理服务器，由反向代理服务器将多个请求分发到多台服务器上，将负载分发到不同的服务单元，既保证了服务发可用性，也加快了请求的响应时间。\n\n###  动静分离\n\n为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析的速度，降低原来单个服务器的压力。\n\n## Windows下安装与启动\n\n下载完成后直接解压，命令行进入`nginx.exe`所在的文件路径，使用命令行执行相关命令\n\n```bash\n# 启动服务\nstart nginx\n\n# 关闭服务\nnginx -s stop\n\n# 重新加载服务\nnginx -s reload\n```\n\n启动后直接访问`localhost:80`\n\n## Nginx配置文件\n\n> 全局块：从配置文件开始到`events`之间的内容，主要影响`nginx`服务器整体运行的配置指令\n\n```bash\n# 表示可以支持的最大并发量\nworker_processes 1;\n```\n\n> events块：主要影响`nginx`服务器与用户的网络连接\n\n```bash\n# 表示支持的最大连接数\nworker_connections 1024;\n```\n\n> `http`块：配置最频繁的部分，nginx的主要功能就是在这里配置，包括`http`全局块和`server`块\n\n**在Nginx上部署前端项目，并通过反向代理的方式，实现跨域**\n\n```markdown\nserver {\n\t# 监听的IP和端口\n\tlisten       8080; \n\tserver_name  localhost;\n\n\tlocation / {\n\t\t# 前端项目，这里直接放在了nginx根目录下面，可以设置为代理服务器\n\t\troot   wms_front; \n\t\tindex  index.html index.htm;\n\t}\n\n\tlocation ~ /wms/ {\n\t\tproxy_pass  http://localhost:8081; # 配置自己后台访问的ip端口或域名\n\t}\n}\n```\n\n在访问`http://localhost:8080`时，实际访问的是`Nginx`根目录下的`wms_front/index.html`；\n`http://localhost:8080/wms/`下的所有请求都会转发到`http://localhost:8081/wms/`\n\n**负载均衡配置：**\n\n在`http`块添加：\n\n```markdown\nupstream myserver{\nip_hash;\nserver 192.168.1.1 weight=1;\nserver 192.168.1.2 weight=1;\nfair;\n}\nlocation / {\n\tproxy_pass  http://myserver;\n\tproxy_connection_timeout 10;\n}\n```\n\n> nginx分配策略：\n>\n> 1、轮询\n> 每个请求按照时间顺序逐一分配到不同的服务器，如果后端服务器宕机，则自动剔除。\n>\n> 2、权重\n> `weight`表示权重，默认为1，权重越高被分配的客户端越多 。\n>\n> 3、ip_hash\n> 每个请求按访问`ip`的`hash`结果分配，这样每个`ip`固定访问一个服务器，可解决`session`问题。\n>\n> 4、fair\n> 按后端服务器的响应时间分配，响应时间短的，优先分配。\n\n## Nginx原理\n\n在`nginx`启动后，会有一个`master`进程和多个`worker`进程，`master`进程主要用来管理`worker`进程，包括：接受信号，将信号分发给`worker`进程，监听`worker`进程工作状态，当`worker`进程退出时(非正常)，启动新的`worker`进程。基本的网络事件会交给`worker`进程处理。多个`worker`进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。\n<img src=\"nginx/1.jpg\" style=\"zoom:72%;\" />\n\n![](nginx/2.jpg)","tags":["Ngnix"],"categories":["JavaEE"]},{"title":"实习笔记2","url":"/2021/01/18/note-02/","content":"\n## 强引用、弱引用、软引用和虚引用\n\n**强引用**\n强引用不会被垃圾回收器回收，内存不足时抛出OOM。\n`new`创建对象时就是强引用，对象不使用时，将其设置为`null`，GC才会回收。<!--more-->\n例如`ArrayList`中的`clear()`方法：\n![](note-02/1.png)\n\n**软引用**\n如果一个对象只具有软引用，则**内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存**。只要垃圾回收器没有回收它，该对象就可以被程序使用。\n当内存不足时，`JVM`首先将**软引用**中的**对象**引用置为`null`，然后通知**垃圾回收器**进行回收。\n\n```java\n// 强引用\nString strongReference = new String(\"abc\");\n// 软引用\nString str = new String(\"abc\");\nSoftReference<String> softReference = new SoftReference<String>(str);\n```\n\n**弱引用**\n在GC线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，**不管当前内存空间足够与否，都会回收它的内存**。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n\n```java\n// 强引用\nString str = new String(\"abc\");\n// 弱引用\nWeakReference<String> weakReference = new WeakReference<>(str);\n// 弱引用转强引用\nString strongReference = weakReference.get();\n```\n\n![](note-02/2.png)\n因为`key`是弱引用，当`ThreadLocal`对象除了`Entry`对象外没有其他引用的时候，在下次`GC`就直接回收了，但是`value`会随着线程生命周期存在，所以就发生了内存泄漏。\n所以在`ThreadLocal`的源码中`remove`中调用`expungeStaleEntry`函数来解决这种情况：\n![](note-02/3.png)\n\n**虚引用**\n\n在任何时候都可能被垃圾回收器回收。    主要用来**跟踪对象**被垃圾回收器**回收**的活动。\n\n>虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n>\n>```java\n>String str = new String(\"abc\");\n>ReferenceQueue queue = new ReferenceQueue();\n>// 创建虚引用，要求必须与一个引用队列关联\n>PhantomReference pr = new PhantomReference(str, queue);\n>```\n\n## 代码规范\n\n**命名规范**\n\n1、名副其实，见名知意\n2、避免魔法值，使用全局常量、枚举\n\n**函数**\n\n1、一个函数只做一件事，保证短小\n2、函数名由动词 / 动词+名词 构成\n3、长而具有描述性的名称比短而令人费解的名称好\n4、函数传参控制在一个或两个以内，多参数封装成对象\n5、函数要么修改某对象的状态，要么返回该对象的信息\n\n**注释**\n\n注释是一种必须的恶，用来弥补我们使用代码表达意图时遭遇的失败，尽可能地少些注释，使用代码表达意图。\n\n**格式**\n\n1、函数、相关性不强的代码使用换行隔开\n2、调用者应该放在被调用者上面\n\n**异常**\n\n不要返回 null 值，在新方法中抛出异常或是返回特例对象，比如空对象、空列表`Collections.emptyList()`等。\n不要传递 null 值\n将异常处理与主要逻辑隔离\n\n**单元测试**\n可读性\n每个测试一个概念\n**类**\n单一权责原则\n内聚，类中的每一个变量都被每一个方法使用，则该类具有最大的内聚性\n\n## 匿名对象\n\n在创建对象时，只通过`new`的动作在堆内存开辟空间，却没有把堆内存空间的地址值赋值给栈内存的某个变量用以存储，也就是创建对象后没有再操作对象。\n\n**匿名对象特点：**\n\n1、由于我们没有记录堆内存对象的地址值，所以只能用一次，再次使用就找不到了。\n\n2、匿名对象的好处就是使用完毕就是垃圾，可以在垃圾回收器空闲时回收，节省内存空间。\n\n创建对象后如果没有再对该对象进行别的操作就返回了，可以直接返回匿名对象无需再为匿名对象赋值。\n\n```java\n/**\n* public User getUser(){\n*\t User user = new User();\n*    return user;\n* }\n**/\npublic User getUser(){\n\treturn new User();\n}\n```\n\n## 类型转换抽象类\n\n```java\n/**\n * Description: 转换类基类\n * @param <M> 待转对象类型\n * @param <N> 预转对象类型\n * @date 2021-2-20\n */\npublic abstract class AbstractConvertor<M, N> {\n\t/**\n\t * Description: 单个对象转换\n\t * @param m 待转对象\n\t * @return 转换后的对象\n\t */\n\tpublic abstract N convert(M m);\n\n\t/**\n\t * Description: 单个对象反向转换\n\t * @param n 待转对象\n\t * @return 转换后的对象\n\t */\n\tpublic abstract M reverseConvert(N n);\n\n\t/**\n\t * Description: 集合转换\n\t * @param mList 待转对象集合\n\t * @return 转换后的对象集合\n\t */\n\tpublic List<N> convert(List<M> mList) {\n\t\tList<N> nList = null;\n\t\tif (mList != null) {\n\t\t\tnList = new ArrayList<N>(mList.size());\n\t\t\tfor (M m : mList) {\n\t\t\t\tnList.add(convert(m));\n\t\t\t}\n\t\t}\n\t\treturn nList;\n\t}\n\n\t/**\n\t * Description: 集合转换\n\t * @param mList 待转对象集合\n\t * @return 转换后的对象集合\n\t */\n\tpublic List<M> reverseConvert(List<N> nList) {\n\t\tList<M> mList = null;\n\t\tif (nList != null) {\n\t\t\tmList = new ArrayList<M>(nList.size());\n\t\t\tfor (N n : nList) {\n\t\t\t\tmList.add(reverseConvert(n));\n\t\t\t}\n\t\t}\n\t\treturn mList;\n\t}\n}\n```\n\n## 时间日期转换工具类\n\n```java\npublic class DateUtil {\n\n    private DateUtile(){}\n    /**\n     * 年月日时分秒格式的日期转化为字符串\n     * @param date\n     * @return\n     */\n    public static String formatDateTime(Date date){\n        if(null == date){\n            return null;\n        }\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return sdf.format(date);\n    }\n\n    /**\n     * 年月日时分秒格式的字符串转化为日期\n     * @param str\n     * @return\n     */\n    public static Date parseDateTime(String str){\n        if(null == str){\n            return null;\n        }\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        Date date = null;\n        try {\n            date = sdf.parse(str);\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n        return date;\n    }\n\n    /**\n     * 年月日格式的日期转化为字符串\n     * @param date\n     * @return\n     */\n    public static String formatDate(Date date){\n        if(null == date){\n            return null;\n        }\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        return sdf.format(date);\n    }\n\n    /**\n     * 年月日格式的字符串转化为日期\n     * @param str\n     * @return\n     */\n    public static Date parseDate(String str){\n        if(null == str){\n            return null;\n        }\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        Date date = null;\n        try {\n            date = sdf.parse(str);\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n        return date;\n    }\n\n    /**\n     * 时分秒格式的日期转化为字符串\n     * @param date\n     * @return\n     */\n    public static String formatTime(Date date){\n        if(null == date){\n            return null;\n        }\n        SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n        return sdf.format(date);\n    }\n\n    /**\n     * 时分秒格式的字符串转化为日期\n     * @param str\n     * @return\n     */\n    public static Date parseTime(String str){\n        if(null == str){\n            return null;\n        }\n        SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n        Date date = null;\n        try {\n            date = sdf.parse(str);\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n        return date;\n    }\n}\n```\n\n","tags":["实习笔记"],"categories":["实习笔记"]},{"title":"Springboot整合ElasticSearch","url":"/2020/12/27/elasticsearch-02/","content":"\n1、创建项目时勾选：<!--more-->\n![](elasticsearch-02/1.png)\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-elasticsearch</artifactId>\n</dependency>\n```\n\n2、创建`RestHighLevelClient`对象并注入容器\n\n```java\n@Configuration\npublic class ElasticSearchConfig extends AbstractElasticsearchConfiguration {\n\n    @Bean\n    @Override\n    public RestHighLevelClient elasticsearchClient() {\n        // 定义客户端配置对象\n        final ClientConfiguration clientConfiguration = ClientConfiguration.builder()\n                .connectedTo(\"localhost:9200\")\n                .build();\n        // 使用 RestClients创建对象\n        return RestClients.create(clientConfiguration).rest();\n    }\n}\n```\n\n3、使用`RestHighLevelClient`进行crud\n\n```java\n@SpringBootTest\nclass Elasticsearch01ApplicationTests {\n\n    @Autowired\n    private RestHighLevelClient restHighLevelClient;\n\n    @Test\n    public void testInsert() throws IOException {\n        User user = new User();\n        user.setName(\"李四四\");\n        user.setAge(29);\n        IndexRequest indexRequest = new IndexRequest(\"test\", \"user\", \"6\");\n        indexRequest.source(JSON.toJSONString(user), XContentType.JSON);\n        IndexResponse indexResponse = restHighLevelClient.index(indexRequest, RequestOptions.DEFAULT);\n        System.out.println(indexResponse.status());\n    }\n\n    @Test\n    public void testUpdate() throws IOException {\n        User user = new User();\n        user.setName(\"张三\");\n        user.setAge(18);\n        UpdateRequest updateRequest = new UpdateRequest(\"test\",\"user\", \"4\");\n        updateRequest.doc(JSON.toJSONString(user),XContentType.JSON);\n        UpdateResponse updateResponse = restHighLevelClient.update(updateRequest, RequestOptions.DEFAULT);\n        System.out.println(updateResponse.status());\n    }\n\n    @Test\n    public void testDelete() throws IOException {\n        DeleteRequest deleteRequest = new DeleteRequest(\"test\", \"1\");\n        DeleteResponse deleteResponse = restHighLevelClient.delete(deleteRequest, RequestOptions.DEFAULT);\n        System.out.println(deleteResponse.status());\n    }\n\n    @Test\n    public void testSearch() throws IOException {\n        SearchRequest searchRequest = new SearchRequest(\"test\");\n        // 搜索条件\n        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n        searchSourceBuilder.query(QueryBuilders.matchQuery(\"name\", \"张\"))\n                .sort(\"age\", SortOrder.DESC)\n                .postFilter(QueryBuilders.rangeQuery(\"age\").gt(22))\n            \t.highlighter(new HighlightBuilder().field(\"name\"));    .from(0)\n                .size(2);\n        searchRequest.source(searchSourceBuilder);\n        // 发起搜索请求\n        SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);\n        TotalHits totalHits = searchResponse.getHits().getTotalHits();\n        System.out.println(\"文档总数：\" + totalHits);\n        float maxScore = searchResponse.getHits().getMaxScore();\n        System.out.println(\"最高命中得分：\" + maxScore);\n        SearchHit[] searchHits = searchResponse.getHits().getHits();\n        for (SearchHit searchHit : searchHits) {\n            System.out.println(searchHit.getSourceAsMap());\n        }\n\n    }\n}\n\n```\n\n4、使用`ElasticSearchRepository`进行简单的crud\n4.1 在实体类中添加注解：\n\n```java\n@Data\n// 映射文档\n@Document(indexName = \"test\")\npublic class User {\n    @Id\n    private String id;\n    @Field(type = FieldType.Text,analyzer = \"ik_max_word\")\n    private String name;\n    @Field(type = FieldType.Integer)\n    private Integer age;\n}\n```\n\n4.2 添加自定义接口并继承`ElasticsearchRepository<T,T>`\n\n```java\npublic interface UserRepository extends ElasticsearchRepository<User,String> {\n}\n```\n\n4.3 使用自定义的接口操作数据\n\n```java\n@SpringBootTest\npublic class TestUserRepository {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Test\n    public void testSave(){\n        User user = new User();\n        // id不存在保存，存在则更新\n        user.setId(UUID.randomUUID().toString().replace(\"-\",\"\"));\n        user.setName(\"张伟\");\n        user.setAge(10);\n        userRepository.save(user);\n    }\n\n    @Test\n    public void testDelete(){\n        // deleteAll 删除所有\n        userRepository.deleteById(\"d6d99c19-6a8d-4ab5-bd71-f2586e07b28b\");\n    }\n\n    @Test\n    public void testFindOne(){\n        Optional<User> userOptional = userRepository.findById(\"2\");\n        System.out.println(userOptional.get());\n    }\n\n    @Test\n    public void testFindAll(){\n        // 排序\n        Iterable<User> all = userRepository.findAll(Sort.by(Sort.Order.desc(\"age\")));\n        // 分页\n        Page<User> all1 = userRepository.findAll(PageRequest.of(1, 2));\n        all1.forEach(user -> System.out.println(user));\n    }\n}\n```\n\n","tags":["ElasticSearch"],"categories":["中间件"]},{"title":"ElasticSearch基础知识","url":"/2020/12/23/elasticsearch/","content":"\n## ElasticSearch的安装与启动\n\n配置ElasticSearch支持跨域：config/elasticsearch.yml<!--more-->\n\n```yml\nhttp.cors.enabled: true\nhttp.cors.allow-origin: \"*\"\n```\n\n下载或在Google Chrome中添加ElasticSearch Head 插件，用于连接ElasticSearch搜索引擎，并提供可视化的操作页面对ElasticSearch搜索引擎进行各种设置和数据检索功能的管理。\n启动ElasticSearch后，进行连接测试：\n![](elasticSearch/1.png)\n\n## ElasticSearch核心概念\n\nelasticsearch是面向文档的。\n**indices索引**类似于关系型数据库中的**数据库**，默认将索引划分为多个分片，每个分片可以在集群中的不同的服务器之间进行迁移；一个分片就是一个Lucene索引，一个包含**倒排索引**的文件目录，有利于全文搜索。\n**document文档**类似于关系型数据库中的**行**，索引和搜索的基本单位就是文档，就是一条条json数据；\n**fields**类似于关系型数据库中的**字段**；\ntype类似于数据库中的表 （慢慢被废弃）。\n\n## ELK的简介\n\nELK是ElasticSearch、Logstash、Kiban三大开源框架的简称，一般用于日志的分析和收集等场景。\nElasticSearch是基于Lucene的分布式搜索引擎。\nLogstash是ELK的中央数据流引擎，用于从不同目标（文件、MQ）中收集不同格式数据，经过过滤后输出到目的地（文件、MQ、reids、elasticsearch等）。\nKibana可将ElasticSearch中的数据进行友好的展示，并提供实时的分析功能。\n\n## Kibana的安装启动\n\n启动ElasticSearch后，再启动Kibanna后访问`http://localhost:5601`\n\n## 安装IK分词器\n\n下载完成后解压到elasticsearch的plugins目录下即可。\n\n在kibana的控制台进行测试：\n\n> 最小切分 ik_smart\n\n```bash\nGET _analyze\n{\n  \"analyzer\": \"ik_smart\",\n  \"text\": \"今天是平安夜\"\n}\n```\n\n```json\n{\n \"tokens\" : [\n    {\n      \"token\" : \"今天是\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 3,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"平安夜\",\n      \"start_offset\" : 3,\n      \"end_offset\" : 6,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 1\n    }\n  ]\n}\n```\n\n> 最细粒度划分 ik_max_word\n\n```bash\nGET _analyze\n{\n  \"analyzer\": \"ik_max_word\",\n  \"text\": \"今天是平安夜\"\n}\n```\n\n```json\n{\n   \"tokens\" : [\n    {\n      \"token\" : \"今天是\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 3,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"今天\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 2,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"是\",\n      \"start_offset\" : 2,\n      \"end_offset\" : 3,\n      \"type\" : \"CN_CHAR\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"平安夜\",\n      \"start_offset\" : 3,\n      \"end_offset\" : 6,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 3\n    },\n    {\n      \"token\" : \"平安\",\n      \"start_offset\" : 3,\n      \"end_offset\" : 5,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 4\n    },\n    {\n      \"token\" : \"夜\",\n      \"start_offset\" : 5,\n      \"end_offset\" : 6,\n      \"type\" : \"CN_CHAR\",\n      \"position\" : 5\n    }\n  ]\n}\n```\n\n在ik分词器的config目录下可以自定义字典，并进行配置\n<img src=\"elasticSearch/2.png\" style=\"zoom:80%;\" />\n\n## Restful\n\n一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。\n\n一句话描述：**URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。**\n\n## ElasticSearch基本操作\n\n1、创建索引并添加文档\n`PUT /索引名/类型名/文档id {请求体}`\n![](elasticSearch/3.png)\n\n发送请求完成后，就创建了一条索引：\n![](elasticSearch/4.png)\n\n2、设置映射规则（字段类型）\n![](elasticSearch/5.png)\n\n3、获取索引信息：`GET /test2`\n\n4、查看所有索引的信息：`GET _cat/indices?v`\n![](elasticSearch/6.png)\n\n5、修改索引中的文档\n`POST /test3/_doc/1/_update {\"doc\":{\"name\":\"zhangyuzhen\"}}`\n![](elasticSearch/7.png)\n\n6、删除索引：`DELETE /test3`\n\n7、获取文档\n创建索引并添加几条文档：\n![](elasticSearch/8.png)\n\n获取第一条文档数据： `GET /test/user/1`\n![](elasticSearch/9.png)\n\n指定条件获取数据：`GET /test/user_search?q=name:lisi`\n\n**复杂搜索：**\n\n条件匹配与结果过滤：![](elasticSearch/10.png)\n\n排序与分页：\n![](elasticSearch/11.png)\n\nbool多条件查询：\n![](elasticSearch/12.png)\n\n过滤器：\n![](elasticSearch/13.png)\n\n> - gt 大于\n> - gte 大于等于\n> - lt 小于\n> - lte 小于等于\n\n精确查询：\nterm，直接通过倒排索引指定的词条进行精确查找。\nmatch，使用分词器解析。   \n\n> keyword类型不会被分词器解析\n\n查询关键字高亮：\n![](elasticSearch/14.png)","tags":["ElasticSearch"],"categories":["中间件"]},{"title":"实习笔记1","url":"/2020/11/28/note/","content":"\n## 数据库\n\n- 【强制】主键索引名为pk_字段名；\n\n  ​\t唯一索引名为uk_字段名；\n\n  ​\t普通索引名则为idx_字段名。\n\n  ​\t说明：pk_ 即primary key；uk_ 即unique key；idx_ 即index的简称。<!--more-->\n\n- 【强制】表必备三字段：id, gmt_create, gmt_modified。\n\n  说明：其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。gmt_create, gmt_modified的类型均为datetime类型，前者现在时表示主动创建，后者过去分词表示被动更新。gmt表示格林威治时间即国际时间。\n\n  ```sql\n  # DEFAULT CURRENT_TIMESTAMP  表示当插入数据的时候，该字段默认值为当前时间\n  # ON UPDATE CURRENT_TIMESTAM  表示每次更新这条数据的时候，该字段都会更新成当前时间\n  CREATE TABLE `test` (\n  `id` bigint(20) NOT NULL COMMENT '主键id',\n  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间')\n  ```\n\n- 【强制】POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射。说明：参见定义POJO类以及数据库字段定义规定，在`<resultMap>`中增加映射，是必须的。在MyBatis Generator生成的代码中，需要进行对应的修改。\n\n- 自增ID与UUID\n\n  - 自增ID数据存储空间小，性能好，但是安全性低，很难处理分布式存储的数据表，处理大量数据可能会超过自增长的取值范围\n\n  - uuid_short() 生成18位正随机数 ===>bigint(20)\n\n   ```xml\n    <insert id=\"addLocationArea\"\n             parameterType=\"\">\n         INSERT INTO location( ... )\n         VALUES\n         (SHORT_UUID(), ...)\n     </insert>\n   ```\n  \n  - 随机正Long值uuid ===>bigint(20)\n  \n  ```java\n  public synchronized static Long getUUID() {\n      // 生成19位正随机数\n      return UUID.randomUUID().getLeastSignificantBits() * -1;\n  }\n  ```\n  \n- MySQL字段尽量避免NULL，应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，而且对表索引时不会存储NULL值的，所以如果索引的字段可以为NULL，索引的效率会下降很多。因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。\n\n  ```sql\n  # 查询出来的的记录中col列可以为''(空字符串)\n  SELECT * FROM `table` WHERE col IS NOT NULL;\n  # 查询col列不为''的所有记录\n  SELECT * FROM `table` WHERE col1 <> ''; \n  ```\n\n  ### crud\n\n- 模糊搜索： \n\n  ```sql\n  select id,name from product where name like concat('%',#{name,jdbcType=varchar},'%')\n  ```\n\n\n- 根据不确定的字段条件进行查询：\n\n  ```xml\n  <resultMap id=\"ResultMap\" type=\"com.zyz.UserPO\">\n  \t<id column=\"id\" property=\"id\" jdbcType=\"BIGINT\"/>\n      <result column=\"name\" property=\"name\" jdbcType=\"VARCHAR\" />\n      <result column=\"password\" property=\"password\" jdbcType=\"VARCHAR\" />\n      <collection property=\"userItemPOList\" ofType=\"com.zyz.UserItemPO\">\n      \t<!--property对应UserPO中的明细对象集合  ofType对应集合对象的实体类-->\n          <id column=\"item_id\" property=\"id\" jdbcType=\"BIGINT\"/>\n          <result column=\"school_name\" property=\"name\" jdbcType=\"VARCHAR\" />\n          <result column=\"school_address\" property=\"address\" jdbcType=\"VARCHAR\" />\n          <!--column属性为联表查询中主表以外的表的字段别名-->\n      </collection>\n  </resultMap>\n  \n  <sql id=\"Base_Column_List\" >\n  \tid,name,password\n  </sql>\n  \n  <select id=\"list\" resultMap=\"ResultMap\">\n          select\n          <include refid=\"Base_Column_List\" />\n          from t_user\n          where 1=1\n          <if test=\"PO.id != null\" >\n              and id = #{PO.id,jdbcType=BIGINT}\n          </if>\n          <if test=\"PO.name != null\">\n              and name = #{PO.name,jdbcType=VARCHAR}\n          </if>\n  </select>\n  \n  \n  <!--批量条件查询  根据商品明细列表中的所有id查询对应的明细详情-->\n  <select id=\"list\" resultMap=\"ResultMap\">\n          SELECT\n          <include refid=\"chargeofforderitemdetailColumns\" />\n          FROM chargeofforderitemdetail\n          <where>\n              <if test=\"chargeOfforderItemIdList != null and chargeOfforderItemIdList.size() > 0\">\n                  ChargeOfforderItem_Id in\n                  <foreach collection=\"chargeOfforderItemIdList\" item=\"item\" separator=\",\" open=\"(\" close=\")\">\n                      #{item,jdbcType=VARCHAR}\n                  </foreach>\n              </if>\n          </where>\n  </select>\n  ```\n\n- 插入不确定的属性字段\n\n  ```xml\n  <insert id=\"insert\">\n      insert into table\n      <trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\">\n              id,\n          <if test=\"PO.name != null\">\n              name,\n          </if>\n          create_Time,\n          lastUpdate_Time\n      </trim>\n      <trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\">\n           UUID_SHORT(),\n           <if test=\"PO.name != null\">\n               #{PO.name,jdbcType=VARCHAR},\n           </if>\n           now(),\n           now()\n     </trim>\n  </insert>\n  ```\n  \n- 批量插入\n\n  ```xml\n  <insert id=\"insertbatch\" parameterType=\"java.util.List\" >\n      insert into user(Id,name)values\n      <foreach collection=\"list\" item=\"item\" separator=\",\" index=\"index\">\n          (\n          UUID_SHORT(),\n          #{item.name,jdbcType=VARCHAR}\n          )\n      </foreach>\n  </insert>\n  ```\n  \n- 根据不确定的字段条件进行更新\n\n  ```xml\n  <update id=\"update\">\n      update table\n      <set>\n          <if test=\"PO.state != null\">\n              name = #{PO.name,jdbcType=VARCHAR},\n          </if>\n          <if test=\"PO.password != null\">\n              password = #{PO.password,jdbcType=VARCHAR},\n          </if>\n      </set>\n      where id = #{PO.id,jdbc=BIGINT}\n  </update>\n  ```\n\n- 时间段的处理\n\n  ```xml\n  <if test=\"beginTime != null\">\n        and <![CDATA[ BusinessTime >=  #{beginTime,jdbcType=TIMESTAMP} ]]>\n  </if>\n  <if test=\"endTime != null\">\n        and <![CDATA[ BusinessTime <=  #{endTime,jdbcType=TIMESTAMP} ]]>\n  </if>\n  ```\n\n## 框架\n\n### Spring缓存注解\n\n- Spring Cache是作用在方法上的，当我们在调用一个缓存方法时会把该方法参数和返回结果作为一个键值对存放在缓存中，等到下次调用同样的参数来调用该方法时将不再执行该方法，而是直接从缓存中获取结果进行返回。\n\n- `@Cacheable(key=\"\" , value=\"\")` 用于**查询**的方法\n\n- `@CacheEvict(key=\"\" , value=\"\")` 调用此注解下的方法时会清除缓存，用于**增删改**方法\n\n   key属性是用来指定Spring缓存方法的**返回结果时对应的key**，value属性用来指定**缓存名称**。\n\n- 使用场景：业务层bl中的关于用户的基础增删改查功能。\n\n- **以后不会使用此方式了，因为不能指定数据有效时间，以及读取改变的数据不够灵活。一般使用RedisTemple或者自定义注解的方式。**\n\n### @Transactional\n\n- 一般在bl层的方法中执行多条sql时使用\n  - `@Transactional(rollbackFor = { Exception.class })`\n  - 默认发生`Error`或`RuntimeException`时才会回滚，发生非运行时异常时不会回滚，需要使用`rollbackFor`属性指定回滚的非运行时异常。\n\n### Controller中的Model参数\n\n- 只有在前端请求有页面返回的时候用到，保存了想要展示在页面上的数据。\n- 例如数据的导出时，使用到了Model参数。\n\n### 自定义注解中的元注解\n\n```java\n// 定义注解使用的时机 METHOD->适用于方法  TYPE->适用于 class,interface,enum\n@Target({ElementType.METHOD, ElementType.TYPE})\n// 在运行时去动态获取注解信息\n@Retention(RetentionPolicy.RUNTIME)\n```\n\n### 全局异常处理\n\n对类添加`@ControllerAdvice`注解，在处理异常的方法前添加\n\n```java\n@ResponseStatus(HttpStatus.OK)\n@ExceptionHandler({Exception.class})\n@ResponseBody\n```\n\n### CommandLineRunner接口\n\n在应用初始化后，去执行一段代码块逻辑，这段初始化代码在整个应用生命周期内只会执行一次。\n\n用于预先加载数据，实现`CommandLineRunner`接口，需要加载的数据的逻辑写在`run()`方法中。\n\n可使用`@Order(1)`，`@Order(2)`......注解指定加载顺序。\n\n### 对象的有状态与无状态\n\n- 是否存储数据\n\n- 无状态的Bean适合用单例模式，这样可以共享实例，提高性能。有状态的Bean，多线程环境下不安全，那么适合用Prototype原型模式。Prototype: 每次对bean的请求都会创建一个新的bean实例。\n\n### Controller中的返回数据\n\n- `ResponseAdvisor`对返回数据进行了拦截，然后统一处理，所有的controller只需要返回业务相关数据即可。\n\n\n```java\n@ControllerAdvice // 对controller的全局配置\npublic class ResponseAdvisor implements ResponseBodyAdvice<Object> {\n\n    @Override\n    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {\n        return true;\n    }\n\n    @Override\n    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,\n                                  Class<? extends HttpMessageConverter<?>> selectedConverterType, ServerHttpRequest request,\n                                  ServerHttpResponse response) {\n\n        if (body instanceof Result) {\n            return body;\n        }\n        // 处理数据，将业务数据封装成自定义的结果集对象Result \n        return RetResponse.makeOKRsp(body);\n    }\n}\n```\n\n  `RetResponse`对controller返回的业务数据封装成自定义的 Result对象返回给前端\n\n  ```java\n/**\n * 响应结果封装 对controller返回的参数封装成自定义的 Result对象返回给前端\n */\npublic class RetResponse {\n\n\tpublic static <T> Result<T> makeOKRsp(T data, String msg) {\n\t\treturn new Result<T>().setCode(ResultCode.SUCCESS) // 200\n\t\t\t\t.setResult(WebConstants.RESULT_SUCCESS)// success\n\t\t\t\t.setData(data).setMsg(msg);// 结果信息\n\t}\n    \n\tpublic static <T> Result<T> makeOKRsp(T data) {\n\t\treturn new Result<T>()\n  .setCode(ResultCode.SUCCESS).setResult(WebConstants.RESULT_SUCCESS).setData(data);\n\t}\n    \n\tpublic static <T> Result<T> makeOKRsp() {\n\t\treturn new Result<T>()\n            .setCode(ResultCode.SUCCESS).setResult(WebConstants.RESULT_SUCCESS);\n\t}\n\tpublic static <T> Result<T> makeErrRsp(T data, String msg) {\n\t\treturn new Result<T>()          \t\t\t                                                 .setCode(ResultCode.INTERNAL_SERVER_ERROR)\n            .setResult(WebConstants.RESULT_FAILED).setData(data).setMsg(msg);\n\t}\n    \n\tpublic static <T> Result<T> makeFailRsp(T data, String msg) {\n\t\treturn new Result<T>()                                              \t\t\t             .setCode(ResultCode.FAIL)\n            .setResult(WebConstants.RESULT_FAILED).setData(data).setMsg(msg);\n\t}\n    \n\tpublic static <T> Result<T> makeRsp(String code) {\n\t\treturn new Result<T>().setCode(Integer.valueOf(code));\n\t}\n    \n\tpublic static <T> Result<T> makeRsp(String code, String msg) {\n\t\treturn new Result<T>().setCode(Integer.valueOf(code)).setMsg(msg);\n\t}\n    \n\tpublic static <T> Result<T> makeExceptionRsp(String code, String msg) {\n\t\treturn new Result<T>()\n            .setCode(Integer.valueOf(code))\n            .setMsg(msg).setResult(WebConstants.RESULT_FAILED);\n\t}\n    \n\tpublic static <T> Result<T> makeRsp(Integer code, String msg, T data, String result){\n\t\treturn new Result<T>()\n            .setCode(code).setMsg(msg).setData(data).setResult(result);\n\t}\n}\n  ```\n\n  `Result`自定义结果集封装对象\n\n  ```java\n@Data\npublic class Result<T> {\n    // 响应码\n    private int code;\n    // 状态信息\n    private String msg;\n    // 返回数据\n    private T data;\n    // 返回常量\n    private String result;\n\n    public Result() {\n\n    }\n\n    /**\n      * 异常构造方法\n      * @param exception\n      */\n    public Result(Exception exception) {\n        this.result = WebConstants.RESULT_FAILED;\n        this.msg = exception.getMessage();\n        this.data = (T) exception.getMessage();\n    }\n\n    public Result(String message, Exception exception) {\n        this(exception);\n        this.msg = message;\n    }\n    \n    public Result(String message, Exception exception, Boolean success) {\n        this(exception);\n        this.code = ResultCode.FAIL.code();\n        this.msg = message;\n        this.result = WebConstants.RESULT_SUCCESS;\n    }\n    \n    public Result(String message, Exception exception, Integer code) {\n        this(exception);\n        this.msg = message;\n    }\n\n     public Result setCode(ResultCode resultCode) {\n        this.code = resultCode.code();\n        return this;\n    }\n\n    public int getCode() {\n        return code;\n    }\n\n    public T getData() {\n        return data;\n    }\n\n    public Result setData(T data) {\n        this.data = data;\n        return this;\n    }\n\n    public Result setCode(int code) {\n        this.code = code;\n        return this;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    public Result setMsg(String msg) {\n        this.msg = msg;\n        return this;\n\n    }\n\n    public String getResult() {\n        return result;\n    }\n\n    public Result setResult(String result) {\n        this.result = result;\n        return this;\n    }\n}\n  ```\n\n响应码枚举类\n\n```java\npublic enum ResultCode {\n    SUCCESS(200),//成功\n    FAIL(400),//失败\n    UNAUTHORIZED(401),//未认证（签名错误）\n    NOT_FOUND(404),//接口不存在\n    INTERNAL_SERVER_ERROR(500);//服务器内部错误\n\n    private final int code;\n\n    ResultCode(int code) {\n        this.code = code;\n    }\n\n    public int code() {\n        return code;\n    }\n\n}\n```\n\n返回常量\n\n```java\npublic class WebConstants {\n   // 返还成功\n   public static final String RESULT_SUCCESS = \"success\";\n   // 返还异常-业务异常\n   public static final String RESULT_FAILED = \"fail\";\n   // 返还失败-系统异常\n   public static final String RESULT_ERROR = \"error\";\n   // token\n   public static final String HEADER_TOKEN = \"Atoken\";\n   // Token验证失败,用户验证异常\n   public static final Integer AUTH_VALIDATE_FAILED = -1;\n   public static final String SERVICE_ERROR_TIPS = \"服务内部异常，请稍后再试\";\n}\n```\n\n- 时间格式化\n\n  ```java\n  @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\n  private Date createTime;\n  ```\n\n- 在数据库中不能为空的字段在ServiceImpl中使用 `AssertUtils.notNull(字段,\"参数不能为空\")  `进行断言，参数为空抛出异常信息。\n\n- 调用过程：\n\n  controller (dto)->service接口(dto)->serviceImpl实现类(dto)：使用@Service注解->bl(dto)实现类：使用@Service注解->mapper(po)接口（对应mapper.xml文件）->mysql\n  \n- 当前时间：\n\n  ```java\n  Timestamp timestamp = new Timestamp(System.currentTimeMillis());\n  System.out.println(timestamp);// 2020-12-10 11:03:11.976\n  SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n  String timestampDF = df.format(timestamp);\n  System.out.println(timestampDF);// 2020-12-11 11:19:51\n  Date parseDate = DateUtils.parseDate(timestampDF, \"yyyy-MM-dd HH:mm:ss\");\n  System.out.println(parseDate);// Fri Dec 11 11:20:23 CST 2020\n  ```\n\n### 分页\n\n分页结果集：\n\n```java\npublic class PageList<T extends Serializable> implements Serializable {\n    private static final long serialVersionUID = -6177180431483012580L;\n    /**\n     * 返回的数据集合\n     */\n    private List<T> dataList;\n\n    /**\n     * 返回的分页对象信息\n     */\n    private Pager pager;\n\n    public List<T> getDataList() {\n        return dataList;\n    }\n\n    public void setDataList(List<T> dataList) {\n        this.dataList = dataList;\n    }\n\n    public Pager getPager() {\n        return pager;\n    }\n\n    public void setPager(Pager pager) {\n        this.pager = pager;\n    }\n}\n```\n\n```java\npublic class Pager extends PagerCondition {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * 总记录数\n     */\n    private Integer recordCount;\n\n    /**\n     * 总页数\n     */\n    private Integer totalPage;\n\n    public Pager() {\n        super();\n    }\n\n    public Pager(Integer currentPage, Integer pageSize, Integer recordCount) {\n        super(currentPage, pageSize);\n        this.recordCount = recordCount;\n        Integer totalPageSize = recordCount / pageSize;\n        Integer remailder = recordCount % pageSize;\n        // 如果总记录数与每页显示条数的余数大于0，总页数加1\n        if (remailder > 0) {\n            totalPageSize = totalPageSize + 1;\n        }\n        totalPage = totalPageSize;\n\n    }\n\n    public Pager(PagerCondition pageCondition, Integer recordCount) {\n        setCurrentPage(pageCondition.getCurrentPage());\n        setPageSize(pageCondition.getPageSize());\n        setRecordCount(recordCount);\n        setTotalPage((recordCount + getPageSize() - 1) / getPageSize());\n    }\n\n    public Integer getRecordCount() {\n        return recordCount;\n    }\n\n    public void setRecordCount(Integer recordCount) {\n        this.recordCount = recordCount;\n    }\n\n    public Integer getTotalPage() {\n        return totalPage;\n    }\n\n    public void setTotalPage(Integer totalPage) {\n        this.totalPage = totalPage;\n    }\n}\n```\n\n分页结果集中的分页参数：\n\n```java\npublic class PagerCondition implements Serializable {\n\n   private static final long serialVersionUID = 1L;\n\n   /**\n    * @Fields 当前页\n    */\n   private Integer currentPage = 1;\n\n   /**\n    * @Fields 每页的数量\n    */\n   private Integer pageSize = 20;\n\n   public PagerCondition() {\n      super();\n   }\n\n   public PagerCondition(Integer currentPage) {\n      super();\n\n      if (currentPage != null)\n         this.currentPage = currentPage;\n\n      this.pageSize = 20;\n   }\n\n   public PagerCondition(Integer currentPage, Integer pageSize) {\n      super();\n\n      if (currentPage != null)\n         this.currentPage = currentPage;\n\n      this.pageSize = pageSize;\n   }\n\n   public Integer getCurrentPage() {\n      return currentPage;\n   }\n\n   public Integer getLimitnum() {\n      return this.getPageSize();\n   }\n\n   public Integer getOffset() {\n      return (this.getCurrentPage() - 1) * this.getPageSize();\n   }\n\n   public Integer getPageSize() {\n      if (pageSize == null || pageSize <= 0)\n         return 20;\n      else\n         return pageSize;\n   }\n\n   public Integer getPreviousPage() {\n      if (this.currentPage > 0) {\n         return this.currentPage - 1;\n      } else {\n         return 0;\n      }\n   }\n\n   public void setCurrentPage(Integer currentPage) {\n      this.currentPage = currentPage;\n   }\n\n   public void setPageSize(Integer pageSize) {\n      this.pageSize = pageSize;\n   }\n\n   public Integer startRow() {\n      int startRow = 0;\n      if (currentPage != 1) {\n         startRow = (currentPage - 1) * pageSize;\n      }\n      return startRow;\n   }\n}\n```\n\n数据库查询返回分页结果集：\n\n```java\n// 这里的Page是PageHelper内部定义的Page\npublic class PageResult<E extends Serializable> extends Page<E> {\n\n    /**\n     * 转换为PageList\n     * @return 转换结果\n     */\n    public PageList<E> toPageList() {\n        final PageList<E> pageList = new PageList<>();\n        pageList.setPager(getPager());\n        pageList.setDataList(new ArrayList<>(this));\n        return pageList;\n    }\n\n    public Pager getPager() {\n        final Pager pager = new Pager();\n        pager.setPageSize(getPageSize());\n        pager.setCurrentPage(getPageNum());\n        pager.setRecordCount(Math.toIntExact(getTotal()));\n        pager.setTotalPage(getPages());\n        return pager;\n    }\n}\n```\n\n并结合PageHelper实现分页，PageHelper分页的实现原理就是，通过PageHelper内部的拦截器在我们执行SQL语句之前动态的将SQL语句拼接分页的语句。\n\n配置好PageHelper后，在每次查询前设置Page参数即可完成分页：\n\n```java\nPageHelper.startPage(queryDTO.getCurrentPage(), queryDTO.getPageSize());\n```\n\n通过实现Mybatis拦截器实现分页参数的传递：\n\n添加配置文件，将自定义的拦截器和pageHelper的拦截器配置到mybatis.xml中\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<configuration>\n    <settings>\n        <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n    </settings>\n\n    <plugins>\n        <plugin interceptor=\"com.github.pagehelper.PageInterceptor\"/>\n        <plugin interceptor=\"com.zyz.config.PageResultEnhancer\"/>\n    </plugins>\n</configuration>\n```\n\n```java\n@Intercepts(@Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}))\npublic class PageResultEnhancer implements Interceptor {\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Object intercept(Invocation invocation) throws Throwable {\n        final Object result = invocation.proceed();\n        if (result instanceof Page) {\n            final Page page = (Page) result;\n            final PageResult pageResult = new PageResult();\n            pageResult.addAll(page);\n            pageResult.setPageNum(page.getPageNum());\n            pageResult.setPageSize(page.getPageSize());\n            pageResult.setStartRow(page.getStartRow());\n            pageResult.setEndRow(page.getEndRow());\n            pageResult.setTotal(page.getTotal());\n            pageResult.setPages(page.getPages());\n            pageResult.setCount(page.isCount());\n            pageResult.setOrderBy(page.getOrderBy());\n            pageResult.setOrderByOnly(page.isOrderByOnly());\n            pageResult.setReasonable(page.getReasonable());\n            pageResult.setPageSizeZero(page.getPageSizeZero());\n            return pageResult;\n        }\n        return result;\n    }\n\n    /**\n     * 只拦截Executor\n     */\n    public Object plugin(Object target) {\n        if (target instanceof Executor) {\n            return Plugin.wrap(target, this);\n        } else {\n            return target;\n        }\n    }\n\n    @Override\n    public void setProperties(Properties properties) {\n    }\n}\n```\n\n实现分页切面完成PageHelper分页参数的设置：\n\n```java\n@Aspect\n@Component\npublic class PageAspect {\n\n    //@Pointcut(\"execution(* com.shengsigu.service..*.*(..))\")\n     @Pointcut(\"execution(* com.shengsigu.service..*.pageList*(..))\")\n    public void pagePointcut(){}\n\n\n    @Before(\"pagePointcut()\")\n    public void pageBefore(JoinPoint joinPoint) {\n        Method method = ((MethodSignature)joinPoint.getSignature()).getMethod();\n\n        // 获取到当前方法的方法签名, 判断返回类型是否是 PageList, 如果是则执行分页逻辑\n        boolean isPageList = method.getReturnType().equals(PageList.class);\n        if (isPageList) {\n            // 获取参数 currentPage, pageSize，并设置分页\n            Object[] args = joinPoint.getArgs();\n            PageCondition pageCondition = (PageCondition) args[0];\n            PageHelper.startPage(pageCondition.getPageNum(),pageCondition.getPageSize(),true);\n        }\n    }\n}\n```\n\n## 反思 \n\n- 不要想当然，凭主观判断别人写的方法，调用别人的方法的时候点进去看一看是否满足自己的需求。\n- 仔细检查！！！ 做事情要有理有据，不要马虎！！！\n- 不要过分地参照原来的代码，它有可能也不规范！\n- 字段的意义？内部业务逻辑？多问写该代码的同事！\n- 对象调用方法前，记得考虑一下是否为空！\n- `if-else`语句中有重复的语句，提取出来放置`if-else`之外！\n- `if`里面有`if`，考虑合并判断条件？\n- 熟悉一块业务功能不能只看代码，应该还要去熟悉流程，数据库。\n- 永远不要相信前端传过来的参数是可靠，处于安全考虑，后端必须进行必要的参数校验。\n- 对象只有在需要时才创建，不要提前创建，避免浪费内存。\n- 最好使用空对象代替`null`返回给前端。\n- 删除、修改单个属性为一个常量时，前端传递一个*id*就可以了，不用传递整个实体对象。\n- 对象调用方法时，注意判空！\n- 方法（动词+名词）和变量（boolean类型 ：is+形容词）做到见名知意。\n- *mapper*文件里面的*sql*尽量不要写死，使用接口传递常量值。\n- 一个方法中不同的功能模块用空行隔开。\n\n## Git\n\n- push代码时确保push到的远程分支是自己新建的一个分支，千万不要push到主分支中！！！有的项目可能没有设置权限，提交的代码就直接合并到主分支中参与构建了，最终导致构建失败！\n\n- push大量改动时，将改动拆分push，push前检查改动，以最小改动为基准，能添加尽量不要删除，一般情况不要合并其他环境的版本到当前环境的版本，dubbo cache不要勾选！\n\n- 确保本地编译成功再提交，pom文件的依赖不能随便加，但是要导的包一定记得导，导不进来的二方接口是别人的代码还没合，包还没构建的原因。\n\n- 提交前merge同一环境下的目标分支到自己本地的分支，不要与fetch更新自己远程的分支到本地分支弄混淆。\n\n- Git Log查看git操作的日志。\n\n- Undo Commit 撤销commit。\n\n- git pull强制覆盖：\n\n  `git fetch origin master`  先把远程仓库最新状态拉到本地（以master为例）；\n\n  `git reset --hard origin/master` 将本地仓库重置到远程仓库最新状态（本地将被覆盖）。\n\n  或者如果你在其他分支上：`git reset --hard origin/<branch_name>`\n\n  `git pull`\n\n## 测试代码\n\n```java\n@SpringBootTest\nclass TestApplicationTests {\n   @Test\n   void testListToMap() {\n      List<User> users = new ArrayList<>();\n      users.add(new User(\"111\", \"zhangsan1\"));\n      users.add(new User(\"222\", \"zhangsan2\"));\n      users.add(new User(\"111\", \"zhangsan3\"));\n      // 除去key重复的键值对，保留第一次出现的 返回指定类型的 map\n      Map<String, User> usersMap = users.stream()\n            .collect(Collectors.toMap(User::getId, Function.identity(), (a, b) -> a, ConcurrentHashMap::new));\n      System.out.println(usersMap.getClass());\n      System.out.println(usersMap);\n   }\n\n   @Test\n   void testOptional() {\n      List<User> users = new ArrayList<>();\n      users.add(new User(\"111\", \"zhangsan1\"));\n      users.add(new User(\"222\", \"zhangsan2\"));\n      users.add(new User(\"333\", \"zhangsan3\"));\n      users.add(null);\n      // findAny()操作，返回的元素是不确定的，对于同一个列表多次调用findAny()有可能会返回不同的值。\n      // 使用findAny()是为了更高效的性能。如果是数据较少，串行地情况下，一般会返回第一个结果，如果是并行的情况，那就不能确保是第一个\n      // 用来判断集合中是否有满足条件的元素,存在返回true，并且允许集合元素为null的情况\n      Optional<User> usersIsNull = users.stream().filter(e -> e != null && e.getName().equals(\"zhangsan\")).findAny();\n      System.out.println(usersIsNull.isPresent());// false\n   }\n\n\n   @Test\n   public void testStringUtils() {\n      System.out.println(StringUtils.isNumeric(\"123\"));// true\n      System.out.println(\"--------isEmpty-------\");\n      // isEmpty判断空字符串时返回 false\n      System.out.println(\"null->\" + StringUtils.isEmpty(null));// true\n      System.out.println(\"\\\"\\\"->\" + StringUtils.isEmpty(\"\"));// true\n      System.out.println(\"\\\" \\\"->\" + StringUtils.isEmpty(\" \"));// false\n      System.out.println(\"--------isBlank-------\");\n      System.out.println(\"null->\" + StringUtils.isBlank(null));// true\n      System.out.println(\"\\\"\\\"->\" + StringUtils.isBlank(\"\"));// true\n      System.out.println(\"\\\" \\\"->\" + StringUtils.isBlank(\" \"));// true\n   }\n\n   @Test\n   public void testAssert() {\n      //Assert.notNull(null,\"判断null\");// 抛出异常\n      //Assert.notNull(\"\",\"判断\\\"\\\"\");// 不会抛出异常\n      //Assert.notNull(\" \",\"判断null\\\" \\\"\");// 不会抛出异常\n      //Assert.notNull(new ArrayList<>());// 不会抛出异常\n      User user = new User();\n   }\n\n   @Test\n   public void test(){\n      Integer num = Integer.valueOf(\"\");// 抛出 java.lang.NumberFormatException\n   }\n\n   @Test\n   public void testUUID(){\n   // 生成19位随机数 直接使用 在多线程环境下可能重复 写成工具类方法并用synchronized关键字修饰\n      Long shortUuid = UUID.randomUUID().getLeastSignificantBits() * -1;\n      System.out.println(shortUuid);\n   // 生成uuid去掉-，可与redis的key拼接 生成唯一的键   \n      String uuid = UUID.randomUUID().toString().replace(\"-\",\"\");\n      System.out.println(uuid);\n   }\n\n   @Test\n   public void testMap(){\n      List<User> users = new ArrayList<>();\n      ArrayList<String> study = new ArrayList<>();\n      ArrayList<String> sports = new ArrayList<>();\n      study.add(\"chinese\");\n      study.add(\"math\");\n      study.add(\"english\");\n      sports.add(\"dance\");\n      sports.add(\"basketball\");\n      users.add(new User(\"111\", \"zhangsan1\",new Hobby(study,sports)));\n      users.add(new User(\"222\", \"zhangsan2\",new Hobby(study,sports)));\n      users.add(new User(\"333\", \"zhangsan3\",new Hobby(study,sports)));\n\n      List<String> ids = users.stream().map(User::getId).collect(Collectors.toList());\n      System.out.println(ids);// [111, 222, 333]\n      // flatmap 将对象中的属性转换为流，方便进行二次处理\n      List<String> usersports = users.stream().flatMap(user -> user.getHobby().getSports().stream()).collect(Collectors.toList());\n      System.out.println(usersports);// [dance, basketball, dance, basketball, dance, basketball]\n      // groupingBy分组 封装成为 Map<指定属性,List<User>> 指定属性相同的 User在一个List里面\n      Map<String, List<User>> mapById = users.stream().collect(Collectors.groupingBy(User::getId));\n      System.out.println(mapById);\n      // toMap 封装成 Map<指定属性,User> 指定属性重复时抛 java.lang.IllegalStateException\n      Map<String, User> mapById2 = users.stream().collect(Collectors.toMap(User::getId, Function.identity()));\n      System.out.println(mapById2);\n   }\n\n   @Test\n   public void testSingletonList(){\n      /**\n       * Arrays.asList(strArray)返回的是一个可变的集合，\n       * 但是返回值是其内部类，不具有add方法，可以通过set方法进行增加值，默认长度是10\n       *\n       *\n       * Collections.singletonList()返回的是不可变的集合，但是这个长度的集合只有1，可以减少内存空间。\n       * 但是返回的值依然是Collections的内部实现类，同样没有add的方法，调用add，set方法会报错\n       */\n\n      User user = new User(\"111\", \"zhangsan1\");\n      List<User> oneToList1 = Collections.singletonList(user);\n      // oneToList1.add(new User(\"222\",\"zyz\"));// java.lang.UnsupportedOperationException\n      System.out.println(oneToList1);\n      List<User> oneToList2 = Stream.of(user).collect(Collectors.toList());\n      oneToList2.add(new User(\"222\",\"zyz\"));\n      System.out.println(oneToList2);\n   }\n\n   @Test\n   public void testDate() throws ParseException {\n      Timestamp timestamp = new Timestamp(System.currentTimeMillis());\n      System.out.println(timestamp);// 2020-12-10 11:03:11.976\n      SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n      String timestampDF = df.format(timestamp);\n      System.out.println(timestampDF);// 2020-12-11 11:19:51\n      Date parseDate = DateUtils.parseDate(timestampDF, \"yyyy-MM-dd HH:mm:ss\");\n      System.out.println(parseDate);// Fri Dec 11 11:20:23 CST 2020\n   }\n\n   @Test\n   public void testNumeric(){\n      System.out.println(StringUtils.isNumeric(\"123\"));// true\n      System.out.println(StringUtils.isNumeric(\"12.3\"));// false\n      System.out.println(StringUtils.isNumeric(\"\"));// false\n      System.out.println(StringUtils.isNumeric(\" \"));// false\n   }\n}\n```\n\n## 业务\n\n- 在实际开发中，添加和更新功能可以写在一起，添加时前端不传id，更新时前端传id。\n\n- 对前端传过来的json通过`@RequestBody`转换为JavaBean后进行非空判断\n\n  - 经过`@RequestyBody`封装的javaBean一定不为null，只需进行非空判断，或者对其属性进行非空判断\n  - 一些必须传的数据可使用断言判断，截断流程\n  - if判断，在保证不阻断业务流程下使用\n  - 集合元素进行forEach遍历之前，必须进行非空判断```CollectionUtils.isEmpty(collection)```\n\n- 修改密码的逻辑\n\n  - 在根据原密码修改密码，验证原密码，验证密码时需要对原密码进行加密再与数据库中的密码进行比较：\n\n  ```java\n  // 传入参数：旧密码oldPassword、新密码newPassword、用户id userId \n  String digestOldPassword = DigestUtils.md5DigestAsHex(oldPassword.getBytes());\n  if (!digestOldPassword.equals(user.getPassword().trim().toLowerCase())) {\n  \tnew RuntimeException(\"输入的原密码错误！\");\n  }\n  // 密码强度校验......\n  // 对新密码进行加密\n  String digestNewPassword = DigestUtils.md5DigestAsHex(newPassword.trim().getBytes());\n  // 更新密码到数据库\n  ```\n\n- 枚举类的使用\n\n```java\npublic enum ChargeOffStateEnum {\n    /**\n     * 审核中\n     */\n    WAIT_AUTID((byte) 1, \"审核中\"),\n    /**\n     * 已审核\n     */\n    CANCEL((byte) 2, \"已取消\"),\n    /**\n     * 已取消\n     */\n    COMPLETE((byte) 3, \"已完成\");\n\n    ChargeOffStateEnum(Byte value, String name) {\n        this.name = name;\n        this.value = value;\n    }\n\n    private Byte value;\n    private String name;\n\n    public Byte getValue() {\n        return value;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public static ChargeOffStateEnum getChargeOffStateEnum(Byte value) {\n        if (value == null) {\n            return null;\n        }\n        ChargeOffStateEnum[] stateEnums = ChargeOffStateEnum.values();\n        for (ChargeOffStateEnum stateEnum : stateEnums) {\n            if (value.equals(stateEnum.getValue())) {\n                return stateEnum;\n            }\n        }\n        return null;\n    }\n}\n```\n\n## bug处理\n\n定位bug：\n![](note/2.png)\n\n![](note/3.png)\n\n![](note/4.png)\n\n","tags":["实习笔记"],"categories":["实习笔记"]},{"title":"ElementUI整合SpringBoot","url":"/2020/10/31/elementui/","content":"\n## 创建前端项目\n\n- 使用vue cli创建一个名为element_user的vue项目<!--more-->\n\n``` bash\nvue init webpack element_user\n```\n\n- 在当前项目下安装elementui \n\n```bash\nnpm i element-ui -S\n```\n\n- 在项目中的main.js中引入elementui\n\n```js\nimport ElementUI from 'element-ui';\nimport 'element-ui/lib/theme-chalk/index.css';\n\nVue.use(ElementUI); // 在项目中使用 elementui\n```\n\n> ElementUI的一些基础知识：\n>\n> ElementUI是基于vue的一个ui框架，并提供了很多相关组件，方便我们快速构建页面。\n>\n> **属性值的设置**：\n>\n> - 当属性值是字符串时，直接使用`属性=\"属性值\"`  的方式给属性赋值\n> - 当属性值是表达式（例如 false,true，数字等等）时，使用`:属性=\"属性值\"`的方式给属性赋值\n>\n> **事件的绑定：**\n>\n> - 在组件标签中添加`@事件名=vue中事件处理函数`\n> - 在 `methods:{}`内编写处理函数的实现\n>\n> **组件方法的调用：**\n>\n> - 使用组件的方法时，需要在组件中加入`ref=\"组件别名\"`\n> - 在调用方法时直接使用`this,$refs.组件别名.方法名()`\n\n**vue项目的基本结构：**\n![](elementui/1.png)\n\n### 在App.vue中创建头部导航栏\n\n```js\n<template>\n  <div>\n    <el-container>\n      <el-header>\n        <el-menu :default-active=\"activeIndex\"\n          class=\"el-menu-demo\" mode=\"horizontal\" @select=\"handleSelect\">\n          <el-menu-item index=\"/\">主页</el-menu-item>\n          <el-menu-item index=\"/userlist\">用户管理</el-menu-item>\n          <el-menu-item index=\"/orderlist\">订单管理</el-menu-item>\n        </el-menu>\n      </el-header>\n      <el-main>\n        <router-view/>\n      </el-main>\n    </el-container>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"App\",\n  data() {\n    return {\n      activeIndex: this.$route.path,\n    };\n  },\n  methods: {\n    handleSelect(key, keyPath) {\n      this.$router.push(key);\n    },\n  },\n};\n</script>\n\n<style>\n</style>\n```\n\n### 编写主页的组件Index.vue\n\n简单实现一个轮播图的效果。\n\n```js\n<template>\n  <div>\n    <el-carousel :interval=\"3000\" type=\"card\" height=\"250px\">\n      <el-carousel-item v-for=\"item in imgs\" :key=\"item\">\n        <el-image style=\"width: 500px; height: 250px\" :src=\"item\" fit=\"contain\"></el-image>\n      </el-carousel-item>\n    </el-carousel>\n    <h2>欢迎来到xx管理系统！</h2>\n  </div>\n</template>\n\n<script>\nimport homeImg1 from \"../assets/indexImgs/1.jpg\";\nimport homeImg2 from \"../assets/indexImgs/2.jpg\";\nimport homeImg3 from \"../assets/indexImgs/3.jpg\";\nimport homeImg4 from \"../assets/indexImgs/4.jpg\";\n\nexport default {\n  name: \"Index\",\n  data() {\n    return {\n      imgs: [homeImg1, homeImg2, homeImg3, homeImg4],\n    };\n  },\n};\n</script>\n\n<style>\n</style>\n```\n\n### 在index.js中引入组件和访问路径\n\n```js\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport Index from '../components/Index'\nimport UserList from '../components/User/UserList'\nimport OrderList from '../components/Order/OrderList'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    { path: '/', redirect:'/index' },\n    { path: '/index', component: Index },\n    { path: '/userlist', component: UserList },\n    { path: '/orderlist', component: OrderList }\n  ]\n})\n\n```\n\n## 编写用户管理的组件UserList.vue\n\n### 在当前工程下安装axios\n\n```bash\nnpm install axios --save-dev\n```\n\n### 在main.js  中引入axios\n\n```js\nimport axios from 'axios';\n\nVue.prototype.$http=axios; // 修改 vue内部 $http为 axios\n```\n\n### 编写UserList.vue\n\n```js\n<template>\n  <div>\n    <el-button type=\"primary\" size=\"small\" @click=\"centerDialogVisible = true\">添加</el-button>\n    <el-table stripe size=\"small\" :data=\"tableData\">\n      <el-table-column type=\"index\" width=\"50\"> </el-table-column>\n      <el-table-column label=\"编号\" width=\"100\">\n        <template slot-scope=\"scope\">\n          <span style=\"margin-left: 10px\">{{ scope.row.id }}</span>\n        </template>\n      </el-table-column>\n      <el-table-column label=\"姓名\" width=\"160\">\n        <template slot-scope=\"scope\">\n          <el-popover trigger=\"hover\" placement=\"top\">\n            <p>姓名: {{ scope.row.name }}</p>\n            <p>住址: {{ scope.row.address }}</p>\n            <div slot=\"reference\" class=\"name-wrapper\">\n              <el-tag size=\"medium\">{{ scope.row.name }}</el-tag>\n            </div>\n          </el-popover>\n        </template>\n      </el-table-column>\n      <el-table-column prop=\"gender\" label=\"性别\" width=\"100\"></el-table-column>\n      <el-table-column prop=\"birth\" label=\"生日\" width=\"160\"></el-table-column>\n      <el-table-column prop=\"address\" label=\"地址\" width=\"160\"></el-table-column>\n      <el-table-column label=\"操作\" width=\"300\">\n        <template slot-scope=\"scope\">\n          <el-button size=\"small\"\n           @click=\"handleEdit(scope.$index, scope.row)\">编辑</el-button>\n          <el-button size=\"small\"  type=\"danger\"\n            @click=\"handleDelete(scope.$index, scope.row)\">删除</el-button>\n        </template>\n      </el-table-column>\n    </el-table>\n    <el-dialog title=\"员工信息\" :visible.sync=\"centerDialogVisible\" width=\"40%\" center>\n      <el-form :hide-required-asterisk=\"false\" :rules=\"rules\" ref=\"userForm\" :model=\"form\" label-suffix=\":\">\n        <el-form-item label=\"姓名\" prop=\"name\">\n          <el-col :span=\"11\"><el-input v-model=\"form.name\" size=\"small\"></el-input></el-col>\n        </el-form-item>\n        <el-form-item label=\"性别\">\n          <el-radio-group v-model=\"form.gender\">\n            <el-radio label=\"男\"></el-radio>\n            <el-radio label=\"女\"></el-radio>\n          </el-radio-group>\n        </el-form-item>\n        <el-form-item label=\"生日\" prop=\"birth\">\n          <el-col :span=\"11\">\n            <el-date-picker value-format=\"yyyy-MM-dd\" type=\"date\" placeholder=\"选择日期\" v-model=\"form.birth\" style=\"width: 100%\" size=\"small\"></el-date-picker>\n          </el-col>\n        </el-form-item>\n        <el-form-item label=\"详细地址\" prop=\"address\">\n          <el-input type=\"textarea\" v-model=\"form.address\" :rows=\"2\"></el-input>\n        </el-form-item>\n        <span style=\"text-align: center; display: block\">\n          <el-button type=\"primary\" @click=\"onSubmit\" size=\"small\">保存</el-button>\n          <el-button @click=\"clear\" size=\"small\">重置</el-button>\n        </span>\n      </el-form>\n    </el-dialog>\n    <el-pagination\n      layout=\"prev, pager, next,jumper,total,sizes\"\n      background\n      style=\"margin: 10px 0px\"\n      :total=\"total\"\n      @current-change=\"findCurrentPage\"\n      @size-change=\"findPageSize\"\n    >\n    </el-pagination>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"UserList\",\n  data() {\n    return {\n      search: \"\",\n      tableData: [],\n      centerDialogVisible: false,\n      form: {\n        name: \"\",\n        gender: \"男\",\n        birth: \"\",\n        address: \"\",\n      },\n      total: 0,\n      pageNo: 1,\n      pageSize: 9,\n      rules: {\n        name: [{ required: true, message: \"请输入姓名\", trigger: \"blur\" }],\n        birth: [{ required: true, message: \"请选择出生日期\", trigger: \"blur\" }],\n        address: [\n          { required: true, message: \"请输入详细地址\", trigger: \"blur\" },\n        ],\n      },\n    };\n  },\n\n  methods: {\n    handleEdit(index, row) {\n      // console.log(index, row);\n      this.centerDialogVisible = true;\n      this.$http\n        .get(\"http://localhost:8989/user/select?id=\" + row.id)\n        .then((res) => {\n          //console.log(res.data);\n          this.form = res.data;\n        });\n    },\n    handleDelete(index, row) {\n      this.$confirm(\"确认删除?\", \"提示\", {\n        confirmButtonText: \"确定\",\n        cancelButtonText: \"取消\",\n        type: \"warning\",\n      })\n        .then(() => {\n          this.$http\n            .get(\"http://localhost:8989/user/delete?id=\" + row.id)\n            .then((res) => {\n              if (res.data.status) {\n                this.$message({\n                  message: \"删除成功\",\n                  type: \"success\",\n                });\n                this.listAll();\n              } else {\n                this.$message({\n                  message: \"删除失败\",\n                  type: \"error\",\n                });\n              }\n            });\n        })\n        .catch(() => {\n          this.$message({\n            type: \"info\",\n            message: \"已取消删除\",\n          });\n        });\n    },\n    onSubmit() {\n      this.$refs.userForm.validate((valid) => {\n        if (valid) {\n          this.$http\n            .post(\"http://localhost:8989/user/save\", this.form)\n            .then((res) => {\n              this.centerDialogVisible = false;\n              if (res.data.status) {\n                this.$message({\n                  message: \"保存成功\",\n                  type: \"success\",\n                });\n                this.listAll();\n              } else {\n                this.$message({\n                  message: \"保存失败\",\n                  type: \"error\",\n                });\n              }\n              this.form = { gender: \"男\" };\n            });\n        } else {\n          this.$message({\n            message: \"输入信息不合法！\",\n            type: \"error\",\n          });\n          return false;\n        }\n      });\n      //console.log(this.form);\n    },\n    clear() {\n      this.form = { id: this.form.id, gender: \"男\" };\n    },\n    listAll() {\n      this.$http\n        .get(\n          \"http://localhost:8989/user/listAll?pageNo=\" +\n            this.pageNo +\n            \"&pageSize=\" +\n            this.pageSize\n        )\n        .then((res) => {\n          // console.log(res);\n          this.tableData = res.data.users;\n          this.total = res.data.recordCount;\n        });\n    },\n    findCurrentPage(page) {\n      this.pageNo = page;\n      this.listAll();\n    },\n    findPageSize(size) {\n      this.pageSize = size;\n      this.listAll();\n    },\n  },\n  created() {\n    this.listAll();\n  },\n};\n</script>\n```\n\n## 实现后端接口\n\n```java\n@RestController\n@RequestMapping(\"/user\")\n@CrossOrigin // 解决跨域问题\npublic class UserController {\n    @Autowired\n    private UserService userService;\n\n    @GetMapping(\"/listAll\")\n    public Map<String, Object> listAll(Integer pageNo, Integer pageSize) {\n        HashMap<String, Object> map = new HashMap<>();\n        pageNo=pageNo==null?1:pageNo;\n        pageSize=pageSize==null?9:pageSize;\n        List<UserPO> users = userService.listAll(pageNo, pageSize);\n        Integer recordCount = userService.findTotal();\n        Integer pageTotal = (recordCount - 1) / pageSize + 1;\n        map.put(\"users\", users);\n        map.put(\"totalPage\", pageTotal);\n        map.put(\"recordCount\", recordCount);\n        return map;\n    }\n\n    @PostMapping(\"/save\")\n    public Result insert(@RequestBody UserPO userPO) {\n        Result result = new Result();\n        try {\n            userService.insertOrUpdate(userPO);\n            result.setStatus(true);\n            result.setMsg(\"保存成功\");\n        } catch (Exception e) {\n            result.setStatus(false);\n            result.setMsg(\"保存失败\");\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    @GetMapping(\"/delete\")\n    public Result delete(Integer id) {\n        Result result = new Result();\n        try {\n            userService.delete(id);\n            result.setStatus(true);\n            result.setMsg(\"删除成功\");\n        } catch (Exception e) {\n            result.setStatus(false);\n            result.setMsg(\"删除失败\");\n            e.printStackTrace();\n        }\n        return result;\n    }\n    \n    @GetMapping(\"/select\")\n    public UserPO select(Integer id) {\n        return userService.selectOne(id);\n    }\n}\n```\n\n## 效果\n\n![](elementui/1.gif)\n\n\n\n\n\n","tags":["Vue","ElementUI","SpringBoot"],"categories":["小项目"]},{"title":"Vue Cli的使用","url":"/2020/10/30/vue-cli/","content":"\nvue cli是一个用于构建基于vue.js项目（类似于java后端像maven那样）的构建工具。<!--more-->\n\n## 环境准备\n\n- 安装node.js\n\n- 配置 npm（类似于maven中的仓库）\n\n  ```bash\n  # 切换为淘宝镜像源\n  npm config set registry https://registry.npm.taobao.org\n  # 验证是否切换成功\n  npm config get registry\n  # 配置npm依赖下载位置\n  npm config set cache \"d:\\nodejs\\npm_cache\"\n  npm config set prefix \"d:\\nodejs\\npm_global\"\n  # 查看配置 \n  npm config ls\n  ```\n\n- 安装 vue cli\n\n  ```bash\n  # 全局安装 安装在之前配置好的D:\\nodejs\\npm_global\\node_modules目录下\n  npm install -g vue-cli\n  ```\n\n## 使用vue cli创建一个vue项目\n\n**创建一个项目名为hello的vue项目**\n\n```powershell\nvue init webpack hello\n```\n\n**启动项目**\n\n```bash\ncd hello\n  \nnpm run dev\n# npm start\n```\n\n**本地访问**\n\nhttp://localhost:8080\n\n**项目结构：**\n\n```markdown\n\thello     ------------->项目名\n    -build  ------------->用来使用webpack打包使用build依赖\n    -config ------------->用来做整个项目配置目录\n    -node_modules  ------>用来管理项目中使用依赖\n    -src\t\t\t\t\t ------>用来书写vue的源代码[重点]\n      -assets      ------>用来存放静态资源 [重点]\n      -components   ------>用来书写Vue组件 [重点]\n      -router\t\t\t ------>用来配置项目中路由[重点]\n      App.vue      ------>项目中根组件[重点]\n      main.js      ------>项目中主入口[重点]\n    -static        ------>其它静态\n    -.babelrc      ------> 将es6语法转为es5运行\n    -.editorconfig ------> 项目编辑配置\n    -.gitignore    ------> git版本控制忽略文件\n    -.postcssrc.js ------> 源码相关js\n    -index.html    ------> 项目主页\n    -package.json  ------> 类似与pom.xml 依赖管理  jquery 不建议手动修改\n    -package-lock.json ----> 对package.json加锁\n    -README.md         ----> 项目说明文件\n```\n\n## 开发步骤\n\n1、编写各个组件：主页、用户、商品等等功能模块，并导出\n\n```js\n<template>\n  <div>\n    <h1>网站主页</h1>\n  </div>\n</template>\n\n<script>\nexport default {// 导出组件，向外暴露\n  name: \"Home\",\n};\n</script>\n\n<style>\n</style>\n```\n\n2、在index.js中引入并注册组件\n\n```js\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport Home from '../components/Home' // 引入 Home\nimport User from '../components/User'\nimport Student from '../components/Student'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {path: '/',redirect: '/home'}, // 重定向到 /home\n    {path: '/home',component: Home},// 注册 Home\n    {path: '/user',component: User},\n    {path: '/student',component: Student}\n  ]\n})\n```\n\n3、在App.vue中添加访问路径\n\n```js\n<template>\n    <div>\n        <a href=\"#/home\">主页</a>\n        <a href=\"#/user\">用户管理</a>\n        <a href=\"#/student\">学生管理</a>\n        \n        <router-view/>\n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'App' \n}\n</script>\n\n<style>\n</style>\n```\n\n## 在vue cli中使用axios\n\n- 在当前工程下安装axios\n\n  ```bash\n  npm install axios --save-dev\n  ```\n\n- 在main.js  中引入axios\n\n  ```js\n  import axios from 'axios';\n  \n  Vue.prototype.$http=axios; // 修改 vue内部 $http为 axios\n  ```\n\n- 发起异步请求\n\n  ```js\n  <script>\n  export default {\n    name: \"User\",\n    data() {\n        return{\n            users: []\n        }\n    },\n    method:{\n  \n    },\n    components:{\n  \n    },\n    created(){\n        this.$http.get(\"http://rap2api.taobao.org/app/mock/270195/user/findAll\").then(res=>{\n          this.users = res.data.results;\n        })\n    }\n  };\n  </script>\n  ```\n\n- 数据渲染\n\n  ```js\n  <template>\n    <div>\n      <h1>用户管理</h1>\n      <a href=\"\">添加用户</a>\n      <table border=\"1\" cellspacing=\"0\" width=\"600px\">\n        <tr>\n          <th>编号</th>\n          <th>姓名</th>\n          <th>年龄</th>\n          <th>生日</th>\n          <th align=\"center\">操作</th>\n        </tr>\n        <tr v-for=\"user in users\">\n          <td v-text=\"user.id\"></td>\n          <td v-text=\"user.name\"></td>\n          <td v-text=\"user.age\"></td>\n          <td v-text=\"user.birth\"></td>\n          <td align=\"center\"><a href=\"\">修改</a>&nbsp; \n          <a href=\"\">删除</a></td>\n        </tr>\n      </table>\n    </div>\n  </template>\n  ```\n\n  \n  \n  <img src=\"vue_cli/1.gif\" style=\"zoom:80%;\" />\n\n","tags":["Vue"],"categories":["前端"]},{"title":"RabbitMQ整合springboot","url":"/2020/10/26/rabbitmq-02/","content":"\nspringboot整合RabitMQ<!--more-->\n\n## 引入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n\n## 编写连接信息\n\n```properties\nspring.rabbitmq.host=127.0.0.1\nspring.rabbitmq.port=5672\nspring.rabbitmq.virtual-host=/rabbitmq_study\nspring.rabbitmq.username=zyz\nspring.rabbitmq.password=2824199842\n```\n\n## helloword模型\n\n生产者生产消息，消费者一直等待消息到来。\n![](rabbitmq-02/4.png)\n添加配置类MqConfig\n\n```java\n@Configuration\npublic class MqConfig {\n\n    /**\n     * 创建 hello队列 并交给容器管理\n     * @return\n     */\n    @Bean\n    public Queue helloQueue(){\n        return new Queue(\"hello\");\n    }\n}\n```\n\n**生产者**\n\n```java\n@Autowired\nprivate RabbitTemplate rabbitTemplate;\n@Test \nvoid testHello() {\n    // 发布消息\n    rabbitTemplate.convertAndSend(\"hello\",\"hello,world\");\n}\n```\n\n**消费者**\n\n```java\n@Component\npublic class HelloConsumer {\n\n    @RabbitListener(queues = \"hello\")\n    public void receive(String message){\n        System.out.println(\"Message：\"+message);\n    }\n}\n```\n\n## work模型\n\n多个消费者绑定同一个队列，共同消费其中的消息。解决消息积压问题。\n![](rabbitmq-02/7.png)\n\n配置类MqConfig中添加work队列\n\n```java\n@Bean\npublic Queue workQueue(){\n    return new Queue(\"work\");\n}\n```\n\n**生产者：**\n\n```java\n@Test \nvoid testWork(){\n    for (int i = 0; i < 10; i++) {\n        rabbitTemplate.convertAndSend(\"work\",\"hello,workQueue\");\n    }\n}\n```\n\n**消费者：**\n\n```java\n@Component\npublic class WorkConsumer {\n\n    @RabbitListener(queues =\"work\")\n    public void receive1(String message){\n        System.out.println(\"WorkConsumer1接收消息：\"+message);\n    }\n\n    @RabbitListener(queues = \"work\")\n    public void receive2(String message){\n        System.out.println(\"WorkConsumer2接收消息：\"+message);\n    }\n}\n```\n\n## Fanout模型\n\n广播模型，每个消费者绑定不同的队列，每个队列绑定在交换机上，生产者生产消息给交换机，交换机负责消息的分发。实现一条消息被多个消费者消费。\n![](rabbitmq-02/8.png)\n\n在配置类MqConfig中添加\n\n```java\n // 注入队列fanout1\n@Bean\npublic Queue fanoutQueue1(){\n    return new Queue(\"fanout1\");\n}\n// 注入队列fanout2\n@Bean\npublic Queue fanoutQueue2(){\n    return new Queue(\"fanout2\");\n}\n// 注入交换机fanout.ex\n@Bean\npublic FanoutExchange fanoutEx(){\n    return new FanoutExchange(\"fanout.ex\");\n}\n\n// 绑定队列fanout1和交换机fanout.ex\n@Bean\npublic Binding fanout1ToEx(){\n    return BindingBuilder.bind(fanoutQueue1()).to(fanoutEx());\n}\n\n// 绑定队列fanout2和交换机fanout.ex\n@Bean\npublic Binding fanout2ToEx(){\n    return BindingBuilder.bind(fanoutQueue2()).to(fanoutEx());\n}\n```\n\n**生产者：**\n\n```java\n @Test\nvoid testFanout(){\n    rabbitTemplate.convertAndSend(\"fanout.ex\",\"\",\"hello,fanout\");\n}\n```\n\n**消费者：**\n\n```java\n@RabbitListener(queues = \"fanout1\")\npublic void handleFanout1(String msg){\n    System.out.println(\"消费者1:\"+msg);\n}\n\n@RabbitListener(queues = \"fanout2\")\npublic void handleFanout2(String msg){\n    System.out.println(\"消费者2:\"+msg);\n}\n```\n\n##  Routing-Direct模型\n\n让不同的消息被不同的队列消费\n![](rabbitmq-02/9.png)\n\n在配置类MqConfig中添加\n\n```java\n@Bean\npublic Queue directQueue1(){\n    return new Queue(\"directQueue1\");\n}\n\n@Bean\npublic Queue directQueue2(){\n    return new Queue(\"directQueue2\");\n}\n\n@Bean\npublic DirectExchange directExchange(){\n    return new DirectExchange(\"routing.direct.ex\");\n}\n\n@Bean\npublic Binding directQueue1ToExWithLog(){\n    return BindingBuilder.bind(directQueue1()).to(directExchange()).with(\"log\");\n}\n\n@Bean\npublic Binding directQueue2ToExWithUser(){\n    return BindingBuilder.bind(directQueue2()).to(directExchange()).with(\"user\");\n}\n@Bean\npublic Binding directQueue2ToExWithOrder(){\n    return BindingBuilder.bind(directQueue2()).to(directExchange()).with(\"order\");\n}\n```\n\n**生产者：**\n\n```java\n@Test\nvoid testRoutingDirect(){\n    rabbitTemplate.convertAndSend(\"routing.direct.ex\",\"log\",\"hello,log\");\n    rabbitTemplate.convertAndSend(\"routing.direct.ex\",\"user\",\"hello,user\");\n    rabbitTemplate.convertAndSend(\"routing.direct.ex\",\"order\",\"hello,order\");\n}\n```\n\n**消费者**\n\n```java\n@RabbitListener(queues = \"directQueue1\")\npublic void handleDirectQueue1(String msg){\n    System.out.println(\"消费者1:\"+msg);\n}\n\n@RabbitListener(queues = \"directQueue2\")\npublic void handleDirectQueue2(String msg){\n    System.out.println(\"消费者2:\"+msg);\n}\n```\n\n## Routing-Topic模型\n\n可使用通配符将交换机与队列绑定\n![](rabbitmq-02/10.png)\n\n在配置类MqConfig中添加\n\n```java\n@Bean\npublic Queue topicQueue1(){\n    return new Queue(\"topicQueue1\");\n}\n\n@Bean\npublic Queue topicQueue2(){\n    return new Queue(\"topicQueue2\");\n}\n\n@Bean\npublic TopicExchange topicExchange(){\n    return new TopicExchange(\"routing.topic.ex\");\n}\n\n\n@Bean\npublic Binding topicQueue1ToExWithUser(){\n    return BindingBuilder.bind(topicQueue1()).to(topicExchange()).with(\"user.*\");\n}\n\n@Bean\npublic Binding topicQueue2ToExWithUser(){\n    return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(\"user.#\");\n}\n```\n\n**生产者：**\n\n```java\n@RabbitListener(queues = \"topicQueue1\")\npublic void handleTopicQueue1(String msg){\n    System.out.println(\"消费者user.*:\"+msg);\n}\n\n@RabbitListener(queues = \"topicQueue2\")\npublic void handleTopicQueue2(String msg){\n    System.out.println(\"消费者user.#:\"+msg);\n}\n```\n\n**消费者：**\n\n```java\n@Test\nvoid testRoutingTopic(){\n    rabbitTemplate.convertAndSend(\"routing.topic.ex\",\"user\",\"hello,user\");\n    rabbitTemplate.convertAndSend(\"routing.topic.ex\",\"user.info\",\"hello,user.info\");\n    rabbitTemplate.convertAndSend(\"routing.topic.ex\",\"user.info.crud\",\"hello,user.info.crud\");\n}\n```\n\n结果：\n\n```markdown\n消费者user.*:hello,user.info\n消费者user.#:hello,user\n消费者user.#:hello,user.info\n消费者user.#:hello,user.info.crud\n```\n\n## 实际使用\n\n转换为json字符串发送\n\n```java\n @Test\nvoid testHello() {\n    HashMap<String,User> map = new HashMap<>();\n    User user = new User(111L, \"张小红\", 21);\n    map.put(\"userInfo\",user);\n    rabbitTemplate.convertAndSend(\"hello\", JSON.toJSONString(map));\n}\n```\n\n## 消息监视\n\n在配置文件中添加\n\n```properties\n# 开启消息到达交换机的确认机制\nspring.rabbitmq.publisher-confirm-type=correlated\n# 开启消息未达到队列的回调\nspring.rabbitmq.publisher-returns=true\n```\n\n添加配置类RabbitMsgWatch\n\n```java\n@Configuration\npublic class RabbitMsgWatch implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback {\n\n    private Logger logger = LoggerFactory.getLogger(RabbitMsgWatch.class);\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n    \n    /**\n     * 设置监听\n     */\n    @PostConstruct // 后置增强 bean对象创建后开始生效\n    public void setConfig(){\n        rabbitTemplate.setConfirmCallback(this);\n        rabbitTemplate.setReturnsCallback(this);\n    }\n\n    /**\n     * 消息未达到交换机的回调\n     * @param correlationData\n     * @param ack\n     * @param cause\n     */\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n        logger.info(JSON.toJSONString(correlationData));\n        logger.info(JSON.toJSONString(ack));\n        logger.info(JSON.toJSONString(cause));\n    }\n\n    /**\n     * 消息未到达队列的回调\n     * @param returned\n     */\n    @Override\n    public void returnedMessage(ReturnedMessage returned) {\n        logger.info(JSON.toJSONString(returned));\n    }\n}\n```\n\n## 消息签收\n\n消息的签收方式分为，自动签收和手动签收\n\n- 自动签收\n\n  吞吐量很高，用于数据量比较大，数据不是特别重要的场景，例如日志。消息只要被客户端接收到，无论客户端发生了什么，服务器都会删除这条消息。springboot项目默认开启自动签收。\n\n- 手动签收\n\n  吞吐量低，用于数据重要的场景，例如操作数据库。在sprboot项目中需要手动来开启。\n\n```java\n# 开启手动ack\nspring.rabbitmq.listener.simple.acknowledge-mode=manual\n# 直连交换机开启手动ack\nspring.rabbitmq.listener.direct.acknowledge-mode=manual\n```\n\n发送消息时设置消息id\n\n```java\nrabbitTemplate.convertAndSend(\"directs\", \"error\", \"我是一个重要消息\", new MessagePostProcessor() {\n\t@Override\n\tpublic Message postProcessMessage(Message message)throws AmqpException {\n\t//自己给消息设置自定义的ID\n\tString messageId= UUID.randomUUID().toString().replace(\"-\",\"\");                       \t\tmessage.getMessageProperties().setMessageId(messageId);\n    return message;\n}\n```\n\n消息的签收与拒收\n\n```java\n/**\n* 参数说明:\n* deliveryTag  消息投递ID，要签收的投递ID是多少\n* multiple:是否批量签收\n*/\nchannel.basicAck(deliveryTag,false);\n\n/**\n* 参数说明:\n* deliveryTag  消息投递ID，要签收的投递ID是多少\n* multiple:是否批量签收\n* requeue: true 代表拒绝签收并把消息重新放回到队列里面  false就直接拒绝\n*/\nchannel.basicNack(deliveryTag,false,true);\n```\n\n拒收消息，其实是为了保护消息，当消费消息发生异常时，我们可以把消息放在队列里面，重新让别人消费，而不是丢了它！\n\n> 死循环的处理：\n>\n> 不签收，并且让它回到队列里面，想法很好，但是很容易造成死循环，因为没有任何人能消费它。\n>\n> 我们设计一个机制，当一个消息被消费3次还没有消费成功，我们就直接把它记录下来，人工处理！\n>\n> 消息消费3次（消息的标识，消息的计数）\n>\n> 我们引入Redis ，使用Redis 计数，若超过3次，直接拒绝消息，并且不回到队列里面\n\n## 重复消费问题\n\nmq自己就可以保证消息不被重复消费，因为Mmq可以把消息投递给消费者时，是阻塞的，不会把一个消息投递给多个消费者！\n\n实现原理：\n\n使用BloomFilter实现去重，消费成功后将用户与消息的唯一标识hash之后存入bitmaps中，然后每次消费学习之前将用户与消息的唯一标识通过BloomFilter中判断bitmaps中是否存在，不存在才能消费消息。\n\n## 延迟消息\n\n当发送消息到服务器时，不是马上就放到消息队列中，而是在mq服务器里面建立一个定时任务，在服务器到达延时时间后再执行投递的操作。\n<img src=\"rabbitmq-02/1.jpg\" style=\"zoom:60%;\" />\n\n实现细节：\n\n<img src=\"rabbitmq-02/2.jpg\" style=\"zoom:60%;\" />\n\n\n\n```java\n// 延迟队列  \n@Bean\npublic Queue delayQueue(){\n    HashMap<String, Object> args = new HashMap<>();\n    // 把一个队列修改为延迟队列\n    // 消息的最大存活时间\n    args.put(\"x-message-ttl\",10*1000) ; \n    // 该队列里面的消息死了，去那个交换机\n    args.put(\"x-dead-letter-exchange\",\"DeadLetter.exc\"); \n    // 该队列里面的消息死了，去那个交换机, 由那个路由key\n    args.put(\"x-dead-letter-routing-key\",\"DeadLetter.key\"); \n    return new Queue(\"delay\",true,false,false,args);\n}\n\n// 交换机\n@Bean\npublic DirectExchange deadLetterExchange() {\n    return new DirectExchange(\"DeadLetter.exc\");\n}\n\n// 绑定死信队列\n@Bean\npublic Binding newAndDeadLetterExchange(){\n    return BindingBuilder.bind(deadlyQueue()).to(deadLetterExchange()).\n        with(\"DeadLetter.key\"); // 死信路由key\n}\n\n// 死信队列\n@Bean\npublic Queue deadlyQueue(){\n    return  new Queue(\"dealy.queue\") ;\n}\n```\n\n","tags":["RabbitMQ"],"categories":["中间件"]},{"title":"RabbitMQ","url":"/2020/10/21/rabbitmq-01/","content":"\n## MQ简介\n\n**MQ**（Message Queue），别名为**消息中间件**。通过典型的**生产者**和**消费者**模型，生产者向消息队列中不断生产消息，消费者从消息队列中不断获取消息。因为消息的产生和消费都是**异步**的，而且只关心消息的发送和接收，没有业务逻辑的侵入，实现了系统之间的**解耦**。通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。<!--more-->\n应用场景：\n\n- 异步处理\n- 应用解耦\n- 流量削峰\n- 日志处理\n- 消息通讯\n\n## 主流的消息中间件\n\n> ActiveMQ\n\nActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件,在中小型企业颇受欢迎!\n\n> Kafka\n\nKafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于**日志收集和传输**。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。\n\n> RocketMQ\n\nRocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。\n\n> RabbitMQ\n\nRabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。\n\n> AMQP（advanced message queuing protocol）在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。\n\n## RabbitMQ的使用\n\n使用Docker快速安装并启动\n\n```bash\n# 服务端端口5672  客户端端口 15672 \ndocker run --name rabbitmq -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=123456 -d rabbitmq:3-management\n```\n\n### 访问rabbitmq的管理界面\n\n地址为  ip:15672 \n\n<img src=\"rabbitmq-01/1.png\" style=\"zoom:80%;\" />\n\n添加用户，以及虚拟主机\n<img src=\"rabbitmq-01/2.png\" style=\"zoom:80%;\" />\n\n<font color=\"red\">还需要在当前登录管理界面的用户下添加新增的虚拟主机地址，否则监控不到在新增虚拟主机下的创建的消息队列！</font>\n![](rabbitmq-01/3.png)\n\n### 使用java创建消息队列模型\n\n引入依赖\n\n```xml\n<dependency>\n    <groupId>com.rabbitmq</groupId>\n    <artifactId>amqp-client</artifactId>\n    <version>5.7.2</version>\n</dependency>\n```\n\n#### 第一种模型（直连）\n\n![](rabbitmq-01/4.png)\n\n- P：生产者，也就是要发送消息的程序。\n- C：消费者：消息的接收者，会一直等待消息到来。\n- queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。\n\n**生产者的实现：**\n\n```java\n// 生产消息\npublic class MessageProvider {\n\n    public static void main(String[] args) throws IOException, TimeoutException {\n        // 创建连接mq的连接工厂对象\n        ConnectionFactory connectionFactory = new ConnectionFactory();\n        // 设置连接的rabbitmq主机\n        connectionFactory.setHost(\"172.16.1.57\");\n        connectionFactory.setPort(6000);\n        // 设置连接的虚拟主机\n        connectionFactory.setVirtualHost(\"/rabbitmq_study\");\n        // 设置访问虚拟主机的用户名和密码\n        connectionFactory.setUsername(\"zyz\");\n        connectionFactory.setPassword(\"2824199842\");\n        // 获取连接对象\n        Connection connection = connectionFactory.newConnection();\n        // 获取连接中的通道\n        Channel channel = connection.createChannel();\n        // 将通道绑定消息队列\n        /**\n         * 参数1: 队列名称 不存在则自动创建\n         * 参数2：用来定义队列的特性是否要持久化 true or false\n         * 参数3：是否独占队列\n         * 参数4：是否在消费完成后自动删除队列\n         * 参数5：附加参数\n         */\n        channel.queueDeclare(\"hello\", false, false, false, null);\n        // 通过通道发布消息\n        /**\n         * 参数1：交换机名称\n         * 参数2：队列名称\n         * 参数3：传递消息额外设置\n         * 参数4：消息的具体内容\n         */\n        channel.basicPublish(\"\", \"hello\", null, \"hello rabbitmq\".getBytes());\n        channel.close();\n        connection.close();\n    }\n}\n```\n\n在管理界面查看创建的mq![](rabbitmq-01/5.png)\n\n**消费者的实现：**\n\n```java\n// 接收消息\npublic class MessageConsumer {\n\n    public static void main(String[] args) throws IOException, TimeoutException {\n        ConnectionFactory connectionFactory = new ConnectionFactory();\n        connectionFactory.setHost(\"172.16.1.57\");\n        connectionFactory.setPort(6000);\n        connectionFactory.setVirtualHost(\"/rabbitmq_study\");\n        connectionFactory.setUsername(\"zyz\");\n        connectionFactory.setPassword(\"2824199842\");\n        Connection connection = connectionFactory.newConnection();\n        Channel channel = connection.createChannel();\n        // 与创建消息队列一致\n        channel.queueDeclare(\"hello\", false, false, false, null);\n        // 消费消息\n        /**\n         * 参数1：队列名称\n         * 参数2：是否开启消息的自动确认机制\n         * 参数3：消费时的回调接口\n         */\n        channel.basicConsume(\"hello\", true, new DefaultConsumer(channel) {\n\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                // 输出消息内容\n                System.out.println(\"body:\" + new String(body));\n            }\n        });\n        // channel.close();\n        // connection.close();\n    }\n}\n```\n\n![](rabbitmq-01/6.png)\n\n> 封装工具类\n\n```java\npublic class RabbitMQUtils {\n    private static ConnectionFactory connectionFactory;\n\n    // 让ConnectionFactory只加载一次\n    static {\n        connectionFactory = new ConnectionFactory();\n        connectionFactory.setHost(\"172.16.1.57\");\n        connectionFactory.setPort(6000);\n        connectionFactory.setVirtualHost(\"/rabbitmq_study\");\n        connectionFactory.setUsername(\"zyz\");\n        connectionFactory.setPassword(\"2824199842\");\n    }\n\n    /**\n     * 获取 RabbitMQ的连接\n     * @return\n     */\n    public static Connection getConnection() {\n        try {\n            Connection connection = connectionFactory.newConnection();\n            return connection;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * 关闭 Connection和 Channel\n     * @param conn\n     * @param channel\n     */\n    public static void close(Connection conn, Channel channel) {\n        try {\n            if (channel != null) channel.close();\n            if (conn != null) conn.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n#### 第二种模型（work queue）\n\n`Work queues`，也被称为（`Task queues`），任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：**让多个消费者绑定到一个队列，共同消费队列中的消息**。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。\n\n![](rabbitmq-01/7.png)\n\n- P：生产者：任务的发布者\n- C1：消费者-1，领取任务并且完成任务，假设完成速度较慢\n- C2：消费者-2：领取任务并完成任务，假设完成速度快\n\n**生产者**\n\n```java\npublic class Provider {\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection conn = RabbitMQUtils.getConnection();\n        // 创建通道\n        Channel channel = conn.createChannel();\n        // 通道绑定消息队列\n        channel.queueDeclare(\"work\",false,false,false,null);\n        // 发布消息\n        for (int i = 0; i < 10; i++) {\n            channel.basicPublish(\"\", \"work\", null, \"work queue\".getBytes());\n        }\n        // 关闭资源\n        RabbitMQUtils.close(conn,channel);\n    }\n}\n```\n\n**消费者-1**\n\n```java\npublic class Consumer1 {\n    public static void main(String[] args) throws IOException {\n        Connection conn = RabbitMQUtils.getConnection();\n        Channel channel = conn.createChannel();\n        channel.queueDeclare(\"work\",false,false,false,null);\n        channel.basicConsume(\"work\",true,new DefaultConsumer(channel){\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(new String(body));\n            }\n        });\n    }\n}\n```\n\n**消费者-2**\n\n```java\npublic class Consumer2 {\n    public static void main(String[] args) throws IOException {\n        Connection conn = RabbitMQUtils.getConnection();\n        Channel channel = conn.createChannel();\n        channel.queueDeclare(\"work\",false,false,false,null);\n        channel.basicConsume(\"work\",true,new DefaultConsumer(channel){\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(new String(body));\n            }\n        });\n    }\n}\n```\n\n- 默认为平均分发，将消息平均分配给每个消费者，这种分发方式叫做循环。\n\n通过关闭自动确认和开启手动确认来保证 “能者多劳 ”------消费快的消费者消费更多的消息。\n\n```java\npublic class Consumer1 {\n    public static void main(String[] args) throws IOException {\n        Connection conn = RabbitMQUtils.getConnection();\n        Channel channel = conn.createChannel();\n        //一次只接受一条未确认的消息\n        channel.basicQos(1);\n        channel.queueDeclare(\"work\",false,false,false,null);\n        // 关闭消息自动确认机制  autoAck : false\n        channel.basicConsume(\"work\",false,new DefaultConsumer(channel){\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(new String(body));\n                // 手动确认\n                // 参数1：消息标识\n                // 参数2：false 一次只确认一个消息\n                channel.basicAck(envelope.getDeliveryTag(),false);\n            }\n        });\n    }\n}\n```\n\n#### 第三种模型（广播）\n\n![](rabbitmq-01/8.png)\n\n在广播模式下，消息发送流程是这样的：\n\n-  可以有多个消费者\n-  每个**消费者有自己的queue**（队列）\n-  每个**队列都要绑定到Exchange**（交换机）\n-  **生产者发送的消息，只能发送到交换机**，交换机来决定要发给哪个队列，生产者无法决定。\n-  交换机把消息发送给绑定过的所有队列\n-  队列的消费者都能拿到消息。实现一条消息被多个消费者消费\n\n**生产者：**\n\n```java\npublic class Provider {\n    public static void main(String[] args) throws Exception {\n        Connection conn = RabbitMQUtils.getConnection();\n        Channel channel = conn.createChannel();\n        // 创建交换机\n        channel.exchangeDeclare(\"log\",\"fanout\");\n        // 发送消息\n        channel.basicPublish(\"log\",\"\",null,\"fanout message\".getBytes());\n        RabbitMQUtils.close(conn,channel);\n    }\n}\n```\n\n**消费者：**\n\n```java\npublic class Customer {\n    public static void main(String[] args) throws Exception{\n        Connection conn = RabbitMQUtils.getConnection();\n        Channel channel = conn.createChannel();\n        // 创建交换机  名称，类型\n        channel.exchangeDeclare(\"log\",\"fanout\");\n        // 创建临时队列\n        String queue = channel.queueDeclare().getQueue();\n        // 绑定临时队列和交换机\n        channel.queueBind(queue,\"log\",\"\");\n        // 消费消息\n        channel.basicConsume(queue,true,new DefaultConsumer(channel){\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"消费者1：\"+new String(body));\n            }\n        });\n    }\n}\n```\n\n此时生产者生产的一条消息可以被多个消费者同时消费。\n\n#### 第四种模型（路由）\n\n在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。\n\n 在Direct模型下：\n\n- 队列与交换机的绑定，不能是任意绑定了，而是要指定一个`RoutingKey`（路由key）\n- 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 `RoutingKey`。\n- Exchange不再把消息交给每一个绑定的队列，而是根据消息的`Routing Key`进行判断，只有队列的`Routingkey`与消息的 `Routing key`完全一致，才会接收到消息\n\n![](rabbitmq-01/9.png)\n\n- P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。\n- X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列\n- C1：消费者，其所在队列指定了需要routing key 为 error 的消息\n- C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息\n\n**生产者：**\n\n```java\npublic class MsProvider {\n    public static void main(String[] args) throws Exception {\n        Connection connection = RabbitMQUtils.getConnection();\n        Channel channel = connection.createChannel();\n        channel.exchangeDeclare(\"log_direct\",\"direct\");\n        channel.basicPublish(\"log_direct\",\"info\",null,\"routingKey为info的消息\".getBytes());\n        RabbitMQUtils.close(connection,channel);\n    }\n}\n```\n\n**消费者：**\n\n```java\npublic class MsConsumer {\n    public static void main(String[] args) throws Exception {\n        Connection connection = RabbitMQUtils.getConnection();\n        Channel channel = connection.createChannel();\n        channel.exchangeDeclare(\"log_direct\",\"direct\");\n        String queue = channel.queueDeclare().getQueue();\n        channel.queueBind(queue,\"log_direct\",\"info\");\n        channel.basicConsume(queue,true,new DefaultConsumer(channel){\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(new String(body));\n            }\n        });\n    }\n}\n```\n\n**Routing模型之topic**\n![](rabbitmq-01/10.png)\n\n`Topic`类型的`Exchange`与`Direct`相比，都是可以根据`RoutingKey`把消息路由到不同的队列。只不过`Topic`类型`Exchange`可以让队列在绑定`Routing key` 的时候使用通配符！这种模型`Routingkey` 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： `item.insert`\n\n`audit.# ` 匹配audit.irs.corporate或者 audit.irs 等\n`audit.* `  只能匹配 audit.irs\n\n","tags":["RabbitMQ"],"categories":["中间件"]},{"title":"JWT原理及使用","url":"/2020/10/18/jwt/","content":"\n## JWT 简介\n\nJSON Web Token的缩写，通过json作为web应用中的令牌，用于在各方之间安全地传输json数据。在数据的传输过程中还可以完成数据加密、签名等。<!--more-->\n\n## JWT的主要用途\n\n**1、认证授权**\n\n- 这是使用JWT的最常见方案。一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。单点登录是当今广泛使用JWT的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。\n\n**2.信息交换**\n\n- JSON Web Token是在各方之间安全地传输信息的好方法。因为可以对JWT进行签名（例如，使用公钥/私钥对），所以您可以确保发件人是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否遭到篡改。\n\n## JWT与Session的区别\n\n### 基于传统的Session认证\n\n**认证方式**\n\n- http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证。那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息(session)。这份登录信息会在响应时传递给浏览器，告诉其保存为cookie(存储sessionid)，以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。\n\n**2.认证流程**\n![](jwt/1.png)\n\n**3.存在的问题**\n\n- 1.每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大\n- 2.用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。\n- 3.因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。\n- 4.在前后端分离系统中就更加痛苦:如下图所示\n\t也就是说前后端分离在应用解耦后增加了部署的复杂性。通常用户一次请求就要转发多次。每次携带sessionid 到服务器，服务器还要查询用户信息。还有就是sessionid就是一个特征值，表达的信息不够丰富，不容易扩展。而且如果后端应用是多节点部署，就需要实现session共享机制。不方便集群应用。\n\t<img src=\"jwt/2.png\" style=\"zoom:80%;\" />\n\n### 基于JWT的认证\n\n**认证流程**\n![](jwt/3.png)\n\n- 首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。\n\n- 后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。形成的JWT就是一个形同aaa.bbb.ccc的字符串。  header.payload.signature\n\n- 后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。\n\n- 前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题) \n\n- 后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。\n- 验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。\n\n**JWT的优势**\n\n- 简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快\n\n- 自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库\n\n- 因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。\n\n- 不需要在服务端保存会话信息，特别适用于分布式微服务。\n\n## JWT的结构\n\n### 1、标头Header\n\n通常由两部分组成：令牌的类型（即JWT）和所使用的签名算法，例如HMAC、SHA256或RSA。它会使用Base64编码组成JWT结构的一部分(aaa.)。\n\n```json\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n### 2、有效载荷Payload\n\n包含有关实体的声明（通常是用户）或其他数据（对用户不敏感的信息）的声明。同样使用Base64编码组成JWT的第二部分（bbb.）\n\n```json\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n\n### 3、签名Signature\n\n前面两部分都是使用Base64进行编码的，即在前端可以Base64解码解开里面的信息。Signature 需要使用\n编码后的header和payload以及我们提供的一个密钥，然后使用header中指明的签名算法（HS256）进行签名，保证JWT没有被篡改过。\n\n例如：```HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload),secret);```\n\n![](jwt/4.png)\n\n最终输出为：\n![](jwt/5.png)\n\n- 输出是三个由点分隔的Base64-URL字符串，可以在HTML和HTTP环境中轻松传递这些字符串，与基于XML的标准（例如SAML）相比，它更紧凑。\n- 简洁(Compact)\n\t可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快\n- 自包含(Self-contained)\n\t负载中包含了所有用户所需要的信息，避免了多次查询数据库\n\n## 整合Springboot\n\n### 1、创建数据库\n\n```sql\nCREATE DATABASE jwt_test;\n\nCREATE table t_user(\nid int PRIMARY KEY auto_increment,\nname varchar(25),\npassword varchar(25)\n);\n\ninsert into t_user(id,name,password) values\n(1,'zhangyuzhen','123456'),\n(2,'zhangsan','123456');\n```\n\n### 2、创建Springboot项目\n\n导入如下依赖：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<!--引入jwt-->\n<dependency>\n    <groupId>com.auth0</groupId>\n    <artifactId>java-jwt</artifactId>\n    <version>3.4.0</version>\n</dependency>\n<!--引入mybatis-->\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.1.3</version>\n</dependency>\n<!--引入lombok-->\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.12</version>\n</dependency>\n<!--引入druid-->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.1.19</version>\n</dependency>\n<!--引入mysql-->\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>8.0.19</version>\n</dependency>\n```\n\n### 3、编写配置文件\n\n```properties\nserver.port=8989\n\n\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/jwt_test?serverTimezone=Asia/Shanghai\nspring.datasource.username=root\nspring.datasource.password=2824199842\n\nmybatis.type-aliases-package=com.zyz.po\nmybatis.mapper-locations=classpath:com/zyz/mapper/*.xml\n\nlogging.level.com.zyz.dao=debug\n```\n\n先测试数据库是否能连接成功\n\n```java\n@SpringBootTest\nclass SpringbootJwtApplicationTests {\n\n    @Autowired\n    DataSource dataSource;\n    @Test\n    void contextLoads() throws SQLException {\n        Connection connection = dataSource.getConnection();\n        System.out.println(connection);\n        System.out.println(connection.getClass());\n    }\n}\n```\n\n### 4、创建项目的包结构\n\n![](jwt/10.png)\n\n编写各层的代码：\n\n> po\n\n```java\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n    private Integer id;\n    private String name;\n    private String password;\n}\n```\n\n> dao       @Repository可以省略，因为其接口对应的mapper文件通过namespace与之相关联，生成的实现类总是在容器中\n\n```java\n@Repository\npublic interface UserDao {\n    User login(User user);\n\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.zyz.dao.UserDao\">\n\n    <select id=\"login\" parameterType=\"User\" resultType=\"User\">\n        select id,name from t_user where name=#{name} and password=#{password}\n    </select>\n\n</mapper>\n```\n在Springboot启动类上中添加dao接口包扫描的注解@MapperScan(\"com.zyz.dao\")或者在每个dao接口中添加@Mapper注解\n> service\n\n```\npublic interface UserService {\n    User login(User user);\n}\n```\n\n```java\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private UserDao userDao;\n\n    @Override\n    public User login(User user) {\n        User user1 = userDao.login(user);\n        if(ObjectUtils.isEmpty(user1)){\n            throw new RuntimeException(\"登录失败！\");\n        }\n        return user1;\n    }\n}\n```\n\n> utils\n\n```java\n/**\n * 创建 Token\n */\npublic class JWTUtils {\n    // 密钥\n    private static final String SIGNATURE = \"qwertyuiopasdfghjklzxcvbnm\";\n\n\n    /**\n     * 生成 Token  header.payload.signature\n     * @param map\n     * @return\n     */\n    public static String getToken(Map<String,String> map){\n        // 设置token有效时长\n        Calendar instance = Calendar.getInstance();\n        instance.add(Calendar.DATE,7);// 有效期为7天\n        JWTCreator.Builder builder = JWT.create();\n        // 设置header  header有默认值，无需手动设置 默认加密方式为HMAC256\n        // 设置payload  遍历map将键值对存入payload\n        map.forEach((key,value)->{builder.withClaim(key,value);});\n        String token = builder\n                // 设置token过期时长\n                .withExpiresAt(instance.getTime())\n                // 设置signature\n                .sign(Algorithm.HMAC256(SIGNATURE));\n        return token;\n    }\n\n    /**\n     * 验证 token\n     * @param token\n     */\n    public static DecodedJWT verify(String token){\n       return JWT.require(Algorithm.HMAC256(SIGNATURE)).build().verify(token);\n    }\n\n}\n```\n\n> controller\n\n```java\n@RestController\npublic class UserController {\n    @Autowired\n    private UserService userService;\n\n    @PostMapping(\"/user/login\")\n    public Map<String,Object> login(@RequestBody User user){\n        Map<String, Object> map = new HashMap<>();\n        try {\n            User realUser = userService.login(user);\n            Map<String, String> payload = new HashMap<>();// 用来存放payload\n            payload.put(\"id\",realUser.getId().toString());\n            payload.put(\"name\",realUser.getName());\n            String token = JWTUtils.getToken(payload);// 创建token\n            map.put(\"status\",true);\n            map.put(\"msg\",\"认证成功！\");\n            map.put(\"token\",token);// 认证成功返回token\n        } catch (Exception e) {\n            map.put(\"status\",false);\n            map.put(\"msg\",e.getMessage());\n        }\n        return map;\n    }\n\n    @GetMapping(\"/hello\")\n    public String hello(){\n        return \"hello!\";\n    }\n\n}\n```\n\n> interceptor  编写用于token验证的拦截器\n\n```java\npublic class JWTInterceptor implements HandlerInterceptor {\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        String token = request.getHeader(\"token\");\n        Map<String,Object> map = new HashMap<>();\n        try {\n            JWTUtils.verify(token);// 验证token\n            return true;// 放行\n        } catch (TokenExpiredException e) {\n            map.put(\"state\", false);\n            map.put(\"msg\", \"Token已经过期!!!\");\n        } catch (SignatureVerificationException e){\n            map.put(\"state\", false);\n            map.put(\"msg\", \"签名错误!!!\");\n        } catch (AlgorithmMismatchException e){\n            map.put(\"state\", false);\n            map.put(\"msg\", \"加密算法不匹配!!!\");\n        } catch (Exception e) {\n            e.printStackTrace();\n            map.put(\"state\", false);\n            map.put(\"msg\", \"无效token~~\");\n        }\n        // 将map转换为json格式返回给前端\n        String json = new ObjectMapper().writeValueAsString(map);\n        response.setContentType(\"application/json;charset=UTF-8\");\n        response.getWriter().println(json);\n        return false;\n    }\n}\n```\n\n> config  使编写的拦截器生效\n\n```java\n@Configuration\npublic class InterceptorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new JWTInterceptor())\n                .addPathPatterns(\"/**\") // 拦截所有请求\n                .excludePathPatterns(\"/user/**\");// 与用户相关的请求除外\n    }\n}\n```\n\n## 使用Postman测试\n\n认证成功时：\n<img src=\"jwt/6.png\"/>\n\n认证失败时：\n<img src=\"jwt/7.png\" />\n\n测试被拦截器拦截的接口：\n不携带token:\n![](jwt/8.png)\n\n携带token:\n![](jwt/9.png)\n\n","tags":["JWT"],"categories":["JavaEE"]},{"title":"Dubbo简介","url":"/2020/10/15/dubbo/","content":"\n## 分布式简介\n\n分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统。<!--more-->\n\n## 发展的演变\n\n![](dubbo/1.jpg)\n\n> 单一应用架构\n\n当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。\n<img src=\"dubbo/2.jpg\" style=\"zoom:80%;\" />\n\n缺点：1、拓展性能比较难；2、协同开发问题；3、不利于升级维护\n\n> 垂直应用架构\n\n当访问量逐渐增大，单独增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。\n![](dubbo/3.png)\n\n通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。\n\n缺点： 公用模块无法重复利用，开发性的浪费。\n\n> 分布式服务架构\n\n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。\n![](dubbo/4.png)\n\n> 流式计算架构\n\n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于**提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]**是关键。\n![](dubbo/5.png)\n\n## RPC\n\nRemote Procedure Call 是指远程过程调用，是进程之间的一种通讯方式。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即在A服务器中调用B服务器中的代码，本质上编写的调用代码基本相同，RPC框架帮我们屏蔽了调用实现的细节。\n\n调用的过程：\n![](dubbo/6.png)\n\nRPC的核心模块是：通讯，序列化。\n常见的RPC框架：dubbo、gRPC、Thrift、HSF\n\n## Dubbo\n\nApache Dubbo 是一个基于Java的高性能，轻量级的RPC框架。Dubbo提供了三个关键功能，包括基于接口的远程呼叫，容错和负载平衡以及自动服务注册和发现。\n\nDubbo架构：\n![](dubbo/7.png)\n\n**服务提供者（Provider）**：暴露服务的服务提供方，服务提供者在启动时，向注册中心**注册**自己提供的服务。\n\n**服务消费者（Consumer）**: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心**订阅**自己所需的服务，服务消费者从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n\n**注册中心（Registry）**：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者.\n\n**监控中心（Monitor）**：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n## 调用过程\n\n<img src=\"dubbo/8.png\" style=\"zoom:80%;\" />\n\n","tags":["Dubbo"],"categories":["分布式"]},{"title":"单例设计模式","url":"/2020/10/09/designmodel-02/","content":"\n设计模式分为三种类型：创建型模式、结构型模式、行为型模式，共23种。<!--more-->\n\n## 单例设计模式\n\n单例设计模式属于创建型模式，就是采取一定的方法保证整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个获取该对象实例的方法(静态方法)。\n\n### 单例模式的几种写法\n\n#### 饿汉式（静态常量）\n\n步骤：\n1、构造器私有化；\n2、类内部创建一个静态的对象实例并私有化；\n3、对外暴露一个静态的公共方法getInstance()\n\n```java\npublic class SingletonTest1 {\n    public static void main(String[] args) {\n        Singleton instance1 = Singleton.getInstance();\n        Singleton instance2 = Singleton.getInstance();\n        System.out.println(instance1==instance2);// true\n    }\n}\n\nclass Singleton{\n    // 私有化构造器\n    private Singleton(){\n\n    }\n\n    // 创建静态实例对象\n    private static final Singleton singleton = new Singleton();\n\n    // 对外暴露获取实例的静态方法\n    public static Singleton getInstance(){\n        return singleton;\n    }\n}\n\n```\n\n优点：在类装载时就完成了对象的实例化，避免了线程同步问题。\n缺点：由于在类加载时就完成了类的实例化，没有达到懒加载的效果，如果这个实例对象一直没有使用过，就会造成内存的浪费。\n\n#### 饿汉式（静态代码块）\n\n```java\npackage com.zyz.singleton;\n\npublic class SingletonTest2 {\n    public static void main(String[] args) {\n        Singleton instance1 = Singleton.getInstance();\n        Singleton instance2 = Singleton.getInstance();\n        System.out.println(instance1==instance2);// true\n    }\n}\n\nclass Singleton{\n    // 私有化构造器\n    private Singleton(){\n\n    }\n    \n    // 创建静态对象\n    private static Singleton singleton;\n\n    // 在静态代码块中实例化对象\n    static {\n        singleton = new Singleton();\n    }\n    \n    // 对外暴露获取实例的静态方法\n    public static Singleton getInstance(){\n        return singleton;\n    }\n}\n```\n\n#### 懒汉式（线程不安全）\n\n```java\npublic class SingletonTest3 {\n    public static void main(String[] args) {\n        Singleton instance1 = Singleton.getInstance();\n        Singleton instance2 = Singleton.getInstance();\n        System.out.println(instance1==instance2);// true\n    }\n}\n\nclass Singleton{\n    // 私有化构造器\n    private Singleton(){\n\n    }\n\n    // 私有化静态变量\n    private static Singleton singleton;\n\n    // 暴露获取实例对象的静态方法，使用该方法才创建对象\n    public static Singleton getInstance(){\n        // 对象实例不存在就创建，否则直接返回\n        if(singleton==null){\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n}\n```\n\n达到了懒加载的效果，但是存在线程安全问题，在多线程环境下可能会创建多个对象实例。\n\n#### 懒汉式（线程安全，同步方法）\n\n使用```synchronized```关键字修饰getInstance()方法\n\n#### 双重检查\n\n解决了线程安全问题，懒加载问题，同时保证了效率，在实际开发中推荐使用。\n\n```java\npublic class SingletonTest4 {\n    public static void main(String[] args) {\n        Singleton instance1 = Singleton.getInstance();\n        Singleton instance2 = Singleton.getInstance();\n        System.out.println(instance1 == instance2);// true\n    }\n}\n\nclass Singleton {\n\n    // 私有化构造器\n    private Singleton() {\n\n    }\n\n    // 私有化静态变量\n    // 使用volatile保证变量在多个线程之间的可见性，防止指令重排列\n    private static volatile Singleton singleton;\n\n    // 暴露获取实例对象的静态方法，使用该方法才创建对象\n    public static Singleton getInstance() {\n        // 双重检查，对象实例不存在就创建，否则直接返回\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n\n#### 静态内部类\n\n静态内部类不会自动加载，只有调用静态内部类的方法，静态域，或者构造方法的时候才会加载，并且只加载一次。\n\n```java\npublic class SingletonTest5 {\n    public static void main(String[] args) {\n        Singleton instance1 = Singleton.getInstance();\n        Singleton instance2 = Singleton.getInstance();\n        System.out.println(instance1 == instance2);// true\n    }\n}\n\nclass Singleton {\n\n    // 私有化构造器\n    private Singleton() {\n\n    }\n\n    // 使用静态内部类，提供一个实例\n    private static class SingletonInstance{\n        private static final Singleton INSTANCE = new Singleton();\n    }\n\n    // 暴露获取实例对象的静态方法，使用该方法才加载静态内部类，并返回一个实例对象\n    public static Singleton getInstance() {\n        return SingletonInstance.INSTANCE;\n    }\n}\n```\n\n#### 枚举\n\n```java\npublic class SingletonTest6 {\n    public static void main(String[] args) {\n        Singleton instance1 = Singleton.INSTANCE;\n        Singleton instance2 = Singleton.INSTANCE;\n        System.out.println(instance1 == instance2);// true\n    }\n}\n\nenum Singleton {\n    INSTANCE;\n}\n```\n\n### 单例模式的使用场景\n\n- 需要频繁创建和销毁的对象\n- 创建对象时耗时过多或耗费资源过多\n- 工具类对象\n- 频繁访问数据库或文件的对象（比如数据源、session工厂等）\n\n","tags":["设计模式"],"categories":["设计模式"]},{"title":"设计模式七大原则","url":"/2020/10/07/designmodel-01/","content":"\n## 设计模式七大原则\n\n### 单一职责原则\n\n对一个类来说，一个类应该只负责一项职责。例如dao中的UserDao，OrderDao等等。<!--more-->\n\n### 接口隔离原则\n\n一个类对于另一个类的依赖应该建立在最小接口上，即 将具有多个功能的接口拆分为多个接口。\n\n### 依赖倒转原则\n\n高层模块不应该依赖于低层模块，二者都应该依赖其抽象类。\n依赖倒转的中心思想是面向接口编程。使用接口或抽象类定制号规范，而不涉及具体的操作，将具体的操作交给其实现类去实现。\n\n依赖关系的三种传递方式：\n\n- 接口传递\n\n\t```java\n\tpublic class DependencyPass1 {\n\t    public static void main(String[] args) {\n\t        InternetTV internetTV = new InternetTV();\n\t        OpenAndClose openAndClose = new OpenAndCloseImpl();\n\t        openAndClose.open(internetTV);\n\t    }\n\t}\n\t\n\t// 实体接口\n\tinterface TV {\n\t    public void play();\n\t}\n\t\n\t// 功能接口\n\tinterface OpenAndClose {\n\t    public void open(TV tv);// 接收接口\n\t}\n\t\n\t// 实现实体接口\n\tclass InternetTV implements TV {\n\t    @Override\n\t    public void play() {\n\t        System.out.println(\"InternetTV中的play()被调用\");\n\t    }\n\t}\n\t\n\t// 实现功能接口\n\tclass OpenAndCloseImpl implements OpenAndClose {\n\t    @Override\n\t    public void open(TV tv) {\n\t        tv.play();\n\t    }\n\t}\n\t```\n\n- 构造器传递\n\n\t```java\n\tpublic class DependencyPass2 {\n\t    public static void main(String[] args) {\n\t        InternetTV internetTV = new InternetTV();\n\t        OpenAndClose openAndClose = new OpenAndCloseImpl(internetTV);\n\t        openAndClose.open();\n\t    }\n\t}\n\t// 实体接口\n\tinterface TV {\n\t    public void play();\n\t}\n\t\n\t// 功能接口\n\tinterface OpenAndClose {\n\t    public void open();\n\t}\n\t\n\t// 实现实体接口\n\tclass InternetTV implements TV {\n\t    @Override\n\t    public void play() {\n\t        System.out.println(\"InternetTV中的play()被调用\");\n\t    }\n\t}\n\t\n\t// 实现功能接口\n\t// 通过构造方法接收接口\n\tclass OpenAndCloseImpl implements OpenAndClose {\n\t    private TV tv;\n\t\n\t    public OpenAndCloseImpl(TV tv) {\n\t        this.tv = tv;\n\t    }\n\t\n\t    @Override\n\t    public void open() {\n\t        tv.play();\n\t    }\n\t}\n\t```\n\n- setter方式传递\n\n\t```java\n\tpublic class DependencyPass3 {\n\t    public static void main(String[] args) {\n\t        InternetTV internetTV = new InternetTV();\n\t        OpenAndCloseImpl openAndClose = new OpenAndCloseImpl();\n\t        openAndClose.setTv(internetTV);\n\t        openAndClose.open();\n\t    }\n\t}\n\t\n\t// 实体接口\n\tinterface TV {\n\t    public void play();\n\t}\n\t\n\t// 功能接口\n\tinterface OpenAndClose {\n\t    public void open();\n\t}\n\t\n\t// 实现实体接口\n\tclass InternetTV implements TV {\n\t    @Override\n\t    public void play() {\n\t        System.out.println(\"InternetTV中的play()被调用\");\n\t    }\n\t}\n\t\n\t// 实现功能接口\n\t// 通过setter方法接收接口\n\tclass OpenAndCloseImpl implements OpenAndClose {\n\t    private TV tv;\n\t\n\t    public void setTv(TV tv) {\n\t        this.tv = tv;\n\t    }\n\t\n\t    @Override\n\t    public void open() {\n\t        tv.play();\n\t    }\n\t}\n\t```\n### 里氏替换原则\n\n让原来的子类和父类都继承一个通用的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。\n\n### 开闭原则\n\n对扩展开放，修改关闭。\n使用抽象类提供模板，在进行拓展时，继承抽象类实现具体的方法即可。\n\n### 迪米特法则\n\n一个对象应该对其他对象保持最少的了解，用来降低程序之间的耦合度。\n\n### 合成复用原则\n\n尽量使用合成或聚合关系，少使用继承关系。\n\n## 类的关系\n\n### 依赖关系 Dependency\n\n只要是在类中使用到了对方，他们之间就存在依赖关系。\n![](designModel-01/1.png)\n\nA依赖于B，A作为箭头的起点，即箭头从主语开始，指向宾语。所有的关系都是这样子的！\n\n```java\npublic class PersonServiceBean{\n    private PersonDao personDao;\n    public void save(Person person){}\n    public IDCard getIDCard(Integer personId){}\n    public void modify(){\n        Department department = new Department();\n    }\n}\n\npublic class PersonDao{}\n\npublic class Person{}\n\npublic class IDcard{}\n\npublic class Department{}\n```\n\n### 泛化关系 Generalization\n\n就是继承关系，它是依赖关系的特例。\n![](designModel-01/2.png)\n\n### 实现关系 Realization\n\n就是A类实现B类，也是依赖关系的特例\n![](designModel-01/3.png)\n\n### 关联关系 Association\n\n类与类之间的联系，也是依赖关系的特例。\n关联具有导航性，即单向或双向。\n关联具有多重性，一对一或一对多\n\n单向一对一：\n![](designModel-01/4.png)\n\n双向一对一：\n![](designModel-01/5.png)\n\n### 聚合关系 Aggregation\n\n表示整体和局部之间的关系，整体和局部可以分开，是关联关系的特例。\n\n> Moniter、Mouse聚合于Computer\n![](designModel-01/6.png)\n\n### 组合关系 Composition\n\n如果聚合关系中整体和局部是不可分开的，就升级为组合关系。\n![](designModel-01/7.png)\n\n","tags":["设计模式"],"categories":["设计模式"]},{"title":"NIO","url":"/2020/09/09/nio/","content":"\n## NIO简介\n\nJava NIO 是从jdk1.4开始引入的一个新的IO API ,可以完全代替标准的IO API。NIO与原来的IO有同样的作用和目的，但是使用方式完全不同，NIO支持**面向缓冲区**的、基于通道的IO操作，读写操作更加高效。<!--more-->\n\n**IO与NIO的区别：**\n<img src=\"nio/1.png\" style=\"zoom:80%;\" />\n\nNIO系统的核心在于：通道（Channel）和缓冲区（Buffer）。通道表示打开到IO设备（文件、套接字等）的连接，缓冲区负责暂时存放传输数据。\n<font color=\"red\">简而言之，Channel负责传输，Buffer负责存储。</font>\n\n## Buffer存取数据\n\n```java\n/**\n * 一、Buffer在NIO中负责数据的存取。缓存区就是数组，用于存储不同类型的数据\n * 根据数据类型不同 boolean除外\n * ByteBuffer\n * CharBuffer\n * ShortBuffer\n * IntBuffer\n * LongBuffer\n * FloatBuffer\n * DoubleBuffer\n * 都通过allocate() 获取缓冲区\n *\n * 二、Buffer存取数据的核心方法\n * put():存\n * get():取\n *\n * 三、Buffer四个核心属性\n * capacity:容量，表示缓冲区中存储数据的最大容量，一旦声明不可改变\n * limit:界限，表示缓冲区可以操作数据的大小，limit后的数据不可操作\n * position:位置，表示缓冲区正在操作数据的位置\n * mark:标记，记录当前 position的位置，可通过 reset恢复到 mark位置\n * 0<=mark<=position<=limit<=capacity\n */\npublic class BufferTest {\n    @Test\n    public void test1(){\n        // 1、分配指定大小的缓冲区\n        System.out.println(\"-------allocate--------\");\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        System.out.println(buffer.position());// 0\n        System.out.println(buffer.limit());// 1024\n        System.out.println(buffer.capacity());// 1024\n        // 2、利用put()存入数据到缓冲区\n        System.out.println(\"----------put----------\");\n        String str = \"abcde\";\n        buffer.put(str.getBytes());\n        System.out.println(buffer.position());// 5\n        System.out.println(buffer.limit());// 1024\n        System.out.println(buffer.capacity());// 1024\n        // 3、切换读取数据模式\n        System.out.println(\"----------flip----------\");\n        buffer.flip();\n        System.out.println(buffer.position());// 0\n        System.out.println(buffer.limit());// 5\n        System.out.println(buffer.capacity());// 1024\n        // 4、利用get()读取数据\n        System.out.println(\"----------get-----------\");\n        byte[] dest = new byte[buffer.limit()];\n        buffer.get(dest);\n        System.out.println(buffer.position());// 5\n        System.out.println(buffer.limit());// 5\n        System.out.println(buffer.capacity());// 1024\n        System.out.println(\"读取的数据：\"+new String(dest,0,dest.length));\n        // 5、rewind():可重复读取数据 将核心属性恢复到读之前的状态\n        System.out.println(\"---------rewind---------\");\n        buffer.rewind();\n        System.out.println(buffer.position());// 0\n        System.out.println(buffer.limit());// 5\n        System.out.println(buffer.capacity());// 1024\n        // 6、clear():清空缓冲区，但是数据还在，处于被遗忘的状态\n        System.out.println(\"---------clear---------\");\n        buffer.clear();\n        System.out.println(buffer.position());// 0\n        System.out.println(buffer.limit());// 1024\n        System.out.println(buffer.capacity());// 1024\n    }\n    \n    @Test\n    public void test2(){\n        String str = \"abcde\";\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        buffer.put(str.getBytes());\n        buffer.flip();\n        byte[] dest = new byte[buffer.limit()];\n        buffer.get(dest,0,2);\n        System.out.println(\"读取到的字符串:\"+new String(dest,0,dest.length));// ab\n        System.out.println(\"position:\"+buffer.position());// 2\n        // 标记position\n        buffer.mark();\n        /**\n         *  buffer.get(dest,2,2);\n         *  System.out.println(\"读取到的字符串:\"+new String(dest,0,dest.length));// acbd\n         */\n        buffer.get(dest,0,2);\n        System.out.println(\"读取到的字符串:\"+new String(dest,0,dest.length));// cd\n        System.out.println(\"position:\"+buffer.position());// 4\n        // reset重置  将position恢复到mark时的位置\n        buffer.reset();\n        System.out.println(\"position:\"+buffer.position());// 2\n        // 判断缓冲区是否还有剩余数据\n        if(buffer.hasRemaining()){\n            // 输出剩余数据的个数\n            System.out.println(buffer.remaining());// 3\n        }\n    }\n}\n```\n\n## 直接缓冲区和非直接缓冲区\n\n非直接缓冲区：通过allocate()方法分配缓冲区，将缓冲区建立在JVM的内存中\n\n直接缓冲区：通过allocateDirect()方法分配，将缓冲区直接建立在物理内存中。可以提高效率。\n\n```java\n@Test\npublic void test3(){\n    ByteBuffer buffer = ByteBuffer.allocateDirect(1024);\n    // 判断是否为直接缓冲区\n    System.out.println(buffer.isDirect());// true\n}\n```\n\n## Channel传输数据\n\n```java\n/**\n * 一、Channel用于源节点与目标节点的连接，负责缓冲区中数据的传输\n * 二、主要实现类：\n * FileChannel\n * SocketChannel\n * ServerSocketChannel\n * DatagramChannel\n * 三、获取通道\n * 1、Java针对支持通道的类提供了 getChannel()方法\n * 本地 IO:\n * FileInputStream/FileOutputStream\n * RandomAccessFile\n * 网络 IO:\n * Socket\n * ServerSocket\n * DatagramSocket\n * 2、jdk1.7中NIO.2针对各个通道提供了静态的 open()方法\n *                 以及Files工具类的 newByteChannel()方法\n */\npublic class ChannelTest {\n    @Test // 完成文件的复制 非直接缓冲区\n    public void test1(){\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        FileChannel fisChannel = null;\n        FileChannel fosChannel = null;\n        try {\n            // 创建输入输出流\n            fis = new FileInputStream(\"1.jpg\");\n            fos = new FileOutputStream(\"2.jpg\");\n            // 获取通道\n            fisChannel = fis.getChannel();\n            fosChannel = fos.getChannel();\n            // 分配缓冲区\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            // 将通道中的数据存入缓冲区\n            while(fisChannel.read(buffer)!=-1){\n                // 读取缓冲区中的数据并写入通道\n                buffer.flip();// 切换成读模式\n                fosChannel.write(buffer);\n                // 清空缓冲区\n                buffer.clear();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            // 关闭资源\n            if(fis!=null){\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fos!=null){\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fisChannel!=null){\n                try {\n                    fisChannel.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fosChannel!=null){\n                try {\n                    fosChannel.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n```java\n@Test // 完成文件的复制(内存映射文件) 直接缓冲区\npublic void test2(){\n    FileChannel fisChannel = null;\n    FileChannel fosChannel = null;\n    try {\n        // 使用相应的通道的open方法获取通道\n        fisChannel = FileChannel.open(Paths.get(\"1.jpg\"), StandardOpenOption.READ);\n        fosChannel = FileChannel.open(Paths.get(\"3.jpg\"),StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.CREATE);\n        // 创建内存映射文件\n        MappedByteBuffer inMapperBuf = fisChannel.map(FileChannel.MapMode.READ_ONLY, 0, fisChannel.size());\n        MappedByteBuffer outMapperBuf = fosChannel.map(FileChannel.MapMode.READ_WRITE, 0, fisChannel.size());\n\n        byte[] dest = new byte[inMapperBuf.limit()];\n        // 直接缓冲区中的数据进行读写\n        inMapperBuf.get(dest);\n        outMapperBuf.put(dest);\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        if(fisChannel!=null){\n            try {\n                fisChannel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if(fosChannel!=null){\n            try {\n                fosChannel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n对于直接字节缓存区来说，JVM会尽最大努力直接在此缓冲区执行本机的IO操作，避免每次调用基础操作系统的。一个本机IO操作之前或之后，将缓冲区的内容复制到中间的缓冲区中。\n<img src=\"nio/3.png\" style=\"zoom:80%;\" />\n\n## 通道之间的数据传输\n\n```java\n@Test // 通道之间的数据传输\npublic void test3(){\n    FileChannel fisChannel = null;\n    FileChannel fosChannel = null;\n    try {\n        fisChannel = FileChannel.open(Paths.get(\"1.jpg\"), StandardOpenOption.READ);\n        fosChannel = FileChannel.open(Paths.get(\"4.jpg\"), StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.CREATE);\n\n        fisChannel.transferTo(0,fisChannel.size(),fosChannel);\n        // fosChannel.transferFrom(fisChannel,0,fisChannel.size());\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        if(fisChannel!=null){\n            try {\n                fisChannel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if(fosChannel!=null){\n            try {\n                fosChannel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n## 分散读取和聚集写入\n\n分散读取：将通道中读取到的数据分散到多个缓冲区中。\n\n聚集写入：将多个缓冲区中的数据写入到一个通道中。\n\n```java\n@Test // 分散读取和聚集写入\npublic void test4() {\n    RandomAccessFile randomAccessFile1 = null;\n    RandomAccessFile randomAccessFile2 = null;\n    FileChannel inChannel = null;\n    FileChannel outChannel = null;\n    try {\n        randomAccessFile1 = new RandomAccessFile(\"1.jpg\", \"rw\");\n        inChannel = randomAccessFile1.getChannel();\n        ByteBuffer buffer1 = ByteBuffer.allocate(102400);\n        ByteBuffer buffer2 = ByteBuffer.allocate(102400);\n        // 分散读取\n        ByteBuffer[] buffers = {buffer1, buffer2};\n        inChannel.read(buffers);\n\n        // 聚集写入\n        randomAccessFile2 = new RandomAccessFile(\"5.jpg\", \"rw\");\n        outChannel = randomAccessFile2.getChannel();\n        for(ByteBuffer buffer:buffers){\n            buffer.flip();\n        }\n        outChannel.write(buffers);\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (randomAccessFile1 != null) {\n            try {\n                randomAccessFile1.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (randomAccessFile2 != null) {\n            try {\n                randomAccessFile2.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inChannel!=null){\n            try {\n                inChannel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (outChannel!=null){\n            try {\n                outChannel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n## 阻塞与非阻塞\n\n- 传统的IO 流都是阻塞式的。当一个线程调用read() 或write()时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。\n- Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端请求。\n\n> 阻塞式IO通信\n\n```java\npublic class BlockTest {\n    /**\n     * 使用 NIO完成网络通信的三个核心\n     * 1、通道 Channel:负责来连接\n     * SocketChannel/ServerSocketChannel\n     * DatagramChannel\n     * 2、缓冲区 buffer: 负责数据存储\n     * 3、选择器 Selector:是SelectableChannel对象的多路复用器，用于监控 SelectableSelector的IO状况\n     */\n    @Test // 图片发送\n    public void client() throws Exception{\n        System.out.println(\"图片发送~\");\n        // 1、获取通道\n        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 9999));\n        FileChannel inFileChannel = FileChannel.open(Paths.get(\"1.jpg\"), StandardOpenOption.READ);\n        // 2、获取缓冲区\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        // 3、读取通道中的数据\n        while (inFileChannel.read(buffer)!=-1){\n            buffer.flip();\n            // 4、发送到服务端\n            socketChannel.write(buffer);\n            buffer.clear();\n        }\n        System.out.println(\"图片发送完成！\");\n        socketChannel.shutdownOutput();\n        // 接收服务端的反馈信息\n        int len = 0;\n        while((len = socketChannel.read(buffer))!=-1){\n            buffer.flip();\n            System.out.println(new String(buffer.array(),0,len));\n            buffer.clear();\n        }\n        // 5、关闭资源\n        inFileChannel.close();\n        socketChannel.close();\n\n    }\n\n    @Test // 图片接收\n    public void server() throws Exception{\n        System.out.println(\"服务端开启!\");\n        // 1、获取通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        FileChannel outFileChannel = FileChannel.open(Paths.get(\"666.jpg\"), StandardOpenOption.WRITE,StandardOpenOption.CREATE);\n        // 2、绑定端口\n        serverSocketChannel.bind(new InetSocketAddress(9999));\n        // 3、获取客户端连接的通道\n        SocketChannel clientSocketChannel = serverSocketChannel.accept();\n        // 4、创建缓冲区\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        // 5、读写数据\n        while(clientSocketChannel.read(buffer)!=-1){\n            buffer.flip();\n            outFileChannel.write(buffer);\n            buffer.clear();\n        }\n        /**\n         * 给客户端发送反馈信息\n         * 1、将数据存入缓冲区\n         * 2、读取缓冲区中的数据并写入客户端通道中\n         * 3、清空缓冲区\n         */\n        buffer.put(\"来自服务端：我已经接收完成了！\".getBytes());\n        buffer.flip();\n        clientSocketChannel.write(buffer);\n        buffer.clear();\n        // 6、关闭资源\n        outFileChannel.close();\n        serverSocketChannel.close();\n        clientSocketChannel.close();\n        System.out.println(\"图片接收完成！\");\n    }\n}\n```\n\n> 非阻塞式IO通信\n\n```java\npublic class NonBlockTest {\n    @Test\n    public void client() throws Exception{\n        // 1、获取通道\n        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 9999));\n        // 2、切换成非阻塞模式\n        socketChannel.configureBlocking(false);\n        // 3、分配缓冲区\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        // 4、发送数据\n        buffer.put(new Date().toString().getBytes());\n        buffer.flip();\n        socketChannel.write(buffer);\n        socketChannel.close();\n\n    }\n\n    @Test\n    public void server() throws Exception{\n        // 1、获取通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        // 2、切换为非阻塞模式\n        serverSocketChannel.configureBlocking(false);\n        // 3、绑定端口\n        serverSocketChannel.bind(new InetSocketAddress(9999));\n        // 4、获取选择器\n        Selector selector = Selector.open();\n        // 5、注册通道到选择器上\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        // 6、通过轮询的方式获取通道\n        while(selector.select()>0){\n            // 7、获取注册的所有选择键\n            Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();\n            while(iterator.hasNext()){\n                SelectionKey selectionKey = iterator.next();\n                // 9、判断事件就绪\n                if(selectionKey.isAcceptable()){\n                    // 10、接收就绪，获取连接\n                    SocketChannel clientSocketChannel = serverSocketChannel.accept();\n                    // 11、设置为非阻塞\n                    clientSocketChannel.configureBlocking(false);\n                    // 12、注册通道并监控读就绪事件\n                    clientSocketChannel.register(selector,SelectionKey.OP_READ);\n                }else if(selectionKey.isReadable()){// 13、获取读就绪状态的通道\n                    SocketChannel clientSocketChannel = (SocketChannel) selectionKey.channel();\n                    ByteBuffer buffer = ByteBuffer.allocate(1024);\n                    int len = 0;\n                    while((len = clientSocketChannel.read(buffer))!=-1){\n                        buffer.flip();\n                        System.out.println(new String(buffer.array()));\n                        buffer.clear();\n                    }\n                }\n                // 14、取消选择键\n                iterator.remove();\n            }\n        }\n    }\n}\n```\n\n","tags":["JavaSE","NIO"],"categories":["JavaSE"]},{"title":"连接查询和索引","url":"/2020/09/09/mysql-senior/","content":"\n## 存储引擎\n\n查看所有引擎以及当前使用的引擎：<!--more-->\n\n```sql\nshow engines;\nshow variables like '%storage_engine%';\n```\n\n主要分为MyISAM与InnoDB\n<img src=\"mysql-senior/1.png\" style=\"zoom:70%;\" />\n\n## 性能下降的原因\n\n1、查询语句写的烂\n\n2、索引失效\n\n3、关联查询太多的join\n\n4、服务器调优及各个参数的设置（缓冲、线程数等）\n\n## 常见的join查询\n\n查询顺序：\n手写：\n<img src=\"mysql-senior/2.png\" style=\"zoom:80%;\" />\n\n机读：\n![](mysql-senior/3.png)\n\n![](mysql-senior/4.png)\n\n七种连接的情况：\n<img src=\"mysql-senior/5.png\" style=\"zoom:80%;\" />\n\n```sql\n# 内连接 左、右表共有\nselect * from t_emp e inner join t_dept d on e.deptid=d.id;\n\n# 左外 左表独有+左、右表共有\nselect * from t_emp e left join t_dept d on e.deptid=d.id;\n\n# 左表有，右表没有\nselect * from t_emp e left join t_dept d on e.deptid=d.id \nwhere d.id is null;\n\n# 全有 左表独有+左、右表共有+右表独有\n# mysql不支持全外\n# select * from  t_emp e full out join t_dept d on e.deptid=d.id;\n# 使用union联合查询 union:联合加去重\nselect * from  t_emp e left join t_dept d on e.deptid=d.id union\nselect * from  t_emp e right join t_dept d on e.deptid=d.id;\n\n# 左、右表各自独有 左表独有+右表独有\nselect * from  t_emp e left join t_dept d on e.deptid=d.id \nwhere d.id is null\nunion\nselect * from  t_emp e right join t_dept d on e.deptid=d.id\nwhere e.deptid is null;\n```\n\n## 索引\n\n### 索引简介\n\n索引就是帮助mysql高速获取数据的一种**数据结构**，目的在于提高查找效率，类比字典，如果查询mysql这个词，首先定位到m字母，然后依次定位到之后的字母，直到找到为止。\n\n<font color=\"red\">**简单的理解为 ” 排好序的快速查找数据结构 “ 。**</font>\n![](mysql-senior/6.png)\n\n为了加快Col2的查找，数据库维护了一个查找二叉树（B树），每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在快速获取相应的数据。\n\n索引也很大，不能完全存储在内存中，一般以索引文件的形式存储在磁盘中。\n\n### 索引分类\n\n> 单值索引(主键索引)\n\n一个索引只包含单个列，一个表可以有多个单值索引。（建议不超过5个）\n\n> normal索引\n\n> 全文索引\n\n> 唯一索引\n\n索引列的值必须唯一，但允许有空值\n\n> 复合索引\n\n一个索引包含了多个列\n\n### 基本语法\n\n> 创建\n\n```sql\ncreate [unique] index indexname on table(cloumnname(length));\n```\n\n```sql\nalter table add [unique] index [indexname] on (columnname(length));\n```\n\n> 删除\n\n```sql\ndrop index [indexname] on table;\n```\n\n> 查看\n\n```sql\nshow index from table\n```\n\n### 索引适用的条件\n\n- 主键自动建立唯一索引；\n-  频繁作为查询条件的字段应该创建索引\n- 查询中与其它表关联的字段，外键关系建立索引\n- 单键/组合索引的选择问题，组合索引性价比更高\n- 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度\n- 查询中统计或者分组字段\n\n### 索引不适用的条件\n\n- 表记录太少\n- 经常增删改的表或者字段\n- Where 条件里用不到的字段不创建索引\n- 过滤性不好的不适合建索引\n\n### 索引失效的情况\n\n索引失效分析工具：\n\n可以使用explain命令加在要分析的sql语句前面，在执行结果中查看key这一列的值，如果为NULL，说明没有使用索引\n\n- 在使用`like“%字段%”`进行查询时，是进行全表扫描的，不会使用索引，因为索引是遵循最左匹配的原则的，所以说当扫描到第一个是“%”时，并不会使用索引进行查询。\n- `or`语句前后没有同时使用索引\n- 查询时没有用到联合索引的第一个字段\n- 在索引字段上使用`not`，`<>`，`!=`。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： `key<>0` 改为 `key>0 or key<0`\n- 对索引字段进行计算操作、字段上使用函数\n\n## sql优化\n\n- 正确使用索引\n- select不要带`*`\n- where后面接索引字段，or两边接索引字段\n- join条件要有索引字段\n- 减少子查询，连表查询\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["MySQL"],"categories":["数据库"]},{"title":"JVM入门","url":"/2020/09/06/jvm/","content":"\n## jvm生命周期\n\n1、jvm启动\n由引导类加载器bootstrap class loader通过创建一个初始类来完成的，这个类是由虚拟机具体的实现指定的。<!--more-->\n\n2、jvm执行\n执行java程序\n\n3、jvm退出\n\n程序正常执行结束；\n程序在执行过程中出现异常或错误；\n操作系统出现错误；\n某线程调用Runtime类中halt()或System类中exit()\n\n## 内存结构图\n\n结构简图：\n<img src=\"jvm/1.png\" style=\"zoom:80%;\" />\n\n## 类加载器\n\n> 三种类加载器：\n\nBootstrapClassLoader  引导类加载器\n是用C/C++实现的，用来加载java的核心类库，没有父加载器，用来加载拓展类加载器，系统类加载器；\n出于安全考虑，Bootstrap加载器只加载 java、javax、sun开头的类。 \n\nExtClassLoader  拓展类加载器\n派生于ClassLoader，父类加载器是BootstrapClassLoader;\n从jre/lib/ext目录加载类库\n\nAppClassLoader 系统类加载器\n派生于ClassLoader，父加载器是ExtClassLoader；\n加载环境变量和系统属性，默认为应用程序的加载类\n\n类加载过程：\n![](jvm/2.png)\n\n> 获取加载器的方法\n\n```java\n// 获取当前类加载器\nclazz.getClassLoader();\n// 获取当前线程上下文的ClassLoader\nThread.currentThread().getContextClassLoader();\n// 获取系统的ClassLoader\nClassLoader.getSystemClassLoader();\n// 获取调用者的ClassLoader\nDriverManager.getCallerClassLoader();\n```\n\n> 双亲委派机制\n\n如果一个类的加载器收到了加载类的请求，并不会马上加载，而是将请求向上委托给父加载器，直到到达引导类加载器；如果父加载器能完成加载类的委托，则成功返回，否则，子加载器才会尝试自己加载。\n![](jvm/3.png)\n好处：\n1、安全，避免用户自定义的类动态加载，替换了java的核心类如`String`;\n2、避免类的重复加载，JVM区分不同的类，不仅仅是根据类名，相同的类被不同的类加载器加载也是不同的两个类。\n\n## 本地方法栈(Native Method Stack)\n\n线程私有，native方法用来调用C/C++程序，在内存中专门开辟了一块区域处理标记为native的代码。\n\n## 程序寄存器(Program Counter Register)\n\n线程私有，存储指向下一条指令的地址。\n\n## 方法区(Method Stack)\n\n各个线程共享，它存储了每个类的结构信息：字段和方法数据、构造方法和普通方法的字节码内容、常量池（jdk1.8在堆中的元空间中）。\n方法区是规范，不同虚拟机的实现不同。（类似于接口的不同实现）\n\n## 虚拟机栈(JVM Stack)\n\n主管程序的运行，在线程创建时创建，它的生命周期跟随线程的生命周期，线程结束时释放，对于栈来说不存在垃圾回收问题，是线程私有的。\n<font color=\"red\">8种基本数据类型，对象的引用变量，实例方法都是在栈内存中分配的。</font>\n栈帧中主要存储3类数据：\n本地变量：输入、输出参数，方法中的变量\n栈操作：记录进栈、出栈\n栈帧数据：运行时数据、方法等\n![](jvm/4.png)\n\n栈+堆+方法区的关系：\n![ ](jvm/5.png)\n\n## 堆(Heap)\n\n主管数据的存储，一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。\n类加载器读取了类文件后，需要把类，方法，常、变量放入堆内存中，保存所有引用类型的真实信息。\n逻辑上分为三个部分：新生区、养老区、元空间\n物理上分为两个部分：新生区、养老区\n<img src=\"jvm/6.png\" style=\"zoom:70%;\" />\n\n> 垃圾回收过程\n\nEden区满了，触发第一次GC，称为Minor GC，将存活数据复制到From区，清空Eden区，\n\n> GC过程（复制 -> 清空 -> 互换），\n> <img src=\"jvm/7.png\" style=\"zoom: 67%;\" />\n\n当Eden区再次触发GC时，会扫描Eden区和From区，对两个区域进行垃圾回收，经过这次回收还存活的对象直接复制到To区，同时把这些数据的年龄加1，清空Eden区和From区，清空后的From区成为下次GC的To区，完成交换，如此交换15次，若数据还有存活则存入养老区。\n\n养老区满了，开启Full GC，FGC多次，养老区也无法腾出空间了，抛出OOM\n\n> 永久代\n\n是一个常驻内存区域，用于存放jdk自身携带的Class,Interface元数据，即运行环境必需的类信息，存放的数据不会被垃圾回收器回收，关闭JVM才会释放。\n\n## GC判断对象可以被回收的两种方式\n\n- 引用计数法：每个对象有一个引用计数属性，新增一个引用计数加一，减少一个引用计数减一，当计数为零时可以被回收。可能存在循环引用的问题，比如A对象引用B对象，而B对象中又引用了A对象，当他们都不再使用后，因为相互引用，引用计数=1，永远无法回收。\n\n- 可达性分析：从GC Roots向下搜索，搜索的路径称为引用链。当一个对象到GC Roots没用任何引用链相连时，说明该对象可回收。\n\n  GC Roots的对象有：\n\n  - 虚拟机栈中的引用的对象\n  - 方法区中的静态属性引用的对象\n  - 方法区中常量引用的对象\n  - 本地方法栈中引用的对象\n\n\n\n\n\n\n\n\n\n","tags":["JVM"],"categories":["JVM"]},{"title":"旅游信息管理系统","url":"/2020/08/17/project-02/","content":"\n# 需求分析\n\n分析各个模块和确定技术选型<!--more-->\n\n- 用户模块\n\t- 登录和注册\n- 省份模块\n\t- 增删改查\n\t- 使用redis作为mybatis的缓存\n- 景点模块\n\t- 增删改查\n\t- 使用redis作为mybatis的缓存\n- 技术选型\n\t- 前端：vue+axios\n\t- 后端：springboot + mybatis + mysql + redis\n\n# 库表设计\n\n1、系统中有哪些表\n\n用户表t_user、省份表t_province、景点表t_place\n\n2、表与表之间的关系\n\n用户表是独立的；省份表与景点表是1:N的关系\n\n3、表中的字段\n\nt_user：id、username、password、email\n\nt_province：id、name、tags、placecounts\n\nt_place：id、name、picpath、hotticket、dimticket、details、provinceid\n\n库：travels\n\n```sql\ncreate table t_user(\n\tid int(6) primary key auto_increment,\n\tusername varchar(20),\n\tpassword varchar(20),\n\temail varchar(30)\n);\n\ncreate table t_province(\n\tid int(6) primary key auto_increment,\n\tname varchar(20),\n\ttags varchar(80),\n\tplacecounts int(4)\n);\n\ncreate table t_place(\n\tid int(6) primary key auto_increment,\n\tname varchar(40),\n\tpicpath mediumtext,\n\thotticket double(7,2),\n\tdimticket double(7,2),\n\tdetails varchar(300),\n\tprovinceid int(6) references t_province(id)\n);\n```\n\n# 编码环节\n\n## 环境准备\n\n1、创建springboot项目\n![](project-02/1.png)\n\n2、导入druid数据据源和文件上传依赖\n\n```xml\n<dependency>\n    <groupId>commons-fileupload</groupId>\n    <artifactId>commons-fileupload</artifactId>\n    <version>1.4</version>\n</dependency>\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.1.23</version>\n</dependency>\n```\n\n3、编写配置文件\n\n```yml\n# 指定工程访问路径\nserver:\n  servlet:\n    context-path: /travelsAdmin\n\nspring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/travels?serverTimezone=Asia/Shanghai\n    username: root\n    password: 2824199842\n\nmybatis:\n  type-aliases-package: com.zyz.bean\n  mapper-locations: classpath:com/zyz/mapper/*.xml\n  configuration:\n    map-underscore-to-camel-case: true\n\nlogging:\n  level:\n    com:\n      zyz:\n        dao: debug\n        service: info\n        controller: info\n```\n\n## 开始编码\n\n### 用户模块\n\n#### 实现注册和登录功能\n\n> bean \n\n```java\npackage com.zyz.bean;\n\n@Data\npublic class User {\n    private String id;\n    private String username;\n    private String password;\n    private String email;\n}\n```\n\n> dao\n\n```java\npackage com.zyz.dao;\n\n@Mapper\n@Repository\npublic interface UserDao {\n    void add(User user);\n    User queryUserByName(String name);\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.zyz.dao.UserDao\">\n\n    <insert id=\"add\" parameterType=\"User\"  keyProperty=\"id\" useGeneratedKeys=\"true\">\n        insert into t_user values(#{id},#{username},#{password},#{email})\n    </insert>\n\n    <select id=\"queryUserByName\" parameterType=\"String\" resultType=\"User\">\n        select id,username,password,email from t_user where username=#{username}\n    </select>\n</mapper>\n```\n\n> service\n\n```java\npackage com.zyz.service;\n\npublic interface UserService {\n\n    void register(User user);\n\n    User queryUserByName(String username);\n\n    User login(User user);\n}\n```\n\n```java\npackage com.zyz.service.impl;\n\n@Service\n@Transactional\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private UserDao userDao;\n\n    @Override\n    public void register(User user) {\n        if (StringUtils.isEmpty(user.getUsername())) {\n            throw new RuntimeException(\"请输入用户名！\");\n        }\n        if (StringUtils.isEmpty(user.getPassword())) {\n            throw new RuntimeException(\"请输入密码！\");\n        }\n        if (StringUtils.isEmpty(user.getEmail())) {\n            throw new RuntimeException(\"请输入邮箱！\");\n        }\n        // 判断用户名是否存在\n        User realUser = userDao.queryUserByName(user.getUsername());\n        if (realUser != null) {\n            throw new RuntimeException(\"该用户名已存在！\");\n        }\n        userDao.add(user);\n    }\n\n    @Override\n    public User queryUserByName(String username) {\n        return userDao.queryUserByName(username);\n    }\n\n    @Override\n    public User login(User user) {\n        if (StringUtils.isEmpty(user.getUsername())) {\n            throw new RuntimeException(\"请输入用户名！\");\n        }\n        if (StringUtils.isEmpty(user.getPassword())) {\n            throw new RuntimeException(\"请输入密码！\");\n        }\n        User realuser = userDao.queryUserByName(user.getUsername());\n        if (realuser == null) {\n            throw new RuntimeException(\"用户名不存在或错误！\");\n        }\n        if (!(user.getPassword().equals(realuser.getPassword()))) {\n            throw new RuntimeException(\"密码错误！\");\n        }\n        return realuser;\n    }\n}\n```\n\n> controller\n\n```java\npackage com.zyz.controller;\n\n@RestController\n@RequestMapping(\"user\")\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    @PostMapping(\"login\")\n    public Map<String,Object> login(@RequestBody User user,String code,HttpServletRequest request){\n        HashMap<String, Object> map = new HashMap<>();\n        try {\n            if (StringUtils.isEmpty(code)) {\n                throw new RuntimeException(\"请输入验证码！\");\n            }\n            // 获取验证码\n            String realcode = (String) request.getServletContext().getAttribute(\"code\");\n            if (!(realcode.equalsIgnoreCase(code))) {\n                throw new RuntimeException(\"验证码错误！\");\n            }\n            User realUser = userService.login(user);\n            map.put(\"user\",realUser);\n            map.put(\"status\",true);\n            map.put(\"msg\",\"提示：登录成功！\");\n        } catch (Exception e) {\n            e.printStackTrace();\n            map.put(\"status\",false);\n            map.put(\"msg\",\"提示：\"+e.getMessage());\n        }\n        return map;\n    }\n\n    /**\n     * 用户登录\n     * @param user\n     * @param code\n     * @param request\n     * @return\n     */\n    @PostMapping(\"register\")\n    public Map<String, Object> register(@RequestBody User user, String code, HttpServletRequest request) {\n        HashMap<String, Object> map = new HashMap<>();\n        try {\n            // 判断验证码是否为空\n            if (StringUtils.isEmpty(code)) {\n                throw new RuntimeException(\"请输入验证码！\");\n            }\n            // 获取验证码\n            String realcode = (String) request.getServletContext().getAttribute(\"code\");\n            if (!(realcode.equalsIgnoreCase(code))) {\n                throw new RuntimeException(\"验证码错误！\");\n            }\n            userService.register(user);\n            map.put(\"status\",true);\n            map.put(\"msg\",\"提示：注册成功！\");\n        } catch (Exception e) {\n            e.printStackTrace();\n            map.put(\"status\", false);\n            map.put(\"msg\", \"提示：\" + e.getMessage());\n        }\n        return map;\n    }\n    /**\n     * 展示验证码\n     * @param request\n     * @return\n     * @throws Exception\n     */\n    @GetMapping(\"getImageCode\")\n    public String getImageCode(HttpServletRequest request) throws Exception {\n        // 使用工具类生成验证码并输出\n        ByteArrayOutputStream os = new ByteArrayOutputStream();\n        String code = VerifyCodeUtils.generateVerifyCode(4);\n        VerifyCodeUtils.outputImage(100, 60, os, code);\n        // 保存至applicationContext域中\n        request.getServletContext().setAttribute(\"code\", code);\n        // 将图片转换为base64格式，返回给前端\n        String s = Base64Utils.encodeToString(os.toByteArray());\n        return \"data:image/png;base64,\" + s;\n    }\n}\n```\n\n> 前端\n>\n> 使用v-model将表单中的数据与vue中data绑定\n\n> 登录\n\n```js\n<script src=\"js/axios.min.js\"></script>\n<script src=\"js/vue.js\"></script>\n<script>\n    var app = new Vue({\n        el: \"#wrap\",\n        data:{\n            date: \"\", \n            url: \"\",\n            user:{},\n            code:\"\",\n        },\n        methods:{\n            getCode(){\n                axios.get(\"http://localhost:8080/travelsAdmin/user/getImageCode?time=\" + Math.random())\n                    .then(res => {\n                        // console.log(res.data);\n                        this.url = res.data;\n                    });\n            },\n            getCodeImage(){ // 验证码点击事件\n                this.getCode();\n            },\n            login(){\n                console.log(this.user);\n                console.log(this.code);\n                axios.post(\"http://localhost:8080/travelsAdmin/user/login?code=\"+this.code,this.user)\n                .then(res=>{\n                    //console.log();\n                    if(res.data.status){\n                        alert(res.data.msg+\"点击确定跳转管理页面\");\n                        localStorage.setItem(\"user\",JSON.stringify(res.data.user));\n                        location.href=\"province/provincelist.html\";\n                    }else{\n                        alert(res.data.msg+\"点击确定重新登录\");\n                    }\n                })\n            }\n        },\n        created(){\n            // 显示验证码\n            this.getCode();\n            // 显示当前日期\n            var realDate = new Date();\n            this.date=realDate.getFullYear()+\"/\"+(realDate.getMonth()+1)+\"/\"+realDate.getDate();\n        },\n    })\n</script>\n```\n\n> 注册\n\n```js\n<script>\n    var app = new Vue({\n        el: \"#wrap\",\n        data:{\n            date: \"\",\n            url: \"\",\n            user:{},\n            code:\"\",\n        },\n        methods:{\n            getCode(){\n                axios.get(\"http://localhost:8080/travelsAdmin/user/getImageCode?time=\" + Math.random())\n                    .then(res => {\n                        // console.log(res.data);\n                        this.url = res.data;\n                    });\n            },\n            getCodeImage(){ // 验证码点击事件\n                this.getCode();\n            },\n            register(){ // 注册\n                // console.log(this.user);\n                // console.log(this.code);\n                // 发起异步请求\n                axios.post(\"http://localhost:8080/travelsAdmin/user/register?code=\"+this.code,this.user)\n                .then(res=>{\n                    // 查看返回的数据\n                    // console.log(res.data);\n                    if(res.data.status){\n                        if(window.confirm(res.data.msg+\"点击确定跳转登录页面\")){\n                            location.href=\"login.html\"\n                        }else {\n                            location.reload();\n                        }\n                    }else {\n                        alert(res.data.msg);\n                    }\n                })\n            }\n        },\n        created(){\n            // 显示验证码\n            this.getCode();\n            // 显示当前日期\n            var realDate = new Date();\n            this.date=realDate.getFullYear()+\"/\"+(realDate.getMonth()+1)+\"/\"+realDate.getDate();\n        },\n    })\n</script>\n```\n\n在管理页面显示当前用户名：\n\n```js\ncreated(){\n    var user = localStorage.getItem(\"user\");\n    if(user==null){\n        location.href=\"http://localhost:8080/travelsAdmin/login.html\"\n    }else{\n        this.user = JSON.parse(user);\n    }\n},\n```\n\n用户退出：\n\n```html\n <a href=\"javascript:;\" @click=\"logout\" style=\"float: right\">安全退出</a>\n```\n\n```js\nmethods:{\n    logout(){\n        localStorage.removeItem(\"user\");\n        location.href=\"http://localhost:8080/travelsAdmin/login.html\";\n    }\n}\n```\n\n### 省份模块\n\n#### 展示所有省份\n\n> bean\n\n```java\npackage com.zyz.bean;\n\n@Data\npublic class Province {\n    private String id;\n    private String name;\n    private String tags;\n    private Integer placecounts;\n}\n```\n\n> dao\n\n抽取BaseDao\n\n```java\n/**\n *\n * @param <T> 类型\n * @param <K> 条件参数的类型\n */\npublic interface BaseDao<T,K> {\n\n    void add(T t);\n\n    void delete(K k);\n\n    void update(T t);\n    \n    T queryByName(K k);\n    \n    T queryById(K k);\n\n    List<T> listByPage(Integer start,Integer rows);\n\n    Integer findTotal();\n\n}\n```\n\nProvinceDao继承BaseDao\n\n```java\npackage com.zyz.dao;\n\n@Mapper\n@Repository\npublic interface ProvinceDao extends BaseDao<Province,String>{\n\n}\n```\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.zyz.dao.ProvinceDao\">\n    <!--  分页查询  -->\n    <select id=\"listByPage\" resultType=\"Province\">\n        select id,name,tags,placecounts from t_province\n        order by placecounts desc\n        limit #{start},#{rows}\n    </select>\n\n    <!-- 查询总记录数 -->\n    <select id=\"findTotal\" resultType=\"Integer\">\n        select count(*) from t_province\n    </select>\n\n</mapper>\n```\n\n> service\n\n```java\npackage com.zyz.service;\n\npublic interface ProvinceService {\n\n    /**\n     * 分页查询\n     * @param page  当前页\n     * @param rows  每一页显示的记录数\n     * @return\n     */\n    List<Province> listByPage(Integer page, Integer rows);\n\n    /**\n     * 查询总记录数\n     * @return\n     */\n    Integer findTotal();\n\n    void add(Province province);\n\n    void delete(String id);\n\n    void update(Province province);\n    \n    Province queryById(String id);\n\n    Province queryByName(String name);\n}\n```\n\n```java\npackage com.zyz.service.impl;\n\n@Service\n@Transactional\npublic class ProvinceServiceImpl implements ProvinceService {\n\n    @Autowired\n    private ProvinceDao provinceDao;\n\n    @Override\n    public List<Province> listByPage(Integer page, Integer rows) {\n        int start = (page-1)*rows;\n        return provinceDao.listByPage(start,rows);\n    }\n\n    @Override\n    public Integer findTotal() {\n        return provinceDao.findTotal();\n    }\n\n    @Override\n    public void add(Province province) {\n        \n    }\n\n    @Override\n    public void delete(String id) {\n\n    }\n\n    @Override\n    public void update(Province province) {\n\n    }\n\n    @Override\n    public Province queryByName(String name) {\n        return null;\n    }\n}\n```\n\n> controller\n\n```java\npackage com.zyz.controller;\n\n@RestController\n@RequestMapping(\"province\")\npublic class ProvinceController {\n\n    @Autowired\n    private ProvinceService provinceService;\n\n    /**\n     * 查询所有省份\n     * @param page\n     * @param rows\n     * @return\n     */\n    @GetMapping(\"listByPage\")\n    public Map<String, Object> listByPage(Integer page, Integer rows) {\n        page = page == null ? 1 : page;\n        rows = rows == null ? 4 : rows;\n        HashMap<String, Object> map = new HashMap<>();\n        // 分页处理\n        List<Province> provinces = provinceService.listByPage(page, rows);\n        // 计算总页数\n        Integer total = provinceService.findTotal();\n        Integer totalPage = total % rows == 0 ? total / rows : (total / rows) + 1;\n        map.put(\"provinces\", provinces);\n        map.put(\"total\", total);\n        map.put(\"totalPage\", totalPage);\n        map.put(\"page\", page);\n        return map;\n    }\n}\n```\n\n> 前端\n\n```js\n<script>\n    var app = new Vue({\n        el: \"#wrap\",\n        data:{\n            date: \"\",\n            url: \"\",\n            user: {},\n            provinces: [],\n            page: 1,\n            rows: 0,\n            totalPage: 0,\n            total: 0,\n        },\n        methods:{\n            // 判断是否登录\n            isLogin(){\n                var user = localStorage.getItem(\"user\");\n                if(user==null){\n                    location.href=\"http://localhost:8080/travelsAdmin/login.html\";\n                }else{\n                    this.user = JSON.parse(user);\n                }\n            },\n            // 显示当前日期\n            showDate(){\n                var realDate = new Date();\n                this.date=realDate.getFullYear()+\"/\"+(realDate.getMonth()+1)+\"/\"+realDate.getDate();\n            },\n            // 退出\n            logout(){\n                localStorage.removeItem(\"user\");\n                location.href=\"http://localhost:8080/travelsAdmin/login.html\";\n            },\n            // 查询所有省份\n            listAll(page){\n                this.page = page;\n                axios.get(\"http://localhost:8080/travelsAdmin/province/listByPage?page=\"+this.page)\n                .then(res=>{\n                    this.provinces = res.data.provinces;\n                    this.page = res.data.page;\n                    this.total = res.data.total;\n                    this.totalPage = res.data.totalPage;\n                });\n            },\n        },\n        created(){\n            // 判断是否登录\n            this.isLogin();\n            // 显示当前日期\n            this.showDate();\n            // 查询所有省份\n            this.listAll(this.page);\n        }\n    })\n</script>\n```\n\n遍历当前查询到的信息\n\n```html\n<tbody>\n<tr v-for=\"province in provinces\" :key=\"province.id\">\n    <td v-text=\"province.id\"></td>\n    <td v-text=\"province.name\"></td>\n    <td v-text=\"province.tags\"></td>\n    <td v-text=\"province.placecounts\"></td>\n</tr>\n</tbody>\n```\n\n分页控件\n\n```html\n <div id=\"pages\">\n     <a href=\"javascript:;\" v-if=\"page!=1\" @click=\"listAll(page-1)\" class=\"page\">&lt;上一页</a>\n     <a href=\"javascript:;\" v-if=\"page==1\" class=\"page\">&lt;上一页</a>\n\n     <span v-for=\"num in totalPage\">\n         <a href=\"javascript:;\" class=\"page\"  v-if=\"num!=page\" @click=\"listAll(num)\" v-text=\"num\"></a>\n         <a href=\"javascript:;\" class=\"page\"  v-if=\"num==page\" v-text=\"num\"></a>\n     </span>\n\n     <a href=\"javascript:;\" v-if=\"page!=totalPage\" @click=\"listAll(page+1)\" class=\"page\">下一页&gt;</a>\n     <a href=\"javascript:;\" v-if=\"page==totalPage\" class=\"page\">下一页&gt;</a>\n</div>\n```\n\n#### 添加省份\n\n> dao\n\n```xml\n<!--  添加省份  -->\n<insert id=\"add\" parameterType=\"Province\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n    insert into t_province values(#{id},#{name},#{tags},#{placecounts})\n</insert>\n\n<!--  根据名称查省份  -->\n<select id=\"queryByName\" parameterType=\"String\" resultType=\"Province\">\n    select id,name,tags,placecounts from t_province where name=#{name}\n</select>\n```\n\n> service\n\n```java\n@Override\npublic void add(Province province) {\n    if(StringUtils.isEmpty(province.getName())){\n        throw new RuntimeException(\"请输入省份！\");\n    }\n    if(StringUtils.isEmpty(province.getTags())){\n        throw  new RuntimeException(\"请输入标签！\");\n    }\n    if(StringUtils.isEmpty(province.getPlacecounts())){\n        throw new RuntimeException(\"请输入景点数量！\");\n    }\n    Province realProvince = provinceDao.queryByName(province.getName());\n    if(!ObjectUtils.isEmpty(realProvince)){\n        throw new RuntimeException(\"该省份已存在！\");\n    }\n    provinceDao.add(province);\n}\n```\n\n> controller\n\n```java\n/**\n * 添加省份\n * @param province\n * @return\n */\n@PostMapping(\"add\")\npublic Map<String,Object> add(@RequestBody Province province){\n    HashMap<String, Object> map = new HashMap<>();\n    try {\n        provinceService.add(province);\n        map.put(\"status\",true);\n        map.put(\"msg\",\"提示：添加成功！\");\n    } catch (Exception e) {\n        e.printStackTrace();\n        map.put(\"status\",false);\n        map.put(\"msg\",\"提示：\"+e.getMessage());\n    }\n    return map;\n}\n```\n\n> 前端\n\n省份管理页：\n\n```html\n<button type=\"button\" @click=\"toAdd\" >添加省份</button>\n```\n\n```js\n// 跳转添加页面\ntoAdd(){\n    location.href=\"addprovince.html\";\n}\n```\n\n添加页：\n\n```js\n// 添加省份方法\nadd() {\n    axios.post(\"http://localhost:8080/travelsAdmin/province/add\", this.province)\n        .then(res => {\n            if (res.data.status) {\n                if (window.confirm(res.data.msg + \"点击确定跳转管理页面\")) {\n                    location.href = \"provincelist.html\";\n                } else {\n                    location.reload();\n                }\n            } else {\n                alert(res.data.msg);\n            }\n        })\n}\n```\n\n#### 删除省份\n\n> dao\n\n```xml\n<!--  删除省份  -->\n<delete id=\"delete\" parameterType=\"String\">\n    delete from t_province where id = #{id}\n</delete>\n```\n\n> serivce\n\n```java\n@Override\npublic void delete(String id) {\n    provinceDao.delete(id);\n}\n```\n\n> controller\n>\n> ```java\n> /**\n>  * 删除省份\n>  * @param id\n>  * @return\n> */\n> @GetMapping(\"delete\")\n> public Map<String,Object> delete(String id){\n>     HashMap<String, Object> map = new HashMap<>();\n>     try {\n>         provinceService.delete(id);\n>         map.put(\"status\",true);\n>         map.put(\"msg\",\"提示：删除成功！\");\n>     } catch (Exception e) {\n>         e.printStackTrace();\n>         map.put(\"status\",false);\n>         map.put(\"msg\",\"提示：删除失败\");\n>     }\n>     return map;\n> }\n> ```\n\n> 前端\n\n```html\n<a href=\"javascript:;\" @click=\"deletePro(province.id)\">删除省份</a>\n```\n\n```js\n// 删除省份\ndeletePro(id) {\n    if (window.confirm(\"确定删除吗？\")) {\n        axios.get(\"http://localhost:8080/travelsAdmin/province/delete?id=\"+id)\n            .then(res => {\n                if (res.data.status) {\n                    alert(res.data.msg);\n                    location.reload();\n                } else {\n                    alert(res.data.msg);\n                }\n            })\n    }\n}\n```\n\n#### 修改省份\n\n> dao\n\n```xml\n<!--  根据id查询省份  -->\n<select id=\"queryById\" parameterType=\"String\" resultType=\"Province\">\n    select id,name,tags,placecounts from t_province where id = #{id}\n</select>\n\n<!--  修改省份  -->\n<update id=\"update\" parameterType=\"Province\">\n    update t_province set name=#{name},tags=#{tags},placecounts=#{placecounts}\n    where id=#{id}\n</update>\n```\n\n> service\n\n```java\n@Override\npublic void update(Province province) {\n    if(StringUtils.isEmpty(province.getName())){\n        throw new RuntimeException(\"请输入省份！\");\n    }\n    if(StringUtils.isEmpty(province.getTags())){\n        throw  new RuntimeException(\"请输入标签！\");\n    }\n    if(StringUtils.isEmpty(province.getPlacecounts())){\n        throw new RuntimeException(\"请输入景点数量！\");\n    }\n    provinceDao.update(province);\n}\n\n@Override\npublic Province queryById(String id) {\n    return provinceDao.queryById(id);\n}\n```\n\n> controller\n\n```java\n/**\n * 修改省份\n * @param province\n * @return\n */\n@PostMapping(\"update\")\npublic Map<String,Object> update(@RequestBody Province province){\n    HashMap<String, Object> map = new HashMap<>();\n    try {\n        provinceService.update(province);\n        map.put(\"status\",true);\n        map.put(\"msg\",\"提示：修改成功！\");\n    } catch (Exception e) {\n        e.printStackTrace();\n        map.put(\"status\",false);\n        map.put(\"msg\",\"提示：\"+e.getMessage());\n    }\n    return map;\n}\n\n/**\n * 获取省份\n * @param id\n * @return\n */\n@GetMapping(\"getProvince\")\npublic Province getProvince(String id){\n    Province province = provinceService.queryById(id);\n    return province;\n}\n```\n\n> 前端\n\n管理页面：\n\n```html\n<a href=\"javascript:;\" @click=\"toUpdate(province.id)\">修改省份</a>\n```\n\n```js\n// 跳转修改页面\ntoUpdate(id) {\n    location.href = \"updateprovince.html?id=\" + id;\n}\n```\n\n修改页面：\n\n```html\n<button type=\"button\" @click=\"update\">修 改</button>&emsp;\n```\n\n```html\n<script>\n    var app = new Vue({\n        el: \"#wrap\",\n        data: {\n            date: \"\",\n            province: {},\n        },\n        methods: {\n            // 显示当前日期方法\n            showDate() {\n                var realDate = new Date();\n                this.date = realDate.getFullYear() + \"/\" + (realDate.getMonth() + 1) + \"/\" + realDate.getDate();\n            },\n            // 根据id查询当前省份\n            getProvince(){\n                // 获取id\n                var start = location.href.lastIndexOf(\"=\");\n                var id = location.href.substring(start+1);\n                axios.get(\"http://localhost:8080/travelsAdmin/province/getProvince?id=\"+id)\n                    .then(res=>{\n                        // console.log(res.data);\n                        this.province = res.data;\n                    })\n            },\n            // 修改省份方法\n            update() {\n                axios.post(\"http://localhost:8080/travelsAdmin/province/update\", this.province)\n                    .then(res => {\n                        if (res.data.status) {\n                            alert(res.data.msg);\n                            location.href = \"provincelist.html\";\n                        } else {\n                            alert(res.data.msg);\n                        }\n                    })\n            }\n        },\n        created() {\n            // 显示当前日期\n            this.showDate();\n            // 查询当前省份的信息\n            this.getProvince();\n        },\n    })\n</script>\n```\n\n### 景点模块\n\n#### 根据省份展示该省份的所有景点\n\n> 创建实体类\n\n```java\npackage com.zyz.bean;\n\n@Data\npublic class Place {\n    private String id;\n    private String name;\n    private String picpath;\n    private Double hotticket;\n    private Double dimticket;// 淡季门票\n    private String details;\n    private String provinceid;\n}\n```\n\n> dao层\n\n```java\npackage com.zyz.dao;\n\n@Mapper\n@Repository\npublic interface PlaceDao  extends BaseDao<Place,String>{\n\n    /**\n     * 根据省份id进行分页查询\n     * @param start\n     * @param rows\n     * @param provinceId\n     * @return\n     */\n    List<Place> listByProvinceId(Integer start,Integer rows,String provinceId);\n\n    /**\n     * 根据省份查询景点总数\n     * @param provinceId\n     * @return\n     */\n    Integer findTotalByProvinceId(String provinceId);\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.zyz.dao.PlaceDao\">\n\n    <!-- 分页查询当前省份的所有景点信息并排序  -->\n    <select id=\"listByProvinceId\" resultType=\"Place\">\n        select id,name,picpath,hotticket,dimticket,details,provinceid\n        from t_place where provinceid = #{provinceId}\n        order by hotticket\n        limit #{start},#{rows}\n    </select>\n\n    <!-- 查询当前省份的景点的个数   -->\n    <select id=\"findTotalByProvinceId\" parameterType=\"String\" resultType=\"Integer\">\n        select count(*) from t_place where provinceid=#{provinceId}\n    </select>\n   \n</mapper>\n```\n\n> serivce层\n\n```java\npackage com.zyz.service;\n\npublic interface PlaceService {\n\n    /**\n     * 根据省份id进行分页查询\n     * @param page\n     * @param rows\n     * @param provinceId\n     * @return\n     */\n    List<Place> listByProvinceId(Integer page, Integer rows, String provinceId);\n\n    /**\n     * 根据省份查询景点总数\n     * @param provinceId\n     * @return\n     */\n    Integer findTotalByProvinceId(String provinceId);\n}\n```\n\n```java\npackage com.zyz.service.impl;\n\n@Service\n@Transactional\npublic class PlaceServiceImpl implements PlaceService {\n\n    @Autowired\n    private PlaceDao placeDao;\n\n    @Autowired\n    private ProvinceDao provinceDao;\n\n    @Override\n    public List<Place> listByProvinceId(Integer page, Integer rows, String provinceId) {\n        int start = (page-1)*rows;\n        return placeDao.listByProvinceId(start,rows,provinceId);\n    }\n\n    @Override\n    public Integer findTotalByProvinceId(String provinceId) {\n        return placeDao.findTotalByProvinceId(provinceId);\n    }\n}\n```\n\n> controller\n\n```java\npackage com.zyz.controller;\n\n@RestController\n@RequestMapping(\"place\")\npublic class PlaceController {\n\n    @Autowired\n    private PlaceService placeService;\n    /**\n     * 展示所有景点\n     * @param page\n     * @param rows\n     * @param provinceId\n     * @return\n     */\n    @GetMapping(\"listAll\")\n    public Map<String, Object> listAll(Integer page, Integer rows, String provinceId) {\n        page = page == null ? 1 : page;\n        rows = rows == null ? 3 : rows;\n        // 总记录数\n        Integer total = placeService.findTotalByProvinceId(provinceId);\n        // 总页数\n        Integer totalPage = total % rows == 0 ? total / rows : (total / rows) + 1;\n        // 景点信息\n        List<Place> places = placeService.listByProvinceId(page, rows, provinceId);\n        HashMap<String, Object> map = new HashMap<>();\n        map.put(\"total\", total);\n        map.put(\"totalPage\", totalPage);\n        map.put(\"places\", places);\n        map.put(\"page\", page);\n        return map;\n    }\n}\n```\n\n#### 增加景点\n\n> dao层\n>\n> 继承了BaseDao中的增删改方法，以及添加所需要的判断景点是否已经存在 的queryByName()方法，修改所需要的回显当前景点信息的queryById()方法，因此只需要编写对应的mapper文件就行\n\n```xml\n<!--添加景点-->\n<insert id=\"add\" parameterType=\"Place\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n    insert into t_place\n    values(#{id},#{name},#{picpath},#{hotticket},#{dimticket},#{details},#{provinceid})\n</insert>\n<!--  根据名称查询景点  -->\n<select id=\"queryByName\" parameterType=\"String\" resultType=\"Place\">\n    select id,name,picpath,hotticket,dimticket,details,provinceid\n    from t_place where name = #{name}\n</select>\n```\n\n> service层，添加add()方法并实现\n\n```java\nvoid add(Place place);\n```\n\n```java\n@Override\npublic void add(Place place) {\n    if(StringUtils.isEmpty(place.getName())){\n        throw new RuntimeException(\"请输入景点名！\");\n    }\n    if(StringUtils.isEmpty(place.getHotticket())){\n        throw  new RuntimeException(\"请输入旺季门票价格！\");\n    }\n    if(StringUtils.isEmpty(place.getDimticket())){\n        throw new RuntimeException(\"请输入淡季门票价格！\");\n    }\n    if(StringUtils.isEmpty(place.getProvinceid())){\n        throw new RuntimeException(\"请选择省份！\");\n    }\n    Place place1= placeDao.queryByName(place.getName());\n    if(!ObjectUtils.isEmpty(place1)){\n        throw new RuntimeException(\"该景点已存在！\");\n    }\n    // 更新此景点省份的景点数量\n    Province province = provinceDao.queryById(place.getProvinceid());\n    province.setPlacecounts(province.getPlacecounts()+1);\n    provinceDao.update(province);\n    placeDao.add(place);\n}\n```\n\n> controller层 编写处理添加请求的方法\n\n配置文件上传路径：\n\n```yml\n# 文件上传路径\nupload:\n  dir: D:\\img\n```\n\n```java\n// 注入文件上传路径\n@Value(\"${upload.dir}\")\nprivate String uploadPath;\n\n/**\n* 添加景点\n* @param place\n* @param file\n* @return\n*/\n@PostMapping(\"add\")\npublic Map<String, Object> add(Place place, MultipartFile file) {\n    Map<String, Object> map = new HashMap<>();\n    try {\n        if (!ObjectUtils.isEmpty(file)) {\n            // 修改文件名\n            String filename = UUID.randomUUID().toString()+\".\"\n                + FilenameUtils.getExtension(file.getOriginalFilename());\n            // 将文件转换为base64格式存储到数据库中\n            place.setPicpath(Base64Utils.encodeToString(file.getBytes()));\n            placeService.add(place);\n            // 文件上传\n            file.transferTo(new File(uploadPath,filename));\n            map.put(\"status\",true);\n            map.put(\"msg\",\"提示：添加成功！\");\n        }else{\n            throw new RuntimeException(\"请上传图片！\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        map.put(\"status\",false);\n        map.put(\"msg\", \"提示\"+e.getMessage());\n    }\n    return map;\n}\n```\n\n> 修改前端页面\n\n携带省份id跳转到添加页面，便于返回\n\n```js\ntoAdd(){\n    var start = location.href.indexOf(\"=\");\n    var provinceid = location.href.substring(start+1);\n    location.href = \"addviewspot.html?provinceid=\"+provinceid;\n},\n```\n\n```html\n<script>\n    var app = new Vue({\n        el: \"#wrap\",\n        data: {\n            date: \"\",\n            provinces: [],\n            place: {\n                name: \"\",\n                picpath: \"\",\n                hotticket: \"\",\n                dimticket: \"\",\n                details: \"\",\n                provinceid: \"\",\n                myfile: \"\"\n            },\n        },\n        methods: {\n            // 判断是否登录\n            isLogin() {\n                var user = localStorage.getItem(\"user\");\n                if (user == null) {\n                    alert(\"请登录！\");\n                    location.href = \"http://localhost:8080/travelsAdmin/login.html\";\n                }\n            },\n            // 显示当前日期\n            showDate() {\n                var realDate = new Date();\n                this.date = realDate.getFullYear() + \"/\" + (realDate.getMonth() + 1) + \"/\" + realDate.getDate();\n            },\n            // 查询省份\n            listAllProvince() {\n                axios.get(\"http://localhost:8080/travelsAdmin/province/listByPage?rows=35\")\n                    .then(res => {\n                        //console.log(res.data.provinces);\n                        this.provinces = res.data.provinces;\n                    });\n            },\n            // 添加景点\n            add() {\n                // 构造表单\n                var formData = new FormData();\n                formData.append(\"name\", this.place.name);\n                formData.append(\"hotticket\", this.place.hotticket);\n                formData.append(\"dimticket\", this.place.dimticket);\n                formData.append(\"provinceid\", this.place.provinceid);\n                formData.append(\"details\", this.place.details);\n                formData.append(\"file\", this.$refs.myfile.files[0]);\n                console.log(formData);\n                axios({\n                    method: \"post\",\n                    url: \"http://localhost:8080/travelsAdmin/place/add\",\n                    data: formData,\n                    headers: {'Content-Type': 'multipart/form-data'}\n                }).then(res => {\n                    if (res.data.status) {\n                        if (window.confirm(res.data.msg + \"点击确定跳转景点管理页面\")) {\n                            location.href = \"viewspotlist.html?provinceid=\" + this.place.provinceid;\n                        } else {\n                            location.reload();\n                        }\n                    } else {\n                        alert(res.data.msg + \"点击确定重新添加\")\n                    }\n                })\n            },\n            back() {\n                var start = location.href.indexOf(\"=\");\n                var provinceid = location.href.substring(start + 1);\n                location.href = \"viewspotlist.html?provinceid=\" + provinceid;\n            }\n        },\n        created() {\n            // 判断是否登录\n            this.isLogin();\n            // 显示当前日期\n            this.showDate();\n            // 查询所有省份\n            this.listAllProvince();\n        },\n    })\n</script>\n```\n\n#### 删除景点\n\n> dao\n\n```xml\n<!-- 删除景点   -->\n<delete id=\"delete\" parameterType=\"String\">\n    delete from t_place where id = #{id}\n</delete>\n<!--  根据id查询景点信息  -->\n<select id=\"queryById\" resultType=\"Place\" parameterType=\"String\">\n    select id,name,picpath,hotticket,dimticket,details,provinceid\n    from t_place\n    where id =#{id}\n</select>\n```\n\n> service\n\n```\nvoid delete(String id);\n```\n\n```java\n@Override\npublic void delete(String id) {\n    // 该景点的省份景点数-1\n    // 先查询该景点的所有信息\n    Place place = placeDao.queryById(id);\n    // 查询该景点所在省份的信息\n    Province province = provinceDao.queryById(place.getProvinceid());\n    // 更新该省份的景点数\n    province.setPlacecounts(province.getPlacecounts()-1);\n    provinceDao.update(province);\n    // 删除景点\n    placeDao.delete(id);\n}\n```\n\n> controller\n\n```java\n/**\n * 删除景点\n * @param id\n * @return\n */\n@GetMapping(\"delete\")\npublic Map<String,Object> delete(String id){\n    HashMap<String, Object> map = new HashMap<>();\n    try {\n        placeService.delete(id);\n        map.put(\"status\",true);\n        map.put(\"msg\",\"提示：删除成功！\");\n    } catch (Exception e) {\n        e.printStackTrace();\n        map.put(\"status\",false);\n        map.put(\"msg\",\"提示：\"+e.getMessage());\n    }\n    return map;\n}\n```\n\n> 前端\n\n```js\ndeletePlace(id) {\n    if (window.confirm(\"确定删除此景点吗？\")) {\n        axios.get(\"http://localhost:8080/travelsAdmin/place/delete?id=\" + id)\n            .then(res => {\n                if (res.data.status) {\n                    alert(\"删除成功！\");\n                    location.reload();\n                }\n            })\n    }\n},\n```\n\n#### 修改景点信息\n> service \n\n```java\n Place queryById(String id);\n\n void update(Place place);\n```\n\n```java\n@Override\npublic Place queryById(String id) {\n    return placeDao.queryById(id);\n}\n\n@Override\npublic void update(Place place) {\n    if(StringUtils.isEmpty(place.getName())){\n        throw new RuntimeException(\"请输入景点名！\");\n    }\n    if(StringUtils.isEmpty(place.getHotticket())){\n        throw  new RuntimeException(\"请输入旺季门票价格！\");\n    }\n    if(StringUtils.isEmpty(place.getDimticket())){\n        throw new RuntimeException(\"请输入淡季门票价格！\");\n    }\n    placeDao.update(place);\n}\n```\n\n> controller\n\n```java\n/**\n * 根据id查询景点\n * @param id\n * @return\n */\n@GetMapping(\"queryById\")\npublic Place queryById(String id ){\n   return placeService.queryById(id);\n}\n\n/**\n * 修改景点信息\n * @param place\n * @param photo\n * @return\n */\n@PostMapping(\"update\")\npublic Map<String,Object> update(Place place,MultipartFile photo){\n    HashMap<String, Object> map = new HashMap<>();\n    try {\n        if(!ObjectUtils.isEmpty(photo)){\n            String filename = UUID.randomUUID().toString()+\".\"\n                    +FilenameUtils.getExtension(photo.getOriginalFilename());\n            // 更新picpath\n            place.setPicpath(Base64Utils.encodeToString(photo.getBytes()));\n            // 上传到指定路径\n            photo.transferTo(new File(uploadPath,filename));\n        }\n        // 保存至数据库\n        placeService.update(place);\n        map.put(\"status\",true);\n        map.put(\"msg\",\"提示：修改成功！\");\n    } catch (Exception e) {\n        e.printStackTrace();\n        map.put(\"status\",false);\n        map.put(\"msg\",\"提示：\"+ e.getMessage());\n    }\n    return map;\n}\n```\n\n> 前端\n\n```html\n<script>\n    var app = new Vue({\n        el: \"#wrap\",\n        data: {\n            date: \"\",\n            id: \"\",\n            place: {\n                name:\"\",\n                picpath:\"\",\n                hotticket:\"\",\n                dimticket:\"\",\n                details:\"\",\n                provinceid:\"\",\n                myfile:\"\"\n            },\n            provinces: [],\n            src:\"\",\n        },\n        methods: {\n            // 判断是否登录\n            isLogin() {\n                var user = localStorage.getItem(\"user\");\n                if (user == null) {\n                    alert(\"请登录！\");\n                    location.href = \"http://localhost:8080/travelsAdmin/login.html\";\n                }\n            },\n            // 显示当前日期\n            showDate() {\n                var realDate = new Date();\n                this.date = realDate.getFullYear() + \"/\" + (realDate.getMonth() + 1) + \"/\" + realDate.getDate();\n            },\n            showView(){\n                // 获取id\n                var start = location.href.indexOf(\"=\");\n                var id = location.href.substring(start+1);\n                axios.get(\"http://localhost:8080/travelsAdmin/place/queryById?id=\"+id)\n                .then(res=>{\n                    // console.log(res.data);\n                    this.place = res.data;\n                    // 显示图片\n                    this.src = \"data:image/png;base64,\"+this.place.picpath;\n                    this.id = id;\n                })\n            },\n            queryProvinces(){\n                axios.get(\"http://localhost:8080/travelsAdmin/province/listByPage?rows=35\")\n                .then(res=>{\n                    this.provinces = res.data.provinces;\n                })\n            },\n            back(){\n                location.href=\"viewspotlist.html?provinceid=\"+this.place.provinceid;\n            },\n            updatePlace(){\n                var formData = new FormData();\n                formData.append(\"id\",this.place.id);\n                formData.append(\"name\",this.place.name);\n                formData.append(\"picpath\",this.place.picpath);\n                formData.append(\"photo\",this.$refs.myfile.files[0]);\n                formData.append(\"hotticket\",this.place.hotticket);\n                formData.append(\"dimticket\",this.place.dimticket);\n                formData.append(\"provinceid\",this.place.provinceid)\n                formData.append(\"details\",this.place.details)\n                axios({\n                    method: \"post\",\n                    url: \"http://localhost:8080/travelsAdmin/place/update\",\n                    data: formData,\n                    headers:{'content-type':'multipart/formdata'}\n                }).then(res=>{\n                    if(res.data.status){\n                        alert(res.data.msg+\"点击确定跳转景点管理页面\");\n                        location.href = \"viewspotlist.html?provinceid=\"+this.place.provinceid;\n                    }else{\n                        alert(res.data.msg);\n                    }\n                })\n            }\n        },\n        created() {\n            // 判断是否登录\n            this.isLogin();\n            // 显示当前日期\n            this.showDate();\n            // 显示当前待修改景点的信息\n            this.queryProvinces();\n            this.showView();\n        },\n    })\n</script>\n```\n\n图片上传与显示\n\n```html\n<script>\n    function imgfileChange() {\n        var img_show = document.getElementById(\"img-show\");\n        var imgfile = document.getElementById(\"imgfile\");\n\n        var freader = new FileReader();\n        freader.readAsDataURL(imgfile.files[0]);\n        freader.onload = function (e) {\n            img_show.src = e.target.result;\n        };\n    }\n</script>\n\n<label>\n    <div class=\"label-text\">印象图片：</div>\n    <div style=\"text-align: center;padding-left: 36%\">\n        <img :src=\"src\" alt=\"\" id=\"img-show\">\n        <input type=\"file\" id=\"imgfile\" style=\"display: none\" onchange=\"imgfileChange()\"\n               ref=\"myfile\">\n    </div>\n</label>\n```\n\n省份选择框：\n\n```html\n<label>\n    <div class=\"label-text\">所属省份：</div>\n    <select name=\"ofprovince\" v-model=\"place.provinceid\" style=\"height: 25px;\">\n        <option disabled>请选择省份</option>\n        <option v-for=\"pro in provinces\" v-text=\"pro.name\" :value=\"pro.id\"></option>\n    </select>\n</label>\n```\n\n### 使用Redis作为Mybatis的缓存\n\n1、配置Redis地址和端口\n\n```yml\nspring:\n  redis:\n    host: 127.0.0.1\n    port: 6379\n```\n\n2、实现mybatis中的Cache接口\n\n```java\npackage com.zyz.cache;\n\npublic class RedisCache implements Cache {\n\n    private String id;\n\n    public RedisCache( String id){\n        this.id = id;\n    }\n\n    // 获取RedisTemplate\n    public RedisTemplate getRedisTemplate(){\n        RedisTemplate template =(RedisTemplate) ApplicationContextUtils.getBean(\"redisTemplate\");\n        return template;\n    }\n\n    @Override\n    public String getId() {\n        return this.id;\n    }\n\n    // 将数据存入Redis\n    @Override\n    public void putObject(Object key, Object value) {\n        getRedisTemplate().opsForHash().put(id,key.toString(),value);\n    }\n\n    // 从Redis中获取数据\n    @Override\n    public Object getObject(Object key) {\n        return getRedisTemplate().opsForHash().get(id,key.toString());\n    }\n\n    // 删除指定缓存信息\n    @Override\n    public Object removeObject(Object key) {\n        return getRedisTemplate().opsForHash().delete(id,key.toString());\n    }\n\n    // 清除缓存\n    @Override\n    public void clear() {\n        getRedisTemplate().delete(id);\n    }\n\n    // 获取数据大小\n    @Override\n    public int getSize() {\n        return getRedisTemplate().opsForValue().size(id).intValue();\n    }\n}\n```\n\n工具类ApplicationContextUtils获取工厂实例\n\n```java\npackage com.zyz.utils;\n\n@Component\npublic class ApplicationContextUtils implements ApplicationContextAware {\n\n    // 当前工厂\n    private static ApplicationContext applicationContext;\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n\n    // 获取工厂中的实现类\n    public static Object getBean(String name){\n        return applicationContext.getBean(name);\n    }\n}\n```\n\n3、在mapper文件中添加自定义的Redis缓存\n\n```xml\n <cache type=\"com.zyz.cache.RedisCache\"></cache>\n```\n\n4、存储在Redis中的实体类必须实现Serializable接口\n![](project-02/2.png)\n\n# 主要界面\n\n> 用户模块\n\n![](project-02/3.png)\n\n![](project-02/4.png)\n\n> 省份模块\n\n![](project-02/5.png)\n\n![](project-02/6.png)\n\n![](project-02/7.png)\n\n> 景点模块\n\n![](project-02/8.png)\n\n![](project-02/9.png)\n\n![](project-02/10.png)\n\n# 项目总结\n\n做了什么？\n\n- 管理员的注册和登录\n- 省份信息的增删改查\n- 景点信息的增删改查\n\n学到了什么？\n\n- 在前后端分离中分页查询功能的实现\n- 使用mysql中的meduimtext数据类型存储图片，图片需要先进行base64编码然后存进数据库\n- vue中选择框的数据双向绑定\n\n遇到的问题？怎么解决的？\n\n- 在完成添加景点功能时，在浏览器端调试总是出现undefined的错误，仔细与之前的添加功能相比，此添加功能涉及到了文件的上传，需要构造表单，然后在表单中添加数据\n\t<img src=\"project-02/11.png\" style=\"zoom:80%;\" />\n\n\n\t<img src=\"project-02/12.png\" style=\"zoom:80%;\" />\n\n- 在修改景点信息时，提交一直显示图片未上传，仔细读出现不难发现，如果在修改景点信息时沿用添加景点时的那种方式，![](project-02/13.png)\n\t所以一直显示图片未上传，只要修改一下判断逻辑就可以了，在判断没有修改图片时直接更新，修改图片后进行重命名，文件上传然后更新\n\t![](project-02/14.png)  \n\n- 景点省份为空\n\t![](project-02/15.png)\n\n","tags":["Vue","SpringBoot"],"categories":["小项目"]},{"title":"多线程总结","url":"/2020/08/13/thread/","content":"\n## 进程与线程\n\n> 进程\n\n进程是程序的一次执行过程，是指程序及其数据在处理机上顺序执行时所发生的活动，一组具有独立功能的程序在数据集合上的一次活动，它是系统进行资源分配和调度的独立单位。<!--more-->\n\n> 线程\n\n为了提高系统的执行效率，减少处理机的空转时间和调度切换的时间，以及便于系统管理。提出了线程的概念，将一个进程分为多个线程，线程作为调度和分派的基本单位。线程执行开销小，但不利于资源的管理和保护。\n\n线程的三个基本状态：执行，就绪，阻塞\n\n线程的两个基本类型\n\n- 用户级进程：在用户级线程中，有关线程管理的所有工作都由应用程序完成，**内核意识不到线程的存在**。\n- 系统级进程：在内核级线程中，线程管理的所有工作都由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。\n\n## 并发与并行\n\n**并行：**\n\n- 并行是指**同一时刻**内发生两个或多个事件\n- 并行是在**不同实体（处理机）**上的多个事件\n\n**并发：**\n\n- 并发性是指**同一时间间隔**内发生两个或多个事件\n- 并发是在**同一实体**上的多个事件\n\n并行是针对进程的，并发是针对线程的。\n并发的三大特性：\n\n- **原子性**：一个操作在cpu上执行时不可能中途暂停然后再调度。\n- **可见性**：多个线程对变量的修改是可见的。\n- **有序性**：虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按照我们写的代码的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，虽然对变量的值没有造成影响，但有可能会出现线程安全问题。\n  `synchronized`  保证原子性，可见性，有序性；\n  `volatile `  保证可见性，有序性；\n  `final `  保证可见性\n\n## Java实现多线程\n\n创建多线程的四种方式：\n\n- 继承Thread类，重写run()方法\n- 实现Runnable接口，重写run()方法\n- 实现Callable接口，重写call()方法\n- 使用线程池\n\n**实现Runnable接口**\n\n```java\nclass MyThread2 implements Runnable{\n    // 1、实现Runnable接口中的run()方法\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(Thread.currentThread().getName()+i);\n        }\n    }\n}\npublic static void main(String[] args) {\n       // 3.创建Runnable实现类的对象\n       MyThread2 mThread = new MyThread2();\n       // 4.将此对象作为参数传入Thread类的构造器中，创建Thread()类对象\n       Thread t2 = new Thread(mThread);\n       // 5.通过Thread类对象调用start()方法\n       t2.start();\n\n       // 再启动一个线程 不需要再造实现类对象\n       Thread t3 = new Thread(mThread);\n       t3.start();\n}\n```\n\n**实现Callable接口：**\n\n```java\nclass MyThread3 implements Callable{\n    @Override\n    public Object call() throws Exception {\n        for(int i = 0; i < 100; i++) {\n            System.out.println(Thread.currentThread().getName()+i);\n        }\n        return Thread.currentThread().getName();\n    }\n}\n\npublic static void main(String[] args) {\n        // 创建子线程1\n        // 创建Callable实现类的对象\n        MyThread3 t = new MyThread3();\n        // 实例化FutureTask类，将Callable实现类的对象作为参数传入\n        FutureTask futureTask = new FutureTask(t);\n        FutureTask futureTask1 = new FutureTask(t);\n\n        // Thread(Runnable target)需要传入一个Runnable实现类的对象\n        // 而FutureTask类不仅实现了Future接口，同时也实现了Runnable接口\n        // 因此可将FutureTask类的对象作为参数传入\n        Thread th3 = new Thread(futureTask);\n        th3.setName(\"子线程1：\");\n        th3.start();\n        // 创建子线程2\n        Thread th4 = new Thread(futureTask1);\n        th4.setName(\"子线程2：\");\n        th4.start();     \n    }\n}\n```\n\n> Callable与Runnable 两点不同：\n>\n> 第一，可以通过 call()获得返回值。前两种方式都有一个共同的缺陷，即在任务执行完成后 ，无法直接获取执行结果需要借助共享变量等获取 ，而 Callable和Future则很好地解决了这个问题；\n>\n>  第二， call()可以抛出异常。而 Runnable 要通过 setDefaultUncaughtExceptionHandler() 的方式才能在主线程中捕捉到子线程异常。\n\n**使用线程池**\n\n1、降低创建和销毁线程的资源消耗，提高线程的利用率；\n2、提高响应速度；\n3、提高线程的可管理性。\n\n线程池的使用：\n\n```java\npublic class ThreadPoolUtils {\n\n    private ThreadPoolUtils() {\n    }\n    /**\n     * 根据CPU数量动态配置核心线程数和最大线程数\n     */\n    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();\n    /**\n     * 核心线程数\n     */\n    private static final int CORE_POOL_SIZE = CPU_COUNT + 1;\n    /**\n     * 最大线程数\n     */\n    private static final int CORE_COUNT_MAX = 2 * CPU_COUNT + 1;\n    /**\n     * 非核心线程存活时间\n     */\n    private static final long KEEP_ALIVE_TIME = 1;\n\n    public static ThreadPoolExecutor getThreadPool() {\n        return new ThreadPoolExecutor(CORE_POOL_SIZE, CORE_COUNT_MAX, KEEP_ALIVE_TIME,\n                TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(20), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n    }\n```\n\n- `corePoolSize` 核心线程数，也就是正常工作时创建的线程数，创建后不会销毁，是一种常驻线程。\n- `maxinumPoolSize` 最大线程数，表示允许创建的最大线程数，当核心线程数不够使用时创建，线程的总数不会超过最大线程数。\n- `keepAliveTime` 表示超出核心线程数之外的线程的空闲存活时间 。\n- `unit` 时间单位。\n- `workQueue` 任务队列，核心线程使用完后，将任务放入任务队列，当任务队列满后再创建新的线程。\n- `threadFactory` 线程工厂，用于创建线程。\n- `handler` 任务拒绝策略。当关闭线程池后，任务队列里面没有执行完的任务再向线程池提交时会拒绝；当线程达到最大线程数时继续提交任务也会拒绝。\n  <img src=\"thread/2.png\" style=\"zoom:60%;\" />\n\n```java\npublic class ThreadTest4 {\n    public static void main(String[] args) {\n        // 创建线程池 提供指定线程数量\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        // 创建线程并开始线程\n        service.submit(new MyThread4());\n        service.execute(new MyThread4());\n        // 关闭连接池\n        service.shutdown();\n    }\n}\nclass MyThread4 implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(Thread.currentThread().getName()+\":\"+i);\n        }\n    }\n}\n```\n\n## Java实现多线程要注意的细节\n\n**run()与start()的区别：**\n\n- ```run()```：只是封装了被线程执行的代码，直接调用就是普通方法\n- ```start()：```首先启动了线程，然后再由jvm去调用该线程的run()方法\n\n**java虚拟机的启动是单线程还是多线程的？**\n\n- 是多线程的，不仅启动main线程，还至少启动了垃圾回收线程\n\n**一般使用多线程的哪种实现方式？**\n\n- 使用实现Runnable接口的方式，避免了单继承的局限性\n\n- 应该将并发运行任务和运行机制解耦\n\n## Thread中的常用方法\n\n**获取线程名：**```getName()```\n\n**获取当前线程名：**```Thread.currentThread.getName()```\n\n**设置线程名：**```setName()```\n\n**设置守护进程：**```setDeamon(boolean on)```\n\n- 守护进程\n\t- 就是为其他进程服务的进程，例如垃圾回收的进程\n\t- 当别的用户进程执行完后，虚拟机就会退出，守护进程就会停止\n\t- 设置守护进程时，必须要在线程启动前设置```setDeamon(true)```，启动后设置会抛出异常，\n\t- 使用守护进程不要访问共享资源，因为他们可能在任何时候就挂掉了\n\t- 守护进程中产生的新进程也是守护进程\n\n**设置线程优先级:**```setPriority()```\n\n线程优先级高仅仅表示线程**获取的CPU时间片的几率高**，但这不是一个**确定的因素**！\n\n **线程生命周期方法：**\n\n> sleep()方法\n\n调用sleep方法会进入计时等待状态，等时间到了，**进入的是就绪状态而并非是运行状态**\n![](thread/1.png)\n\n\n\n> yield()方法\n\n暂停当前正在执行的线程，让线程进入就绪状态，把执行机会让给优先级相同或更高的线程，不确保真正的让出。\n\n> join()方法\n\n使调用的线程先执行，执行完后再执行其他线程；低优先级的线程也可以获得执行。\n\n> wait()方法\n\nwait()是Object类中定义的native方法；\n\n一旦线程执行此方法，当前线程就会进入阻塞状态，并释放锁\n\n> notify()方法\n\nnotify()也是Object类中定义的native方法；\n\n一旦执行此方法就会唤醒被wait的一个线程。若有多个线程被wait，则唤醒优先级高的\n\n> notifyAll()方法\n\n也是Object类中的方法，唤醒所有wait的线程\n\n> interrupt()方法\n\n线程中断在之前的版本中有stop()方法，因为存在安全问题被设置过时了。\n\nstop()方法可以让一个线程A终止一个线程B，被终止的线程会立即释放锁，这可能会让对象处于不一致的状态。\n\n一般使用interrupt()来请求终止线程。\n\n- interrupt不会真正停止一个线程，仅仅是发出一个**中断信号**，告诉他应该要结束了\n- 让线程自己处理，到底是中断还是继续执行\n\n```java\nThread t1 = new Thread( new Runnable(){\n    public void run(){\n        // 若未发生中断，就正常执行任务\n        while(!Thread.currentThread.isInterrupted()){\n            // 正常任务代码……\n        }\n        // 中断的处理代码……\n        doSomething();\n    }\n} ).start();\n```\n\n如果阻塞线程调用了interrupt()方法，那么会**抛出异常，设置标志位为false，同时该线程会退出阻塞**。\n\nThread.interrupted() ：第一次使用返回true，并清除中断标志位，第二次返回false\n\n## synchronized锁与Lock锁\n\n**synchronized锁使用：**\n\n> 方式一：同步代码块\n\n将可能出现线程安全问题的代码使用```synchronized```关键字包裹\n\n```java\nsynchronized(/*锁*/){// 要保证是同一把锁\n    // 需要同步的代码\n}\n```\n\n> 方式二：同步方法\n\n 将可能出现线程安全问题的代码块封装成一个同步方法\n\n```java\npublic void synchronized func(){\n    // 方法体\n}\n```\n\n**Lock锁**\n\n通过显式定义同步锁对象，即Lock对象，来实现同步。\n\n```java\nclass buyTicket implements Runnable{\n    private int ticketNum = 100;\n    // 1.实例化ReentrantLock\n    // ReentrantLock类实现了Lock，以及创建锁的lock()方法，释放锁的unlock()方法。\n    ReentrantLock lock = new ReentrantLock();\n    @Override\n    public void run() {\n        while(true){\n            try{\n                // 2.调用锁定方法lock()\n                lock.lock();\n                if(ticketNum>0){\n                    ticketNum--;\n                }else{\n                    break;\n                }\n            }finally{\n                // 3.调用解锁方法unlock()\n                lock.unlock();\n            }\n        }\n    }\n}\n```\n\n`synchronized`和`ReentrantLock`都是悲观锁的实现，共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源释放给其他线程。\n\n> 悲观锁\n\n总是假设最坏的情况，每次操作数据都会加锁，其他线程阻塞直到获得锁。例如数据库中的行锁，表锁，读锁，写锁，Java中的`synchronized`和`ReentrantLock`独占锁等。适用于写操作比较多的场景，保证数据的一致性。\n\n> 乐观锁\n\n总是假设最好的情况，每次操作数据时都不会加锁，只是在更新数据前判断在此期间该数据有没有被修改过，通常使用**版本号机制**和**CAS算法**实现。适用于读操作比较多的场景，可提高吞吐量。\n\n> 版本号机制\n>\n> 在数据表中添加version版本号字段，用来表示数据被修改的次数，数据被修改时加1，线程在提交更新操作时会将读取的version与数据库中的version对比，相等才更新，否则重试直到更新成功。\n>\n> CAS算法\n>\n> Compare And Swap 比较交换，也叫非阻塞同步，在进行更新操作时会将**读取到的值V**与**当前要修改的值A**进行比较，如果相等就认为在此期间该值没有被其他线程修改过，则会提交更新操作将A修改为**更新值B**，否则一直自旋，直到成功。\n\n缺点：\n\n- ABA问题，当前值由A改到其他值，然后又改回A，CAS算法就会判断该值没有被修改过。`AtomicStampedReference`类通过**控制变量的版本**来保证 CAS 的正确性。\n- 自旋CAS，长时间不成功会带来cpu开销加大。\n\n在Jdk 1.6之后，对Synchronized进行了优化，主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁 和 轻量级锁 以及其它各种优化。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是自旋后阻塞，提高了吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。\n\n## 避免死锁\n\n1、注意加锁顺序，保证每一个线程按同样的顺序进行加锁；\n\n2、设置超时时间；\n\n3、死锁检查，预防死锁的发生。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["JavaSE"],"categories":["JavaSE"]},{"title":"员工管理系统","url":"/2020/08/11/project-01/","content":"\n# 需求分析\n\n模块，功能，技术选型：<!--more-->\n\n- 用户模块：\n\n    - 1、用户登录\n   - 2、用户注册\n   - 3、验证码实现\n   - 4、欢迎xx用户登录\n   - 5、安全退出\n\n- 员工管理模块：\n\t - 6、员工信息展示\n\t - 7、员工的添加\n\t - 8、员工的删除\n\t - 9、员工的修改\n\t - 10、员工列表加入Redis缓存实现\n\n- 技术选型\n\t- 前端：vue+axios\n\t- 后端：springboot + mybatis + mysql + redis\n\n\n\n# 库表设计\n\n1、系统需要哪些表\n\n用户表\n\n员工表\n\n2、分析表与表之间的关系\n\n用户表管理员工表，没有什么关系，涉及到的都是单表操作\n\n3、分析表中的字段\n\n用户表字段\nid、username、realname、password、gender、status、registerTime\n\n员工表\n\nid、name、photoPath、salary、age\n\n创建emp数据库，创建表\n\n```sql\ncreate table t_user(\n\tid int(6) primary key auto_increment,\n\tusername varchar(50),\n\trealname varchar(50),\n    password varchar(50),\n    gender varchar(4),\n    status varchar(4),\n    regist_time timestamp\n);\n\ncreate table t_emp(\n\tid int(6) primary key auto_increment,\n    name varchar(50),\n    photo_path varchar(100),\n    salary double(10,2),\n    age int(3)\n)\n```\n\n# 详细设计\n\n流程图，伪代码（小项目省略）\n\n# 编码环节\n\n## 环境准备\n\nspringboot+mybatis+mysql、引入员工系统页面\n\n项目名：emps\n\n项目结构：\n\n```\n-src/main/java\n--------------com.zyz.\n---------------------bean\n---------------------dao\n---------------------service\n---------------------controller\n---------------------utils\n---------------------cache\n-src/main/resource\n------------------application.yml \n------------------com.zyz.mapper/   mapper配置文件\n------------------com.zyz.sql/      数据库文件\n------------------static/          静态资源\n```\n\n## 正式进入编码\n\n### 一、用户模块\n\n#### 1、创建springboot项目，勾选相应的依赖\n\n![](project-01/1.png)\n\n搭建项目基本结构：\n![](project-01/2.png)\n\n引入其他依赖\n\n```xml\n <dependency>\n     <groupId>com.alibaba</groupId>\n     <artifactId>druid</artifactId>\n     <version>1.1.23</version>\n</dependency>\n<dependency>\n    <groupId>commons-fileupload</groupId>\n    <artifactId>commons-fileupload</artifactId>\n    <version>1.4</version>\n</dependency>\n```\n\n#### 2、编写springboot配置文件\n\n```yml\n# 指定工程访问路径\nserver:\n  servlet:\n    context-path: /empAdmin\n\nspring:\n  datasource:\n    username: root\n    password: 2824199842\n    url: jdbc:mysql://127.0.0.1:3306/emp?serverTimezone=Asia/Shanghai\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n\nmybatis:\n  type-aliases-package: com.zyz.bean\n  mapper-locations: classpath:com/zyz/mapper/*.xml # 要在接口中添加@Mapper注解\n  configuration:\n    map-underscore-to-camel-case: true\n\nlogging:\n  level:\n    com:\n      zyz:\n        dao: debug\n        service: info\n        controller: info\n```\n\n#### 3、实现验证码展示功能\n\n> 验证码工具类\n\n```java\npackage com.zyz.utils;\n\npublic class VerifyCodeUtils{\n    //使用到Algerian字体，系统里没有的话需要安装字体，字体只显示大写，去掉了1,0,i,o几个容易混淆的字符\n    public static final String VERIFY_CODES = \"23456789ABCDEFGHJKLMNPQRSTUVWXYZ\";\n    private static Random random = new Random();\n\n    /**\n     * 使用系统默认字符源生成验证码\n     * @param verifySize    验证码长度\n     * @return\n     */\n    public static String generateVerifyCode(int verifySize){\n        return generateVerifyCode(verifySize, VERIFY_CODES);\n    }\n    /**\n     * 使用指定源生成验证码\n     * @param verifySize    验证码长度\n     * @param sources   验证码字符源\n     * @return\n     */\n    public static String generateVerifyCode(int verifySize, String sources){\n        if(sources == null || sources.length() == 0){\n            sources = VERIFY_CODES;\n        }\n        int codesLen = sources.length();\n        Random rand = new Random(System.currentTimeMillis());\n        StringBuilder verifyCode = new StringBuilder(verifySize);\n        for(int i = 0; i < verifySize; i++){\n            verifyCode.append(sources.charAt(rand.nextInt(codesLen-1)));\n        }\n        return verifyCode.toString();\n    }\n\n    /**\n     * 生成随机验证码文件,并返回验证码值\n     * @param w\n     * @param h\n     * @param outputFile\n     * @param verifySize\n     * @return\n     * @throws IOException\n     */\n    public static String outputVerifyImage(int w, int h, File outputFile, int verifySize) throws IOException{\n        String verifyCode = generateVerifyCode(verifySize);\n        outputImage(w, h, outputFile, verifyCode);\n        return verifyCode;\n    }\n\n    /**\n     * 输出随机验证码图片流,并返回验证码值\n     * @param w\n     * @param h\n     * @param os\n     * @param verifySize\n     * @return\n     * @throws IOException\n     */\n    public static String outputVerifyImage(int w, int h, OutputStream os, int verifySize) throws IOException{\n        String verifyCode = generateVerifyCode(verifySize);\n        outputImage(w, h, os, verifyCode);\n        return verifyCode;\n    }\n\n    /**\n     * 生成指定验证码图像文件\n     * @param w\n     * @param h\n     * @param outputFile\n     * @param code\n     * @throws IOException\n     */\n    public static void outputImage(int w, int h, File outputFile, String code) throws IOException{\n        if(outputFile == null){\n            return;\n        }\n        File dir = outputFile.getParentFile();\n        if(!dir.exists()){\n            dir.mkdirs();\n        }\n        try{\n            outputFile.createNewFile();\n            FileOutputStream fos = new FileOutputStream(outputFile);\n            outputImage(w, h, fos, code);\n            fos.close();\n        } catch(IOException e){\n            throw e;\n        }\n    }\n\n    /**\n     * 输出指定验证码图片流\n     * @param w\n     * @param h\n     * @param os\n     * @param code\n     * @throws IOException\n     */\n    public static void outputImage(int w, int h, OutputStream os, String code) throws IOException{\n        int verifySize = code.length();\n        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n        Random rand = new Random();\n        Graphics2D g2 = image.createGraphics();\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n        Color[] colors = new Color[5];\n        Color[] colorSpaces = new Color[] { Color.WHITE, Color.CYAN,\n                Color.GRAY, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,\n                Color.PINK, Color.YELLOW };\n        float[] fractions = new float[colors.length];\n        for(int i = 0; i < colors.length; i++){\n            colors[i] = colorSpaces[rand.nextInt(colorSpaces.length)];\n            fractions[i] = rand.nextFloat();\n        }\n        Arrays.sort(fractions);\n\n        g2.setColor(Color.GRAY);// 设置边框色\n        g2.fillRect(0, 0, w, h);\n\n        Color c = getRandColor(200, 250);\n        g2.setColor(c);// 设置背景色\n        g2.fillRect(0, 2, w, h-4);\n\n        //绘制干扰线\n        Random random = new Random();\n        g2.setColor(getRandColor(160, 200));// 设置线条的颜色\n        for (int i = 0; i < 20; i++) {\n            int x = random.nextInt(w - 1);\n            int y = random.nextInt(h - 1);\n            int xl = random.nextInt(6) + 1;\n            int yl = random.nextInt(12) + 1;\n            g2.drawLine(x, y, x + xl + 40, y + yl + 20);\n        }\n\n        // 添加噪点\n        float yawpRate = 0.05f;// 噪声率\n        int area = (int) (yawpRate * w * h);\n        for (int i = 0; i < area; i++) {\n            int x = random.nextInt(w);\n            int y = random.nextInt(h);\n            int rgb = getRandomIntColor();\n            image.setRGB(x, y, rgb);\n        }\n\n        shear(g2, w, h, c);// 使图片扭曲\n\n        g2.setColor(getRandColor(100, 160));\n        int fontSize = h-4;\n        Font font = new Font(\"Algerian\", Font.ITALIC, fontSize);\n        g2.setFont(font);\n        char[] chars = code.toCharArray();\n        for(int i = 0; i < verifySize; i++){\n            AffineTransform affine = new AffineTransform();\n            affine.setToRotation(Math.PI / 4 * rand.nextDouble() * (rand.nextBoolean() ? 1 : -1), (w / verifySize) * i + fontSize/2, h/2);\n            g2.setTransform(affine);\n            g2.drawChars(chars, i, 1, ((w-10) / verifySize) * i + 5, h/2 + fontSize/2 - 10);\n        }\n\n        g2.dispose();\n        ImageIO.write(image, \"jpg\", os);\n    }\n\n    private static Color getRandColor(int fc, int bc) {\n        if (fc > 255)\n            fc = 255;\n        if (bc > 255)\n            bc = 255;\n        int r = fc + random.nextInt(bc - fc);\n        int g = fc + random.nextInt(bc - fc);\n        int b = fc + random.nextInt(bc - fc);\n        return new Color(r, g, b);\n    }\n\n    private static int getRandomIntColor() {\n        int[] rgb = getRandomRgb();\n        int color = 0;\n        for (int c : rgb) {\n            color = color << 8;\n            color = color | c;\n        }\n        return color;\n    }\n\n    private static int[] getRandomRgb() {\n        int[] rgb = new int[3];\n        for (int i = 0; i < 3; i++) {\n            rgb[i] = random.nextInt(255);\n        }\n        return rgb;\n    }\n\n    private static void shear(Graphics g, int w1, int h1, Color color) {\n        shearX(g, w1, h1, color);\n        shearY(g, w1, h1, color);\n    }\n\n    private static void shearX(Graphics g, int w1, int h1, Color color) {\n\n        int period = random.nextInt(2);\n\n        boolean borderGap = true;\n        int frames = 1;\n        int phase = random.nextInt(2);\n\n        for (int i = 0; i < h1; i++) {\n            double d = (double) (period >> 1)\n                    * Math.sin((double) i / (double) period\n                    + (6.2831853071795862D * (double) phase)\n                    / (double) frames);\n            g.copyArea(0, i, w1, 1, (int) d, 0);\n            if (borderGap) {\n                g.setColor(color);\n                g.drawLine((int) d, i, 0, i);\n                g.drawLine((int) d + w1, i, w1, i);\n            }\n        }\n\n    }\n\n    private static void shearY(Graphics g, int w1, int h1, Color color) {\n        int period = random.nextInt(40) + 10; // 50;\n        boolean borderGap = true;\n        int frames = 20;\n        int phase = 7;\n        for (int i = 0; i < w1; i++) {\n            double d = (double) (period >> 1)\n                    * Math.sin((double) i / (double) period\n                    + (6.2831853071795862D * (double) phase)\n                    / (double) frames);\n            g.copyArea(i, 0, 1, h1, 0, (int) d);\n            if (borderGap) {\n                g.setColor(color);\n                g.drawLine(i, (int) d, i, 0);\n                g.drawLine(i, (int) d + h1, i, h1);\n            }\n\n        }\n\n    }\n}\n```\n\n> 创建UserController类\n\n```java\npackage com.zyz.controller;\n\n@RestController\n@CrossOrigin  // 允许跨域\n@RequestMapping(\"user\")\npublic class UserController {\n    /**\n     * 生成验证码图片\n     * @return\n     */\n    @GetMapping(\"getImageCode\")\n    public String getImageCode(HttpServletRequest request) throws Exception {\n        // 使用工具类生成验证码并输出\n        ByteArrayOutputStream os = new ByteArrayOutputStream();\n        String code = VerifyCodeUtils.generateVerifyCode(4);\n        VerifyCodeUtils.outputImage(100, 30, os, code);\n        // 保存至applicationContext域中\n        request.getServletContext().setAttribute(\"code\", code);\n        // 将图片转换为base64\n        String s = Base64Utils.encodeToString(os.toByteArray());\n        return \"data:image/png;base64,\" + s;\n    }\n}\n```\n\n> 在前端发起异步请求\n\n```html\n<script src=\"js/vue.js\"></script>\n<script src=\"js/axios.min.js\"></script>\n<script>\n    var app = new Vue({\n        el: \"#wrap\",\n        data: {\n            url: \"\",\n            date: \"\",\n        },\n        methods: {\n            // 更换验证码\n            getImg() {\n                this.getSrc()\n            },\n            // 封装获取验证码的请求方法\n            getSrc() {\n                var _this = this;\n                axios.get(\"http://localhost:8080/empAdmin/user/getImageCode?time=\" + Math.random())\n                    .then(res => {\n                        // console.log(res.data);\n                        _this.url = res.data;\n                    });\n            }\n        },\n        created() {  // 页面加载前执行  发起异步请求\n            this.getSrc();\n            // 显示当前日期\n            this.date = new Date().getFullYear() + \"/\" + (new Date().getMonth() + 1) + \"/\" + new Date().getDate();\n        }\n    })\n</script>\n```\n\n```html\n<td>\n    <img id=\"num\" :src=\"url\"/>\n    <a href=\"javascript:;\" @click=\"getImg\">换一张</a>\n</td>\n```\n\n```html\n<p v-text=\"date\"></p>\n```\n\n#### 4、实现注册功能\n\n> 创建User实体类，使用lombok！\n\n```java\npackage com.zyz.bean;\n@Data\npublic class User {\n    private String id;\n    private String username;\n    private String realname;\n    private String password;\n    private String gender;\n    private String status;\n    private Date registerTime;\n}\n```\n\n> 编写dao层\n\n```java\npackage com.zyz.dao;\n\n@Mapper\n@Repository\npublic interface UserDao {\n    // 添加用户\n    void save(User user);\n\n    // 根据用户名查找用户\n    User queryUserByName(String username);\n}\n```\n\n对应的sql映射文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.zyz.dao.UserDao\">\n    <insert id=\"save\" parameterType=\"User\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n        insert into t_user\n        values\n        (#{id},#{username},#{realname},#{password},#{gender},#{status},#{registerTime})\n    </insert>\n\n    <select id=\"queryUserByName\" parameterType=\"String\" resultType=\"User\">\n        select id,username,realname,password,gender,status,register_time\n        from t_user where username=#{username}\n    </select>\n</mapper>\n```\n\n> 编写service层\n\n```java\npackage com.zyz.service;\n\npublic interface UserService {\n    // 用户注册\n    void register(User user);\n}\n```\n\n实现对应的service接口\n\n```java\npackage com.zyz.service.impl;\n\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private UserDao userDao;\n    @Override\n    public void register(User user) {\n        // 判断用户是否存在\n        User user1 = userDao.queryUserByName(user.getUsername());\n        if(user1==null){\n            // 生成用户状态\n            user.setStatus(\"已激活\");\n            // 设置用户注册时间\n            user.setRegisterTime(new Date());\n            // 调用dao\n            userDao.save(user);\n        }else{\n            throw new RuntimeException(\"用户名已存在！\");\n        }\n    }\n}\n```\n\n> 编写controller层，在UserController中添加响应注册请求的方法\n\n```java\n@Autowired\nprivate UserService userService;\n\n@PostMapping(\"register\") // @RequestBody将前端传来的json字符串转换为java对象\npublic Map<String, Object> register(@RequestBody User user, String code, HttpServletRequest request) {\n    Map<String, Object> map = new HashMap<>();\n    try {\n        // 判断验证码\n        if (StringUtils.isEmpty(code)) {\n            throw new RuntimeException(\"验证码为空！\");\n        }\n        String realCode = (String) request.getServletContext().getAttribute(\"code\");\n        if (realCode.equalsIgnoreCase(code)) {\n            if (StringUtils.isEmpty(user.getUsername())) {\n                throw new RuntimeException(\"用户名为空！\");\n            }\n            if (StringUtils.isEmpty(user.getPassword())) {\n                throw new RuntimeException(\"密码为空！\");\n            }\n            // 调用service方法\n            userService.register(user);\n            map.put(\"status\", true);\n            map.put(\"msg\", \"提示：注册成功！\");\n        } else {\n            throw new RuntimeException(\"验证码错误！\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        map.put(\"status\", false);\n        map.put(\"msg\", \"提示：\" + e.getMessage());\n    }\n    return map;\n}\n```\n\n> 编写前端页面\n\n在vue对象的data中添加user对象，用来接收页面的参数\n![](project-01/4.png)\n\n将页面中的表单项与user的每一个属性值绑定，.trim去掉前后空格\n![](project-01/3.png)\n\n给按钮绑定注册事件\n\n```html\n<input @click=\"register\" type=\"button\" class=\"button\" value= \" 注 册 \"/>\n```\n\n发起注册请求\n\n```js\n// 注册\nregister() {\n    axios.post(\"http://localhost:8080/empAdmin/user/register?code=\" + this.code, this.user)\n        .then(res => {\n            // console.log(res.data);\n            if (res.data.status) {\n                // 注册成功，跳转登录页面\n                alert(res.data.msg + \"点击确定跳转至登录页面！\");\n                location.href = \"http://localhost:8080/empAdmin/login.html\";\n            } else {\n                // 注册失败\n                alert(res.data.msg + \"点击确定重新注册！\");\n            }\n        });\n}\n```\n\n#### 5、实现登录功能\n\n> dao层\n\n已经有通过名字查询用户信息的方法```queryUserByName(String username)```，service层直接调用即可\n\n> service层\n\n```java\n@Override\npublic User login(User user) {\n    if(StringUtils.isEmpty(user.getUsername())){\n        throw new RuntimeException(\"用户名为空！\");\n    }\n    if(StringUtils.isEmpty(user.getPassword())){\n        throw new RuntimeException(\"密码为空！\");\n     }\n    // 根据输入的用户名查询用户\n    User user1 = userDao.queryUserByName(user.getUsername());\n    // 判断用户是否存在  使用ObjectUtils!\n    if(!ObjectUtils.isEmpty(user1)){\n        if(user1.getPassword().equals(user.getPassword())){\n            return user1;\n        }else{\n            throw new RuntimeException(\"密码错误！\");\n        }\n    }else{\n        throw new RuntimeException(\"用户名不存在或错误！\");\n    }\n}\n```\n\n> controller层\n\n```java\n@PostMapping(\"login\")\npublic Map<String,Object> login(@RequestBody User user){\n    Map<String,Object> map = new HashMap<>();\n    try {\n        userService.login(user);\n        map.put(\"status\",true);\n        map.put(\"msg\",\"提示：登录成功！\");\n    } catch (Exception e) {\n        e.printStackTrace();\n        map.put(\"status\",false);\n        map.put(\"msg\",\"提示：\"+e.getMessage());\n    }\n    return map;\n}\n```\n\n> 前端页面\n\n```html\n<p v-text=\"date\"></p>\n```\n\n```html\n<input type=\"text\" v-model=\"user.username\" />\n```\n\n```html\n<input type=\"password\" v-model=\"user.password\" />\n```\n\n```html\n<script>\n\tvar app = new Vue({\n\t\tel: \"#wrap\",\n\t\tdata: {\n\t\t\tdate: \"\",\n\t\t\tuser: {},\n\t\t},\n\t\tcreated(){\n\t\t\tthis.date = new Date().getFullYear() + \"/\" + (new Date().getMonth() + 1) + \"/\" + new Date().getDate();\n\t\t},\n\t\tmethods:{\n\t\t\tlogin(){\n\t\t\t\t// console.log(this.user);\n\t\t\t\taxios.post(\"http://localhost:8080/empAdmin/user/login\",this.user)\n\t\t\t\t.then(res=>{\n\t\t\t\t\t// console.log(res.data);\n\t\t\t\t\tif(res.data.status){\n\t\t\t\t\t\talert(res.data.msg+\"点击确定跳转员工管理页面！\");\n\t\t\t\t\t\tlocation.href=\"/empAdmin/emplist.html\";\n\t\t\t\t\t}else{\n\t\t\t\t\t\talert(res.data.msg+\"点击确定重新登录！\")\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t})\n</script>\n```\n\n#### 6、实现用户登录信息展示\n\n登录成功后的信息都在后端这边，前端拿不到这些数据。\n\n在前后端未分离的时候，通常都是通过服务端的HttpSession来保存这些信息，服务端在创建了Session的同时，会为该Session生成唯一的sessionId并保存到浏览器中，在随后的请求通过携带sessionId重新获得已经创建的Session；\n\n而在前后端分离的系统中，前端与后端分别部署在不同的服务器上，前后端交互时，前端请求不会带上后端sessionId，session获取不到。因此将信息保存至浏览器中的localStorage中\n\n在controller中保存用户信息：\n![](project-01/5.png)\n\n登录成功后保存用户信息到localStorage:\n\n```js\nlogin(){\n   // console.log(this.user);\n   axios.post(\"http://localhost:8080/empAdmin/user/login\",this.user)\n   .then(res=>{\n      // console.log(res.data);\n      if(res.data.status){\n         alert(res.data.msg+\"点击确定跳转员工管理页面！\");\n         // 将用户信息存放指localStorage中\n         // JSON.stringify()将json对象转换为json字符串\n         localStorage.setItem(\"user\",JSON.stringify(res.data.user));\n         location.href=\"/empAdmin/emplist.html\";\n      }else{\n         alert(res.data.msg+\"点击确定重新登录！\")\n      }\n   })\n}\n```\n\n在员工展示页面显示登录名：\n\n```html\n<script>\n   var app = new Vue({\n      el: \"#wrap\",\n      data:{\n         date: \"\",\n         user:{} // 存放用户登录信息\n      },\n      created(){\n         this.date = new Date().getFullYear() + \"/\" + (new Date().getMonth() + 1) + \"/\" + new Date().getDate();\n         var userString = localStorage.getItem(\"user\");\n         if(userString!=null){// 已登录\n            // 将json字符串转换为json对象\n            this.user = JSON.parse(userString);\n         }else{// 未登录\n            alert(\"请登录！点击确定跳转登录页面\");\n            location.href=\"/empAdmin/login.html\";\n         }\n      },\n   })\n</script>\n```\n\n```html\n<p>用户：<span v-show=\"user!=null\" v-text=\"user.username\" style=\"color: red\"></span>\n```\n\n#### 7、实现退出功能\n\n删除localStorage中的用户数据，跳转至登录页\n\n```js\nmethods:{\n    // 处理安全退出\n          logout(){\n              localStorage.removeItem(\"user\");\n      \t\t  location.href=\"/empAdmin/login.html\";\n          }\n}\n```\n\n### 二、员工模块\n\n#### 1、展示所有员工的信息\n\n> 创建实体类\n\n```java\npackage com.zyz.bean;\n\n@Data\npublic class Emp {\n    private String id;\n    private String name;\n    private String photoPath;\n    private Double salary;\n    private Integer age;\n}\n```\n\n> dao层\n\n```java\npackage com.zyz.dao;\n\n@Mapper\n@Repository\npublic interface EmpDao {\n    // 查询所有员工\n    List<Emp> listAll();\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.zyz.dao.EmpDao\">\n\n    <select id=\"listAll\" resultType=\"Emp\">\n        select id,name,photo_path,salary,age from t_emp\n    </select>\n\n</mapper>\n```\n\n> service层\n\n```java\npackage com.zyz.service;\n\npublic interface EmpService {\n    // 展示所有员工\n    List<Emp> listAll();\n}\n```\n\n```java\npackage com.zyz.service.impl;\n\n@Service\npublic class EmpServiceImpl implements EmpService {\n\n    @Autowired\n    private EmpDao empDao;\n\n    @Override\n    public List<Emp> listAll() {\n        return empDao.listAll();\n    }\n}\n```\n\n> controller层\n\n```java\npackage com.zyz.controller;\n\n@RestController\n@RequestMapping(\"emp\")\npublic class EmpController {\n    @Autowired\n    private EmpService empService;\n\n    @GetMapping(\"listAll\")\n    public List<Emp> listAll(){\n        List<Emp> emps = empService.listAll();\n        return emps;\n    }\n}\n```\n\n> 前端\n\n在data中添加一个数组，用来存放所有员工\n![](project-01/6.png)\n\n```js\n// 查询员工\naxios.get(\"http://localhost:8080/empAdmin/emp/listAll\")\n    .then(res=>{\n    // console.log(res.data);\n    this.emps = res.data;\n    // console.log(this.emps);\n})\n```\n\n```html\n<!--遍历员工列表-->\n<tr v-for=\"(emp,index) in emps\" :key=\"emp.id\" :class=\"index%2==0?'row1':'row2'\">\n   <td v-text=\"emp.id\"></td>\n   <td v-text=\"emp.name\"></td>\n   <td>\n      <img :src=\"emp.photoPath\" style=\"height: 60px;\">\n   </td>\n   <td v-text=\"emp.salary\"></td>\n   <td v-text=\"emp.age\"></td>\n   <td>\n      <a href=\"emplist.html\">删除</a>&nbsp;\n      <a href=\"updateEmp.html\">修改</a>\n   </td>\n</tr>\n```\n\n#### 2、添加员工\n\n> dao层\n\n添加添加员工的方法：\n\n```java\n// 添加员工\nvoid add(Emp emp);\n```\n\n对应的mapper文件\n\n```xml\n<insert id=\"add\" parameterType=\"Emp\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n    insert into t_emp values(#{id},#{name},#{photoPath},#{salary},#{age})\n</insert>\n```\n\n> service层\n\n```java\nvoid add(Emp emp);\n```\n\n```java\n@Override\npublic void add(Emp emp) {\n    if(StringUtils.isEmpty(emp.getName())){\n        throw new RuntimeException(\"请输入用户名！\");\n    }\n    if(StringUtils.isEmpty(emp.getSalary())){\n        throw new RuntimeException(\"请输入薪资！\");\n    }\n    if(StringUtils.isEmpty(emp.getAge())){\n        throw new RuntimeException(\"请输入年龄！\");\n    }\n    empDao.add(emp);\n}\n```\n\n> controller层\n\n```yml\n# 配置上传文件的地址\nupload:\n  dir:\n    D:\\IDEA_workspace\\emps\\src\\main\\resources\\static\\photos\n```\n\n```java\n// 注入上传用户头像的地址 \n@Value(\"${upload.dir}\")\n private String realPath;\n\n@PostMapping(\"addEmp\")\npublic Map<String, Object> addEmp(Emp emp, MultipartFile photo) throws IOException {\n    // System.out.println(\"员工信息：\"+emp);\n    // System.out.println(\"头像：\"+photo);\n    HashMap<String, Object> map = new HashMap<>();\n    try {\n        // 头像保存\n        // 1、修改文件名\n        if (!ObjectUtils.isEmpty(photo)) {\n            String newFileName = UUID.randomUUID().toString() + \".\" +\n                    FilenameUtils.getExtension(photo.getOriginalFilename());\n            // System.out.println(newFileName);\n            // 2、图像上传\n            photo.transferTo(new File(realPath, newFileName));\n            // 3、设置头像访问地址\n            emp.setPhotoPath(newFileName);\n            // 添加员工到数据库中\n            empService.add(emp);\n            map.put(\"status\", true);\n            map.put(\"msg\", \"添加成功！\");\n        } else {\n            throw new RuntimeException(\"请上传头像\");\n        }\n\n    } catch (Exception e) {\n        e.printStackTrace();\n        map.put(\"status\", false);\n        map.put(\"msg\", \"提示：\" + e.getMessage());\n    }\n    return map;\n}\n```\n\n> 前端\n\n绑定表单属性，对文件添加引用\n![](project-01/7.png)\n\n```html\n<script>\n   var app = new Vue({\n      el: \"#wrap\",\n      data:{\n         date: \"\",\n         user:{}, // 存放用户登录信息\n         emp:{    // 存放员工信息\n            name:\"\",\n            age:\"\",\n            salary:\"\",\n            empPhoto:\"\"\n         },\n      },\n      created(){\n         this.date = new Date().getFullYear() + \"/\" + (new Date().getMonth() + 1) + \"/\" + new Date().getDate();\n         var userString = localStorage.getItem(\"user\");\n         if(userString!=null){// 已登录\n            // 将json字符串转换为json对象\n            this.user = JSON.parse(userString);\n         }else{// 未登录\n            alert(\"请登录！点击确定跳转登录页面\");\n            location.href=\"/empAdmin/login.html\";\n         }\n      },\n      methods:{\n         // 处理安全退出\n         logout(){\n            localStorage.removeItem(\"user\");\n            location.href=\"/empAdmin/login.html\";\n         },\n         addEmp(){\n            // console.log(this.emp);\n            // console.log(this.$refs.empPhoto.files[0]);\n            // 文件上传必须是post请求  entype必须为multipart/from-data\n\n            // 构造表单\n            var fromData = new FormData();\n            fromData.append(\"name\",this.emp.name);\n            fromData.append(\"age\",this.emp.age);\n            fromData.append(\"salary\",this.emp.salary);\n            fromData.append(\"photo\",this.$refs.empPhoto.files[0]);\n            axios({\n               method:\"post\",\n               url:\"http://localhost:8080/empAdmin/emp/addEmp\",\n               data:fromData,\n               headers:{'content-type':'multipart/form-data'}\n            }).then(res=>{\n               // console.log(res.data);\n               if(res.data.status){\n                  if(window.confirm(res.data.msg+\"点击跳转员工列表页面\")){\n                     location.href=\"/empAdmin/emplist.html\";\n                  }else{\n                     location.reload();\n                  }\n               }else{\n                  alert(res.data.msg);\n               }\n            })\n         }\n      }\n   })\n</script>\n```\n\n修改显示用户头像的标签路径\n\n```html\n<td>\n   <img :src=\"'/empAdmin/photos/'+emp.photoPath\" style=\"height: 60px;\">\n</td>\n```\n\n#### 3、删除员工\n\n> dao层\n\n```java\n// 删除员工\nvoid delete(String id);\n\n// 根据id查询员工\nEmp queryEmpById(String id);\n```\n\n```xml\n<delete id=\"delete\" parameterType=\"String\" >\n    delete from t_emp where id = #{id}\n</delete>\n\n<select id=\"queryEmpById\" resultType=\"Emp\">\n    select id,name,photo_path,salary,age from t_emp\n    where id = #{id}\n</select>\n```\n\n> service层\n\n```java\n// 删除员工\nvoid delete(String id);\n\n// 根据id查询员工\nEmp queryEmpById(String id);\n```\n\n```java\n@Override\npublic void delete(String id) {\n    empDao.delete(id);\n}\n\n@Override\npublic Emp queryEmpById(String id) {\n    return empDao.queryEmpById(id);\n}\n```\n\n> controller层\n\n```java\n@GetMapping(\"delete\")\npublic Map<String,Object> delete(String id){\n    HashMap<String, Object> map = new HashMap<>();\n    try {\n        // 删除员工头像\n        Emp emp = empService.queryEmpById(id);\n        File file = new File(emp.getPhotoPath());\n        if(file.exists()){\n            file.delete();\n        }\n        empService.delete(id);\n        map.put(\"status\",true);\n        map.put(\"msg\",\"删除成功\");\n    } catch (Exception e) {\n        e.printStackTrace();\n        map.put(\"status\",false);\n        map.put(\"msg\",\"删除失败\");\n    }\n    return map;\n}\n```\n\n> 前端\n\n```js\n// 删除员工\ndeleteEmp(id) {\n    if (window.confirm(\"确认删除吗？\")) {\n        axios.get(\"http://localhost:8080/empAdmin/emp/delete?id=\" + id)\n            .then(res => {\n                if (res.data.status) {\n                    alert(res.data.msg);\n                    location.reload();\n                } else {\n                    alert(res.data.msg);\n                }\n            })\n    }\n}\n```\n\n参数传递：\n\n```html\n <a href=\"javascript:;\" @click=\"deleteEmp(emp.id)\">删除</a>\n```\n\n#### 4、修改员工\n\n> dao\n\n```java\n// 修改员工\nvoid update(Emp emp);\n```\n\n```xml\n<update id=\"update\" parameterType=\"Emp\">\n    update t_emp set\n    name=#{name},photo_path=#{photoPath},salary=#{salary},age=#{age}\n    where id = #{id}\n</update>\n```\n\n> service\n\n```java\n// 修改员工\nvoid update(Emp emp);\n```\n\n```java\n@Override\npublic void update(Emp emp) {\n    if(StringUtils.isEmpty(emp.getName())){\n        throw new RuntimeException(\"请输入用户名！\");\n    }\n    if(StringUtils.isEmpty(emp.getSalary())){\n        throw new RuntimeException(\"请输入薪资！\");\n    }\n    if(StringUtils.isEmpty(emp.getAge())){\n        throw new RuntimeException(\"请输入年龄！\");\n    }\n    empDao.update(emp);\n}\n```\n\n> controller\n\n```java\n@PostMapping(\"update\")\npublic Map<String, Object> update(Emp emp, MultipartFile photo) {\n    HashMap<String, Object> map = new HashMap<>();\n    try {\n        // 头像保存\n        // 1、修改文件名\n        if (!ObjectUtils.isEmpty(photo)) {\n            String newFileName = UUID.randomUUID().toString() + \".\" +\n                    FilenameUtils.getExtension(photo.getOriginalFilename());\n            // 2、图像上传\n            photo.transferTo(new File(realPath, newFileName));\n            // 3、设置头像访问地址\n            emp.setPhotoPath(newFileName);\n        }\n        empService.update(emp);\n        map.put(\"status\", true);\n        map.put(\"msg\", \"修改成功！\");\n    } catch (Exception e) {\n        e.printStackTrace();\n        map.put(\"status\", false);\n        map.put(\"msg\", \"提示：\"+e.getMessage());\n    }\n    return map;\n}\n```\n\n> 前端\n\n从员工列表中选中员工的id传递给修改页面：\n\n```html\n <a href=\"javascript:;\" @click=\"updateEmp(emp.id)\">修改</a>\n```\n\n```js\n// 修改员工\nupdateEmp(id){\n    location.href=\"/empAdmin/updateEmp.html?id=\"+id;\n}\n```\n\n在修改页面创建前(created()方法中)发起获取当前员工信息的请求\n\n```js\n// 获取员工id\nvar start = location.href.lastIndexOf(\"=\");\nvar id = location.href.substring(start+1);\n// console.log(id);\n// 查询当前员工显示在页面上\naxios.get(\"http://localhost:8080/empAdmin/emp/getEmp?id=\"+id)\n.then(res=>{\n    console.log(res.data)\n    this.emp = res.data;\n})\n```\n\n使用v-model将返回的json数据绑定表单中的属性值\n\n旧照片的显示和新照片上传\n![](project-01/8.png)\n\n绑定更新事件\n\n```html\n<input type=\"button\" @click=\"updateEmp\" class=\"button\" value=\"更 新\"/>\n```\n\n```js\n// 更新员工信息\nupdateEmp() {\n    var formData = new FormData();\n    formData.append(\"id\",this.emp.id);\n    formData.append(\"name\",this.emp.name);\n    formData.append(\"photoPath\",this.emp.photoPath)\n    formData.append(\"photo\",this.$refs.empPhoto.files[0]);\n    formData.append(\"salary\",this.emp.salary);\n    formData.append(\"age\",this.emp.age);\n    console.log(formData);\n    axios({\n        method: \"post\",\n        url:\"http://localhost:8080/empAdmin/emp/update\",\n        data: formData,\n        headers:{'content-type':'multipart/form-data'}\n    }).then(res=>{\n        if(res.data.status){\n            if(window.confirm(res.data.msg)){\n                location.href=\"/empAdmin/emplist.html\";\n            }\n        }else{\n            alert(res.data.msg);\n        }\n    })\n}\n```\n\n### 三、整合Redis缓存\n\n1、导入依赖：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n2、配置Redis访问ip和端口\n\n```yml\nspring:\n  datasource:\n    username: root\n    password: 2824199842\n    url: jdbc:mysql://127.0.0.1:3306/emp?serverTimezone=Asia/Shanghai\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n  redis:\n    host: 127.0.0.1\n    port: 6379\n```\n\n3、创建RedisCache类实现mybatis中的Cache接口，对操纵mybatis缓存\n\n```java\npackage com.zyz.cache;\n\n// 使用redis操纵mybatis缓存\npublic class RedisCache implements Cache {\n    // 对应mapper文件中的namespace\n    private String id;\n\n    public RedisCache(String id) {\n        this.id = id;\n    }\n\n    // 封装获取redisTemplate的方法\n    public RedisTemplate getRedisTemplate(){\n        RedisTemplate redisTemplate =(RedisTemplate) ApplicationContextUtils.getBean(\"redisTemplate\");\n        return redisTemplate;\n    }\n\n    @Override\n    public String getId() {\n        System.out.println(\"当前缓存的id：\"+id);\n        return this.id;\n    }\n\n    // 放入redis缓存\n    @Override\n    public void putObject(Object key, Object value) {\n        System.out.println(\"放入缓存的key-value\"+key+\"-\"+value);\n        // 获取redisTemplate\n        getRedisTemplate().opsForHash().put(id,key.toString(),value);\n    }\n\n    // 从redis缓存中获取\n    @Override\n    public Object getObject(Object key) {\n        System.out.println(\"获取缓存的key-value\"+key+\"-\"+getRedisTemplate().opsForHash().get(id,key.toString()));\n        return getRedisTemplate().opsForHash().get(id,key.toString());\n    }\n\n    // 删除指定缓存信息\n    @Override\n    public Object removeObject(Object o) {\n        return null;\n    }\n\n    // 清除缓存信息\n    @Override\n    public void clear() {\n        System.out.println(\"清除缓存\");\n        getRedisTemplate().delete(id);\n    }\n\n    // 缓存大小\n    @Override\n    public int getSize() {\n        return getRedisTemplate().opsForValue().size(id).intValue();\n    }\n}\n```\n\n4、创建工具类applicationContextUtils实现ApplicationContextAware获取工厂实例，并从中获取需要的实现类\n\n```java\npackage com.zyz.utils;\n\n@Component\npublic class ApplicationContextUtils implements ApplicationContextAware {\n    \n    private static ApplicationContext applicationContext;\n    // 获取当前工厂\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n\n    // 获取工厂中的实现类\n    public static Object getBean(String name){\n        return applicationContext.getBean(name);\n    }\n}\n```\n\n存储在缓存中的实体类必须实现Serializable接口\n![](project-01/9.png)\n\n5、在mapper文件中设置自定义的Redis缓存\n\n```xml\n<!-- 使用自定义的Redis缓存 -->\n<cache type=\"com.zyz.cache.RedisCache\"></cache>\n```\n\n![](project-01/10.png)\n\n![](project-01/11.png)\n\n# 主要界面\n\n<img src=\"project-01/13.png\" style=\"zoom:80%;\" />![](project-01/14.png)\n\n<img src=\"project-01/12.png\" style=\"zoom:80%;\" />\n\n<img src=\"project-01/16.png\" style=\"zoom:80%;\" />\n\n<img src=\"project-01/15.png\" style=\"zoom:80%;\" />\n\n# 项目总结\n\n做了什么？\n\n- 实现了管理员的注册和登录\n- 员工的增删改查功能\n\n学到了什么？\n\n- 使用了Redis作为Mybatis的缓存，以前只是对Mybatis的缓存机制停留在了解阶段，这次使用上了之前学习的Redis数据库\n- 使用了vue对页面进行渲染，axios发起异步请求，熟悉了前后端分离系统的数据交互模式\n- 使用base64格式在浏览器端显示图片，需要在base64格式的图片前面加上```data:image/png;base64,```前缀\n- 学习到了使用ObjectUtils，StringUtils对一些属性进行非空判断\n- 使用 Exception+ResponseBody，讲异常返回给前端，给用户友好的提示\n- 使用localStorage保存用户登录信息\n- 在vue中构造表单，填充数据和文件，后端使用MultipartFile类接收前端的文件，并上传值到指定目录\n\n遇到的问题，怎么解决的？\n\n- 上传用户照片的问题，在指定的上传目录发现了文件的存在，可是却在浏览器中显示不出来，通过查看数据库中员工表的信息，发现其他属性都存在，只有照片为空，通过在controller的添加方法打上断点，调试发现图片并没有保存到员工对象中，通过添加相应的set方法，最后解决了问题。\n- 在项目中我使用了date来显示当前的日期，而对前后端的交互中要频繁使用到data变量，在一次测试过程中就一不小心写错了，检查了很长时间才发现，真的差之一毫，谬之千里啊！\n\n# 优化\n\n## 添加日志输出功能\n```java\nprivate static final Logger LOGGER = LoggerFactory.getLogger(UserController.class);\n```\n在方法中打印日志：\n```java\nLOGGER.info(\"用户登录，参数：{}\", JSON.toJSON(user));\n```\n使用自定义注解并实现日志切面的方式打印日志：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)// 运行时获取注解值\npublic @interface Log {\n\n    String value() default \"\";\n}\n```\n\nLogAspect.java\n\n```java\n@Component\n@Aspect\npublic class LogAspect {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(LogAspect.class);\n\n    @Pointcut(\"execution(public * com.zyz.controller..*.*(..))\")\n    public void logPointcut() {\n    }\n\n    @Before(\"logPointcut()\")\n    public void logAround(JoinPoint joinPoint) {\n        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();\n        Method method = methodSignature.getMethod();\n        Log log = method.getAnnotation(Log.class);\n        if(null != log){\n            LOGGER.info(log.value());\n        }\n    }\n}\n```\n\n## 自定义缓存注解并实现缓存切面\n支持单独设置缓存的过期时间\n1、自定义RedisTemplate，指定序列化方式，防止出现乱码\n\n```java\n@Configuration\npublic class RedisConfig {\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(factory); // Json序列化\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n        // String序列化\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n        // key采用String序列化方式\n        template.setKeySerializer(stringRedisSerializer);\n        template.setHashKeySerializer(stringRedisSerializer);\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n```\n\n2、自定义缓存注解\n\n```java\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)// 运行时获取注解值\npublic @interface Cache {\n    // key\n    String key();\n\n    // 有效时间 默认30分钟 单位 s\n    long expire() default 30*60 ;\n\n}\n```\n\n3、实现缓存切面CacheAspect.java\n\n```java\n@Aspect\n@Component\npublic class CacheAspect {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    @Pointcut(value = \"@annotation(com.zyz.aop.cache.Cache)\")\n    public void cachePointcut() {\n\n    }\n\n    @Around(value = \"cachePointcut() && @annotation(cache)\")\n    public Object cacheAround(ProceedingJoinPoint point, Cache cache) {\n        // 根据参数生成key\n        final String key = parseKey(cache.key());\n        Object value = null;\n        try {\n            // 从redis中获取缓存\n            value = redisTemplate.opsForValue().get(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        if (null != value) {\n            MethodSignature methodSignature = (MethodSignature) point.getSignature();\n            Method method = methodSignature.getMethod();\n            return value;\n        }\n        try {\n            //等待返回结果\n            Object proceed = point.proceed();\n            if (proceed != null) {\n                try {\n                    //设置缓存\n                    redisTemplate.opsForValue().set(key, proceed, cache.expire(), TimeUnit.SECONDS);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            return proceed;\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * redis的键值生成策略\n     *\n     * @param key  key前缀\n     */\n    private String parseKey(String key) {\n        // 使用uuid拼接保证key唯一\n        StringBuilder sb = new StringBuilder(key + \":\"+ UuidUtils.getUuid());\n        return sb.toString();\n    }\n}\n```\n\n```java\npublic class UuidUtils {\n\n    public static synchronized String getUuid(){\n        return UUID.randomUUID().toString().replace(\"-\",\"\");\n    }\n}\n```\n\n4、使用自定义注解：\n\n```java\n@Cache(key=\"user:login\",expire = 15*60)\npublic User login(User user) {}\n```\n生成的key-value：\n\n![](project-01/17.png)\n\n","tags":["Vue","SpringBoot"],"categories":["小项目"]},{"title":"Java集合总结","url":"/2020/08/11/collection/","content":"\n## 集合的作用\n\n简单来说，集合就是存储对象的容器，方便我们操作多个Java对象。<!--more-->\n\n## 集合分类\n\n集合接口以及常用实现类\n![](collection/1.png)\n\n使用场景：\n\n- 如果是集合类型，可选择List或Set。List是插入有序，可重复的，值可以为null；Set 是不可重复的，值不能为null。\n- 如果是key-value类型，则选择Map。保持插入顺序选择LinkedHashMap;排序选择TreeMap。\n\n## Collection\n\n### 1、Collection介绍\n\n集合与数组的区别：\n\n- 数组长度固定，集合长度可变\n- 数组可以存储基本数据类型和引用数据类型；集合只能存储引用数据类型，存储基本数据类型时会自动装箱，转换为对应的包装类。\n\n![](collection/2.png)\n\n基本方法：\n\n```java\n1、添加功能：\n\tboolean add(Object obj)：添加一个元素\n    boolean addAll(Collection c)：添加一个集合的所有元素\n2、删除功能：\n    void clear()：移除所有元素\n    boolean remove(Object obj)：移除一个元素\n    boolean removeAll(Collecion c)：移除当前集合的所有元素，只要一个元素被移除就返回true\n3、判断功能：\n    boolean contains(Object obj)：判断当前集合是否包含当前元素\n    boolean containsAll(Collection c)：判断当前集合包含指定集合\n    boolean isEmpty()：判断集合是否为空\n4、获取功能：\n    Iterator<E> iterator()：获取迭代器\n5、长度功能：\n    int size()：获取元素个数\n6、交集功能：\n    boolean retainAll(Collection c)：移除当前集合中集合c没有的元素，最终结果保存至当前集合中\n```\n\n### 2、迭代器（Iterator）\n\njava.utils.Collection继承了java.lang.Iterable接口，Collection继承了Iterable的Iterator()方法，返回Iterator对象。\n\njava.utils.Iterator也是一个接口，只有三个方法\n\n- hasNext()\n- next()\n- remove()\n\n这三个方法通过Collection的实现类以内部类的方式实现，因为Collection的实现类存储结构不同，遍历方式也必然不同，必须通过各个实现类以内部类的方式实现，来完成对不同实现类的遍历。\n\n```java\n@Test\npublic void test3() {\n    // 1、创建集合对象\n    Collection coll1 = new ArrayList();\n    // 2、添加数据到集合中\n    coll1.add(1);\n    coll1.add(2);\n    coll1.add(3);\n    // 3、使用集合对象获取迭代器对象\n    Iterator iterator = coll1.iterator();\n    // 起始指针位于第一个元素之前\n    // hasNext() 判断是否还有下一个元素\n    // next() 指针下移，将下移以后的集合位置上的元素返回\n    // 4、遍历集合\n    while(iterator.hasNext()){// 5、判断是否存在元素\n        Object obj = iterator.next();// 6、下移到下一个元素的位置\n        if(obj.equals(new Integer(1))){\n            iterator.remove();// 移除当前元素\n        }\n    }\n    iterator = coll1.iterator();\n    while(iterator.hasNext()){\n        System.out.println(iterator.next());\n    }\n}\n```\n\n### 3、List集合\n\nLIst集合特点：有序（存取顺序与取出顺序一致），可重复。\n\nList集合常用实现类\n\n- ArrayList：底层数据结构是数组，线程不安全\n- LinkedList：底层结构是链表，线程不安全\n- Vector：底层数据结构是数组，线程安全\n\n#### ArrayList\n\n底层其实就是一个数组，但是可以进行扩容，实现动态增长。支持快速随机访问。插入和删除元素时，时间复杂度受元素位置影响。\n直接添加元素或删除尾部元素时，时间复杂度为`O(1)`；指定位置添加或删除时间复杂度为`O(n-i)`，因为其他元素需要整体的后移或前移。\n\n构造方法：\n指定了容量则按照该容量初始化，未指定则返回一个空数组\n\nadd(E   e)方法：\n步骤：检查是否需要扩容--->插入元素\n\nadd(int index,E e)\n步骤：检查角标--->检查是否需要扩容--->插入元素\n\nget(int index)：检查角标--->返回元素\n\nset(int index,E e)：检查角标--->替代元素--->返回旧值\n\nremove(int index)：检查角标--->删除元素--->计算出需要移动的个数，并移动--->设置为null，让gc回收\n\n在**增删时候，需要数组的拷贝复制(navite 方法由C/C++实现)**\n\n#### LinkedList\n\nLinkedList底层是双向链表 。删除时时间复杂度为`O(1)`，指定位置添加或删除时时间复杂度为`O(n)`，因为需要先移动到指定位置然后再删除或添加。\n\n#### Vector\n\nVector底层也是数组，与ArrayList最大的区别就是：**同步(线程安全)**\n\n所有方法都是同步的，**有性能损失**。\n\n### 4、Set集合\n\nSet集合特点：元素不可重复\n\nSet集合常用实现类\n\n- HashSet：底层数据结构是哈希表。\n- TreeSet：底层数据结构是红黑数（平衡二叉树）；保证元素有序。\n- LinkedHashSet：底层数据结构由哈希表和链表组成。\n\n#### HashSet\n\n- 实现Set接口\n- 不保证迭代顺序\n- 允许元素为null\n- **底层实际上是一个HashMap实例**\n- 非同步\n- 初始容量非常影响迭代性能\n\n#### TreeSet\n\n- 可以实现排序功能\n- **底层实际上是一个TreeMap实例**\n- 非同步\n\n#### LinkedHashSet\n\n- 迭代是有序的\n- 允许为null\n- **底层实际上是一个HashMap+双向链表实例(其实就是LinkedHashMap)**\n- 非同步\n- 性能比HashSet差一丢丢，因为要维护一个双向链表\n- 初始容量与迭代无关，LinkedHashSet迭代的是双向链表\n\n## Map\n\n### 1、Map介绍\n\n特点：将键映射到值的对象，一个映射不能有重复的键，每个键最多映射一个值。\n\nMap与Collection的区别\n\n- Map集合存储的元素是成对出现的，键唯一，值可以重复\n- Collection集合存储的元素是单独出现的，子类List存储的值可重复，Set不可重复\n\n![](collection/3.png)\n\n基本方法：\n\n```java\n1、添加功能：\n    put(K key,V value)  添加元素，key存在则替换\n2、删除功能：\n    void clear()  移除所有键值对\n    remove(Object key)  根据键删除值，并把值返回\n3、判断功能：\n    boolean containsKey(Object key)  判断集合是否包含指定的键\n    boolean containsValue(Object value)  判断集合是否包含指定的值\n    boolean isEmpty()  判断集合是否为空\n4、获取功能：\n    Set<Map.Entry<K key,V value>> entrySet()  返回键值对对象的集合\n    get(Object key)  根据键获取值\n    Set<K> keySet()  获取集合中所有的键的集合\n    Collection<V> values()  获取集合中所有值的集合\n5、长度功能：\n    int size()  返回集合中键值对的对数\n6、遍历功能：\n    void forEach(Object key, Object value)\n```\n\n#### HashMap\n\n- 无序，允许为null，非同步\n- 底层有散列表（数组+链表）实现\n\n**put(K key,V value)方法**：map.put(key1,value1)\n\n首先调用key1所在类的hashCode()计算key的哈希值，此哈希值与数组长度-1做&位运算，得到在Entry数组中的存放位置；\n如果此位置为空，则直接添加，否则将key1的哈希值与此位置上元素的哈希值比较；\n如果哈希值不同，则直接添加，否则调用key1所在类的equals()方法，如果返回true，直接覆盖，否则添加到链表尾部。\n\n当元素个数达到容量的0.75倍时，就会扩容，容量扩大为原来的2倍，原有的数据全部被复制过来。\n\njdk1.7是以链表的形式添加元素，jdk1.8之后，链表长度大于8，数组长度大于64的时候，链表会转换为红黑树。\n\n**get(Object key)**：计算key的哈希值，通过getNode(int hash,Object key)获取对应的value\n\n**remove(Object key)**：计算key的哈希值，通过removeNode(int hash,Object key,Object value) 删除该键值对，并返回值\n\n**HashMap与HashTable的区别：**\n\n从存储结构和实现来讲基本上都是相同的。HashTable是线程安全的，另外它不允许key和value为null。Hashtable是个过时的集合类，不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用`ConcurrentHashMap`替换。\n\n在JDK8中HashMap的底层是：**数组+链表(散列表)+红黑树**\n\n#### ConcurrentHashMap\n\njdk1.7 采用分段锁的方式解决线程安全\n\njdk1.8 采用`synchronized`+`CAS`实现线程安全\n\n#### LinkedHashMap\n\n- 底层是散列表和双向链表\n- 允许为null，不同步\n- 插入的顺序是有序的(底层链表致使有序)\n\n#### TreeMap\n\n- 实现了NavigableMap接口，而NavigableMap接口继承着SortedMap接口，所以是有序的\n- 底层是红黑树\n- key不能为null，为null为抛出NullPointerException\n- 不同步\n- 使用Comparator或者Comparable来比较key是否相等与排序的问题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["JavaSE"],"categories":["JavaSE"]},{"title":"Redis持久化","url":"/2020/08/10/redis-06/","content":"\nRedis是内存数据库，如果不能将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能。<!--more-->\n\n## RDB\n\n在指定时间间隔内将内存中的数据集快照写入磁盘dump.rdb文件，恢复时将快照直接读到内存。\n\nRedis会单独创建一个子进程来进行持久化，会将数据写入到一个临时文件中，等持久化过程结束了，再将这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行IO操作的，保证了极高的性能。\n\n如果需要进行大规模数据的恢复，且对数据的完整性不是特别敏感，那么RDB将比AOF的效率更高。默认为RDB方式。\n\n## AOF\n\n将所有命令都记录下来，恢复时将命令全部执行一遍。\n\n以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据库。\n\n默认不开启AOF操作\n![](redis-06/3.png)\n\n","tags":["Redis"],"categories":["中间件"]},{"title":"Jedis,Springboot集成Redis","url":"/2020/08/08/redis-05/","content":"\nJedis是Redis官方推荐的Java连接开发工具。是使用Java来操作Redis的中间件。\n\n## 环境搭建\n\n1、创建一个maven项目\n\n2、导入依赖\n\n```xml\n<dependencies>\n        <!-- https://mvnrepository.com/artifact/redis.clients/jedis -->\n        <dependency>\n            <groupId>redis.clients</groupId>\n            <artifactId>jedis</artifactId>\n            <version>3.2.0</version>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.56</version>\n        </dependency>\n</dependencies>\n```\n\n## 编码测试\n\n```java\npublic class JedisTest {\n    public static void main(String[] args) {\n        // 1、创建Jedis对象\n        Jedis jedis = new Jedis(\"127.0.0.1\",6379);\n        System.out.println(jedis.ping());// 连接成功输出 PONG\n\t\t// 所有的api与之前的学习的命令一致\n    }\n}\n```\n\n## 测试事务\n\n```java\npublic class TxTest {\n    public static void main(String[] args) {\n        Jedis jedis = new Jedis(\"127.0.0.1\", 6379);\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(\"name\",\"zyz\");\n        jsonObject.put(\"age\",21);\n        // 开启事务\n        Transaction multi = jedis.multi();\n        String result = jsonObject.toJSONString();\n        try {\n            multi.set(\"user1\",result);\n            // 执行事务\n            multi.exec();\n        } catch (Exception e) {\n            multi.discard();// 放弃事务\n            e.printStackTrace();\n        } finally{\n            System.out.println(jedis.get(\"user1\"));// {\"name\":\"zyz\",\"age\":21}\n        }\n        jedis.close();\n    }\n}\n```\n\n## Springboot整合\n\n1、创建springboot项目，并勾选如下依赖\n![](redis-05/1.png)\n\n> 在springboot2.x之后，原来使用的jedis被替换成了lettuce。\n> jedis：采用直连，多个线程操作不安全。\n> lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况。\n\n2、配置连接属性\n\n```yml\n# springboot所有的配置类都有一个自动配置类  RedisAutoConfiguration\n# 自动配置类都会绑定一个配置文件 RedisProperties  prefix = \"spring.redis\"\nspring:\n  redis:\n    host: 127.0.0.1\n    port: 6379\n```\n\n3、测试连接\n\n```java\n@SpringBootTest\nclass Redis02SpringbootApplicationTests {\n\n   @Autowired\n   RedisTemplate redisTemplate;\n   @Test\n   void contextLoads() {\n      redisTemplate.opsForValue().set(\"name\",\"zyz\");\n      System.out.println(redisTemplate.opsForValue().get(\"name\"));// zyz\n\n   }\n}\n```\n\n## 自定义RedisTemplate\n\n使用统一使用jackson序列化，防止乱码问题\n\n```java\n// 自定义Template\n@Configuration\npublic class RedisConfig {\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(factory);\n        // Json序列化\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n        // String序列化\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n        // key采用String序列化方式\n        template.setKeySerializer(stringRedisSerializer);\n        template.setHashKeySerializer(stringRedisSerializer);\n        // value采用Json序列化\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n```\n\n测试，User实体类需要实现Serializable接口\n\n```java\n@Test\n   public void test() throws Exception {\n       User user = new User(\"zyz\",18);\n       // 序列化\n       String jsonUser = new ObjectMapper().writeValueAsString(user);\n       redisTemplate.opsForValue().set(\"user\",jsonUser);\n       System.out.println(redisTemplate.opsForValue().get(\"user\"));\n   }\n```\n\n控制台获取：\n![](redis-05/2.png)\n\n## 封装工具类\n\n```java\n@Component\npublic final class RedisUtils {\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n    // =============================common============================\n    /**\n     * 指定缓存失效时间\n     *\n     * @param key  键\n     * @param time 时间(秒)\n     */\n    public boolean expire(String key, long time) {\n        try {\n            if (time > 0) {\n                redisTemplate.expire(key, time, TimeUnit.SECONDS);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 根据key 获取过期时间\n     *\n     * @param key 键 不能为null\n     * @return 时间(秒) 返回0代表为永久有效\n     */\n    public long getExpire(String key) {\n        return redisTemplate.getExpire(key, TimeUnit.SECONDS);\n    }\n\n    /**\n     * 判断key是否存在\n     *\n     * @param key 键\n     * @return true 存在 false不存在\n     */\n    public boolean hasKey(String key) {\n        try {\n            return redisTemplate.hasKey(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n\n    /**\n     * 删除缓存\n     *\n     * @param key 可以传一个值 或多个\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void del(String... key) {\n        if (key != null && key.length > 0) {\n            if (key.length == 1) {\n                redisTemplate.delete(key[0]);\n            } else {\n                redisTemplate.delete(CollectionUtils.arrayToList(key));\n            }\n        }\n    }\n\n    // ============================String=============================\n    /**\n     * 普通缓存获取\n     *\n     * @param key 键\n     * @return 值\n     */\n    public Object get(String key) {\n        return key == null ? null : redisTemplate.opsForValue().get(key);\n    }\n\n    /**\n     * 普通缓存放入\n     *\n     * @param key   键\n     * @param value 值\n     * @return true成功 false失败\n     */\n\n    public boolean set(String key, Object value) {\n        try {\n            redisTemplate.opsForValue().set(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n\n    /**\n     * 普通缓存放入并设置时间\n     *\n     * @param key   键\n     * @param value 值\n     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期\n     * @return true成功 false 失败\n     */\n    public boolean set(String key, Object value, long time) {\n        try {\n            if (time > 0) {\n                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\n            } else {\n                set(key, value);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 递增\n     *\n     * @param key   键\n     * @param delta 要增加几(大于0)\n     */\n    public long incr(String key, long delta) {\n        if (delta < 0) {\n            throw new RuntimeException(\"递增因子必须大于0\");\n        }\n        return redisTemplate.opsForValue().increment(key, delta);\n    }\n\n    /**\n     * 递减\n     *\n     * @param key   键\n     * @param delta 要减少几(小于0)\n     */\n    public long decr(String key, long delta) {\n        if (delta < 0) {\n            throw new RuntimeException(\"递减因子必须大于0\");\n        }\n        return redisTemplate.opsForValue().increment(key, -delta);\n    }\n    // ================================Map=================================\n    /**\n     * HashGet\n     *\n     * @param key  键 不能为null\n     * @param item 项 不能为null\n     */\n    public Object hget(String key, String item) {\n        return redisTemplate.opsForHash().get(key, item);\n    }\n\n    /**\n     * 获取hashKey对应的所有键值\n     *\n     * @param key 键\n     * @return 对应的多个键值\n     */\n    public Map<Object, Object> hmget(String key) {\n        return redisTemplate.opsForHash().entries(key);\n    }\n\n    /**\n     * HashSet\n     *\n     * @param key 键\n     * @param map 对应多个键值\n     */\n    public boolean hmset(String key, Map<String, Object> map) {\n        try {\n            redisTemplate.opsForHash().putAll(key, map);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n\n    /**\n     * HashSet 并设置时间\n     *\n     * @param key  键\n     * @param map  对应多个键值\n     * @param time 时间(秒)\n     * @return true成功 false失败\n     */\n    public boolean hmset(String key, Map<String, Object> map, long time) {\n        try {\n            redisTemplate.opsForHash().putAll(key, map);\n            if (time > 0) {\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 向一张hash表中放入数据,如果不存在将创建\n     *\n     * @param key   键\n     * @param item  项\n     * @param value 值\n     * @return true 成功 false失败\n     */\n    public boolean hset(String key, String item, Object value) {\n        try {\n            redisTemplate.opsForHash().put(key, item, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 向一张hash表中放入数据,如果不存在将创建\n     *\n     * @param key   键\n     * @param item  项\n     * @param value 值\n     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间\n     * @return true 成功 false失败\n     */\n    public boolean hset(String key, String item, Object value, long time) {\n        try {\n            redisTemplate.opsForHash().put(key, item, value);\n            if (time > 0) {\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 删除hash表中的值\n     *\n     * @param key  键 不能为null\n     * @param item 项 可以使多个 不能为null\n     */\n    public void hdel(String key, Object... item) {\n        redisTemplate.opsForHash().delete(key, item);\n    }\n\n\n    /**\n     * 判断hash表中是否有该项的值\n     *\n     * @param key  键 不能为null\n     * @param item 项 不能为null\n     * @return true 存在 false不存在\n     */\n    public boolean hHasKey(String key, String item) {\n        return redisTemplate.opsForHash().hasKey(key, item);\n    }\n\n    /**\n     * hash递增 如果不存在,就会创建一个 并把新增后的值返回\n     *\n     * @param key  键\n     * @param item 项\n     * @param by   要增加几(大于0)\n     */\n    public double hincr(String key, String item, double by) {\n        return redisTemplate.opsForHash().increment(key, item, by);\n    }\n\n\n    /**\n     * hash递减\n     *\n     * @param key  键\n     * @param item 项\n     * @param by   要减少记(小于0)\n     */\n    public double hdecr(String key, String item, double by) {\n        return redisTemplate.opsForHash().increment(key, item, -by);\n    }\n\n    // ============================set=============================\n    /**\n     * 根据key获取Set中的所有值\n     *\n     * @param key 键\n     */\n    public Set<Object> sGet(String key) {\n        try {\n            return redisTemplate.opsForSet().members(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n\n    /**\n     * 根据value从一个set中查询,是否存在\n     *\n     * @param key   键\n     * @param value 值\n     * @return true 存在 false不存在\n     */\n    public boolean sHasKey(String key, Object value) {\n        try {\n            return redisTemplate.opsForSet().isMember(key, value);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n\n    /**\n     * 将数据放入set缓存\n     *\n     * @param key    键\n     * @param values 值 可以是多个\n     * @return 成功个数\n     */\n    public long sSet(String key, Object... values) {\n        try {\n            return redisTemplate.opsForSet().add(key, values);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n\n    /**\n     * 将set数据放入缓存\n     *\n     * @param key    键\n     * @param time   时间(秒)\n     * @param values 值 可以是多个\n     * @return 成功个数\n     */\n    public long sSetAndTime(String key, long time, Object... values) {\n        try {\n            Long count = redisTemplate.opsForSet().add(key, values);\n            if (time > 0)\n                expire(key, time);\n            return count;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n\n    /**\n     * 获取set缓存的长度\n     *\n     * @param key 键\n     */\n    public long sGetSetSize(String key) {\n        try {\n            return redisTemplate.opsForSet().size(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n\n    /**\n     * 移除值为value的\n     *\n     * @param key    键\n     * @param values 值 可以是多个\n     * @return 移除的个数\n     */\n\n    public long setRemove(String key, Object... values) {\n        try {\n            Long count = redisTemplate.opsForSet().remove(key, values);\n            return count;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n    // ===============================list=================================\n    /**\n     * 获取list缓存的内容\n     *\n     * @param key   键\n     * @param start 开始\n     * @param end   结束 0 到 -1代表所有值\n     */\n    public List<Object> lGet(String key, long start, long end) {\n        try {\n            return redisTemplate.opsForList().range(key, start, end);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n\n    /**\n     * 获取list缓存的长度\n     *\n     * @param key 键\n     */\n    public long lGetListSize(String key) {\n        try {\n            return redisTemplate.opsForList().size(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n\n\n    /**\n     * 通过索引 获取list中的值\n     *\n     * @param key   键\n     * @param index 索引 index>=0时， 0 表头，1 第二个元素，依次类推；index<0时，-1，表尾，-2倒数第二个元素，依次类推\n     */\n    public Object lGetIndex(String key, long index) {\n        try {\n            return redisTemplate.opsForList().index(key, index);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n\n    /**\n     * 将list放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     */\n    public boolean lSet(String key, Object value) {\n        try {\n            redisTemplate.opsForList().rightPush(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n\n    /**\n     * 将list放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     * @param time  时间(秒)\n     */\n    public boolean lSet(String key, Object value, long time) {\n        try {\n            redisTemplate.opsForList().rightPush(key, value);\n            if (time > 0)\n                expire(key, time);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n\n    }\n\n\n    /**\n     * 将list放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     * @return\n     */\n    public boolean lSet(String key, List<Object> value) {\n        try {\n            redisTemplate.opsForList().rightPushAll(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n\n    }\n\n\n    /**\n     * 将list放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     * @param time  时间(秒)\n     * @return\n     */\n    public boolean lSet(String key, List<Object> value, long time) {\n        try {\n            redisTemplate.opsForList().rightPushAll(key, value);\n            if (time > 0)\n                expire(key, time);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 根据索引修改list中的某条数据\n     *\n     * @param key   键\n     * @param index 索引\n     * @param value 值\n     * @return\n     */\n    public boolean lUpdateIndex(String key, long index, Object value) {\n        try {\n            redisTemplate.opsForList().set(key, index, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 移除N个值为value\n     *\n     * @param key   键\n     * @param count 移除多少个\n     * @param value 值\n     * @return 移除的个数\n     */\n    public long lRemove(String key, long count, Object value) {\n        try {\n            Long remove = redisTemplate.opsForList().remove(key, count, value);\n            return remove;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n}\n```\n\n测试\n\n```java\n@Autowired\nprivate RedisUtils redisUtils;\n@Test\n   public void testRedisUtils(){\n    redisUtils.set(\"name\",\"zyz\");\n       System.out.println(redisUtils.get(\"name\"));\n   }\n```\n\n","tags":["Redis"],"categories":["中间件"]},{"title":"Redis事务","url":"/2020/08/08/redis-04/","content":"\nRedis事务：是一个单独的隔离操作。一个事务中的所有命令都会被序列化、按顺序执行。事务在执行的过程中不会被其他命令打断。主要作用就是串联多个命令，防止其他命令插队。<!--more-->\n\n## Redis事务流程\n\n- 开启事务 （multi）\n- 命令入队\n- 执行事务（exec）\n\n```bash\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> set k1 v1\nQUEUED\n127.0.0.1:6379> set k2 v2\nQUEUED\n127.0.0.1:6379> set k3 v3\nQUEUED\n127.0.0.1:6379> get k2\nQUEUED\n127.0.0.1:6379> set k4 v4\nQUEUED\n127.0.0.1:6379> exec\n1) OK\n2) OK\n3) OK\n4) \"v2\"\n5) OK\n```\n\n放弃事务\n\n```bash\n127.0.0.1:6379> discard\nOK\n```\n\n组队的时候发生异常，事务中的所用命令都不会执行。\n\n运行时发生异常，其他命令正常执行，异常命令抛出异常。\n\n## 监控（使用watch实现乐观锁）\n\n>  悲观锁\n\n- 认为任何时候都会出现问题，无论做什么都加锁。\n\n> 乐观锁\n\n- 认为什么时候都不会出问题，所以不会上锁，更新数据时去判断一下，在此期间是否有人修改过这个数据。\n\t- 获取version\n\t- 更新的时候比较version\n\n测试监视功能\n\n```bash\n127.0.0.1:6379> set money 100  \nOK\n127.0.0.1:6379> set out 0\nOK\n127.0.0.1:6379> watch money # 监视money对象\nOK\n127.0.0.1:6379> multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功\nOK\n127.0.0.1:6379> decrby money 20\nQUEUED\n127.0.0.1:6379> incrby out 20\nQUEUED\n127.0.0.1:6379> exec\n1) (integer) 80\n2) (integer) 20\n```\n\n测试多线程修改值，使用watch可以当作redis的乐观锁操作\n\n客户端1：对money对象进行监视，并开启事务，先不执行事务\n\n```bash\n127.0.0.1:6379> watch money\nOK\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> decrby money 20\nQUEUED\n127.0.0.1:6379> incrby out 20\nQUEUED\n```\n\n再打开一个客户端2，对money对象的值进行修改\n\n```bash\n127.0.0.1:6379> get money\n\"80\"\n127.0.0.1:6379> set money 100\nOK\n```\n\n在客户端1中执行事务，因为监视的值发生了改变，所以事务执行失败！\n\n```bash\n127.0.0.1:6379> exec\n(nil)\n```\n\n> 自旋锁\n\n执行失败后，放弃监视（解锁），再重新监视（加锁），获取监视对象的最新值，再执行事务，直到成功。\n\n```bash\n127.0.0.1:6379> unwatch\nOK\n127.0.0.1:6379> watch money\nOK\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> decrby money 20\nQUEUED\n127.0.0.1:6379> incrby out 20\nQUEUED\n127.0.0.1:6379> exec\n1) (integer) 80\n2) (integer) 40\n```\n\n## Reids事务特性\n\n- 单独的隔离操作\n  - 事务中的所有命令都会被序列化、按顺序执行。在事务执行的过程中不会被其他客户端发送过来的命令请求所打断。\n- 不保证原子性\n  - 事务中如果有一条命令执行失败，其后的命令仍然会执行，没有回滚。\n\n```java\n@RestController\n@RequestMapping(\"/testRedis\")\npublic class RedisTestController {\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n    \n    @GetMapping(\"/secKill\")\n    public String secKill(String userId, String productId) {\n        Assert.notNull(userId, \"用户id不能为空！\");\n        Assert.notNull(productId, \"产品id不能为空！\");\n        // 秒杀成功用户key\n        String successUserKey = \"sk:successUser\" + productId;\n        // 商品库存key\n        String productKey = \"sk:product:\" + productId;\n        // 监视库存的key\n        redisTemplate.watch(productKey);\n        // 获取库存\n        Integer stock = (Integer) redisTemplate.opsForValue().get(productKey);\n        if (stock == null) {\n            return \"秒杀没有开始！\";\n        }\n        // 判断用户是否重复秒杀\n        Long count = redisTemplate.opsForSet().add(successUserKey, userId);\n        if (count == null || count <= 0) {\n            return \"已经秒杀成功，不可重复参与！\";\n        }\n        // 判断秒杀是否结束\n        if (stock <= 0) {\n            return \"秒杀结束！\";\n        }\n\n        redisTemplate.multi();\n        // 秒杀成功 库存减1\n        redisTemplate.opsForValue().decrement(productKey);\n        // 将userId添加到秒杀成功的set中\n        redisTemplate.opsForSet().add(successUserKey, userId);\n        if (redisTemplate.exec().size() == 0) {\n            return \"秒杀失败！\";\n        } else {\n            return \"秒杀成功！\";\n        }\n    }\n}\n```\n\n","tags":["Redis"],"categories":["中间件"]},{"title":"Redis三种特殊类型","url":"/2020/08/08/redis-03/","content":"\n## geospatial地理位置\n\n添加地理数据\n\n- 有效的经度从-180度到180度。\n- 有效的纬度从-85.05112878度到85.05112878度。\n\n```bash\n# 可通过java程序一次性道路\n127.0.0.1:6379> geoadd china:city 113.16 30.65 tianmen\n(integer) 1\n127.0.0.1:6379> geoadd china:city 112.19 30.35 jinzhou\n(integer) 1\n127.0.0.1:6379> geoadd china:city 116.40 39.90 beijing\n(integer) 1\n127.0.0.1:6379> geoadd china:city 112.19 31.23 shanghai\n(integer) 1\n```\n\n获取指定的经纬度\n\n```bash\n127.0.0.1:6379> geopos china:city beijing\n1) 1) \"116.39999896287918\"\n   2) \"39.900000091670925\"\n```\n\n返回两个给定位置之间的距离\n\n```bash\ngeodist china:city beijing shanghai km # 两地的直线距离\n```\n\n以给定的经纬度为中心， 找出某一半径内的元素\n\n```bash\n127.0.0.1:6379> georadius china:city 110 30 1000 km\n1) \"jinzhou\"\n2) \"shanghai\"\n3) \"tianmen\"\n georadius china:city 110 30 500 km withdist\n1) 1) \"jinzhou\"\n   2) \"214.1425\"\n2) 1) \"shanghai\"\n   2) \"250.3140\"\n3) 1) \"tianmen\"\n   2) \"311.8670\"\n127.0.0.1:6379> georadius china:city 110 30 1000 km withcoord\n1) 1) \"jinzhou\"\n   2) 1) \"112.18999832868576\"\n      2) \"30.349999617100856\"\n2) 1) \"shanghai\"\n   2) 1) \"112.18999832868576\"\n      2) \"31.229999039757836\"\n3) 1) \"tianmen\"\n   2) 1) \"113.15999776124954\"\n      2) \"30.649999074635581\"\n127.0.0.1:6379> georadius china:city 110 30 1000 km count 2\n1) \"jinzhou\"\n2) \"shanghai\"\n```\n\n底层是zset，可以使用zset的一些操作\n\n```bash\n127.0.0.1:6379> zrange china:city 0 -1\n1) \"jinzhou\"\n2) \"shanghai\"\n3) \"tianmen\"\n4) \"beijing\"\n127.0.0.1:6379> zrem china:city tianmen\n(integer) 1\n127.0.0.1:6379> zrange china:city 0 -1\n1) \"jinzhou\"\n2) \"shanghai\"\n3) \"beijing\"\n```\n\n## hyperloglog\n\n 主要用于基数统计\n\n```bash\npfadd mykey q w e r t y\n(integer) 1\n127.0.0.1:6379> pfcount mykey\n(integer) 6\n```\n\n## Bitmap\n\n位存储，一般用于用户是否登录，统计用户是否活跃，统计打卡\n\n使用bitmap记录一周的打卡：周一：1 周二：0 ......\n\n ```bash\n127.0.0.1:6379> setbit sign 0 1\n(integer) 0\n127.0.0.1:6379> setbit sign 1 0\n(integer) 0\n127.0.0.1:6379> setbit sign 2 0\n(integer) 0\n127.0.0.1:6379> setbit sign 3 1\n(integer) 0\n127.0.0.1:6379> setbit sign 4 1\n(integer) 0\n127.0.0.1:6379> setbit sign 5 1\n(integer) 0\n127.0.0.1:6379> setbit sign 6 0\n(integer) 0\n ```\n\n查看是否打卡\n\n```bash\n127.0.0.1:6379> getbit sign 0 # 查看星期一是否打卡\n(integer) 1\n```\n\n统计打卡天数\n\n```bash\n127.0.0.1:6379> bitcount sign  # 统计一周的打卡次数\n(integer) 4\n```\n\n\n\n","tags":["Redis"],"categories":["中间件"]},{"title":"Redis五大数据类型","url":"/2020/08/05/redis-02/","content":"\nRedis内部存储的数据为键值对，键的数据类型都是字符串类型，这里说的数据类型是指值的类型。<!--more-->\n\n## String（字符串）\n\n使用场景：\n\n- 存储json类型对象\n- 作为计数器，例如点赞数，粉丝数\n\n追加字符串，如果当前key不存在就相当于新建\n\n```bash\nappend name 666\n```\n\n获取字符串长度\n\n```bash\nstrlen name\n```\n\n增加减少\n\n```bash\n127.0.0.1:6379> set views 1   \nOK                      \n127.0.0.1:6379> incr views # 加1      \n(integer) 2                \n127.0.0.1:6379> get views   \n\"2\"                            \n127.0.0.1:6379> decr views   # 减1\n(integer) 1      \n127.0.0.1:6379> get views   \n\"1\"                         \n127.0.0.1:6379> incrby views 10   # 设置步长，加10\n(integer) 11    \n127.0.0.1:6379> get views    \n\"11\"                         \n127.0.0.1:6379> decrby views 10   \n(integer) 1                     \n127.0.0.1:6379> get views       \n\"1\"      \n```\n\n截取字符串\n\n```bash\n127.0.0.1:6379> get demo\n\"hello,world\"\n127.0.0.1:6379> getrange demo 0 4                                                                      \n\"hello\"   \n127.0.0.1:6379> getrange demo 0 -1  # 获取全部字符串                                              \n\"hello,world\"   \n```\n\n替换\n\n```bash\n127.0.0.1:6379> get demo\n\"hello,world\"\n127.0.0.1:6379> setrange demo 6 redis!   # 替换指定位置开始的字符串                                                              (integer) 12                                                                                           127.0.0.1:6379> get demo                                                              \n\"hello,redis!\"   \n```\n\n设置键值对的时候指定有效期\n\n```bash\nsetex key1 10 \"hello\" # 设置key1的值为hello,10秒后过期\n```\n\n如果key不存在就创建\n\n```bash\nsetnx key2 \"hello2\"\n```\n\n批量设置\n\n```bash\n127.0.0.1:6379> mset k1 v1 k2 v1 k3 v3     \nOK                             \n127.0.0.1:6379> keys *     \n1) \"k3\"                \n2) \"k1\"                 \n3) \"k2\"                \n127.0.0.1:6379> msetnx k1 v1 k4 v4   # 原子操作\n(integer) 0         \n127.0.0.1:6379> keys *   \n1) \"k3\"                  \n2) \"k1\"              \n3) \"k2\"         \n```\n\n设置对象 user:{id}.{filed}\n\n```bash\n127.0.0.1:6379> mset user:1:name zyz user:1:age 21\nOK\n127.0.0.1:6379> mget user:1:name user:1:age\n\"zyz\"\n\"21\"\n```\n\n先get后set\n\n```bash\n127.0.0.1:6379> getset name zyz  # key值不存在，先返回nil,再设置\n(nil)                         \n127.0.0.1:6379> get name     \n\"zyz\"                     \n127.0.0.1:6379> getset name zyz666  # key存在，返回key值，再设置\n\"zyz\"                             \n127.0.0.1:6379> get name     \n\"zyz666\"  \n```\n\n## List（列表）\n\n是一个双向链表结构，可以用来存储一组数据；从这个列表的前端和后端取数据效率非常高。\n\n使用场景：\n\n- 模拟队列，堆栈\n- 朋友圈点赞，查询点赞数，点赞人的信息等\n\n插入\n\n```bash\n127.0.0.1:6379> lpush list 1   # 相当于压栈，操作第一个元素\n(integer) 1                    \n127.0.0.1:6379> lpush list 2    \n(integer) 2               \n127.0.0.1:6379> lpush list 3       \n(integer) 3              \n127.0.0.1:6379> lrange list 0 2         \n1) \"3\"                \n2) \"2\"               \n3) \"1\"             \n127.0.0.1:6379> rpush list 4   # 相当于从队列的尾部插入 ，操作最后一个元素  \n(integer) 4                \n127.0.0.1:6379> lrange list 0 -1   \n 1) \"3\"      \n 2) \"2\"     \n 3) \"1\"       \n 4) \"4\"         \n```\n\n删除\n\n```shell\n127.0.0.1:6379> lrange list 0 -1      \n1) \"3\"        \n2) \"2\"         \n3) \"1\"        \n4) \"4\"      \n127.0.0.1:6379> lpop list   # 移除第一个\n\"3\"                     \n127.0.0.1:6379> Rpop list   # 移除最后一个                        \n\"4\"  \n127.0.0.1:6379> lrange list 0 -1     \n1) \"2\"                           \n2) \"1\"  \n```\n\n获取值\n\n```bash\n127.0.0.1:6379> lindex list 0                           \n\"2\" \n```\n\n查询list长度\n\n```bash\n127.0.0.1:6379> llen list   \n(integer) 4   \n```\n\n根据指定的值删除\n\n```bash\n127.0.0.1:6379> lrange list 0 -1  \n1) \"4\"                            \n2) \"3\"              \n3) \"2\"         \n4) \"1\"        \n127.0.0.1:6379> lrem list  1 4  # 移除value为4的从头开始的第一个值   \n(integer) 1              \n127.0.0.1:6379> lrange list 0 -1   \n1) \"3\"                         \n2) \"2\"                                                                         \n3) \"1\"  \n```\n\n截取元素\n\n```bash\n127.0.0.1:6379> lrange list 0 -1    \n1) \"3\"                    \n2) \"2\"                \n3) \"1\"               \n127.0.0.1:6379> ltrim list 0 1   # 通下标[0]截取指定长度[1] \nOK                     \n127.0.0.1:6379> lrange list 0 -1     \n1) \"3\"                                                        \n2) \"2\" \n```\n\n将原列表的最后一个元素移到新的列表中\n\n```bash\n127.0.0.1:6379> lrange list 0 -1      \n1) \"3\"                                \n2) \"2\"                            \n127.0.0.1:6379> rpoplpush list list1  # 将list最后一个元素移到list1中    \n\"2\"                      \n127.0.0.1:6379> lrange list1 0 -1   \n1) \"2\"                 \n127.0.0.1:6379> lrange list 0 -1    \n1) \"3\"                                                                          \n```\n\n更新值，需要先判断list是否存在\n\n```bash\n127.0.0.1:6379> exists list                                       \n(integer) 0  \n127.0.0.1:6379> lpush list value1                                           \n(integer) 1   \n127.0.0.1:6379> lset list 0 value2                                                        \nOK   \n```\n\n从指定元素值前面/后面插入\n\n```bash\n127.0.0.1:6379> lrange list 0 -1  \n1) \"1\"                           \n2) \"2\"             \n127.0.0.1:6379> linsert list after 2 3   # 在值为2的元素后面插入一个值为3的元素\n(integer) 3                         \n127.0.0.1:6379> lrange list 0 -1    \n1) \"1\"                            \n2) \"2\"             \n3) \"3\"                \n127.0.0.1:6379> linsert list before 1 0    # 在值为1的元素前面插入一个值为0的元素  \n(integer) 4                         \n127.0.0.1:6379> lrange list 0 -1      \n1) \"0\"                            \n2) \"1\"                         \n3) \"2\"                                                           \n4) \"3\"  \n```\n\nList实际上是一个双向链表，前后都可以插入值；key不存在创建新的节点，key存在，新增内容；两边插入或改动效率最高。\n\n消息队列（Lpush，Rpop），栈（Lpush，Lpop）\n\n## Set（集合）\n\n**值不可重复**，值则相同添加失败。\n\n使用场景：\n\n- 去重\n- 抽奖\n- set运算，交集并集补集差集运算，例如好友推荐\n\n添加值、查看所有值、判断值是否存在\n\n```bash\n127.0.0.1:6379> sadd myset aaa   \n(integer) 1                     \n127.0.0.1:6379> sadd myset bbb     \n(integer) 1                     \n127.0.0.1:6379> smembers myset    \n1) \"bbb\"              \n2) \"aaa\"              \n127.0.0.1:6379> sismember myset aaa  \n(integer) 1                  \n127.0.0.1:6379> sismember myset ccc                              \n(integer) 0  \n```\n\n移除指定值的元素\n\n```bash\n127.0.0.1:6379> smembers myset    \n1) \"bbb\"              \n2) \"aaa\"    \n127.0.0.1:6379> srem myset bbb      \n(integer) 1                                                                                        \n127.0.0.1:6379> smembers myset   \n1) \"aaa\"  \n```\n\n随机挑选元素\n\n```bash\n127.0.0.1:6379> smembers myset    \n1) \"bbb\"                         \n2) \"aaa\"                    \n3) \"ccc\"               \n127.0.0.1:6379> srandmember myset    \n\"ccc\"                    \n127.0.0.1:6379> srandmember myset        \n\"bbb\"                        \n127.0.0.1:6379> srandmember myset                                                         \n\"ccc\"    \n```\n\n随机删除\n\n```shell\nspop myset\n```\n\n移动指定元素\n\n```bash\n127.0.0.1:6379> smembers myset    \n1) \"bbb\"                         \n2) \"aaa\"                    \n3) \"ccc\"  \n127.0.0.1:6379> smove myset myset2 aaa\n(integer) 1\n127.0.0.1:6379> smembers myset\n1) \"bbb\"\n2) \"ccc\"\n127.0.0.1:6379> smembers myset2\n1) \"aaa\"\n```\n\n差集，交集，并集==>应用场景：B站，微博的共同关注等等\n\n```bash\n127.0.0.1:6379> sadd myset a\n(integer) 1\n127.0.0.1:6379> sadd myset b\n(integer) 1\n127.0.0.1:6379> sadd myset c\n(integer) 1\n127.0.0.1:6379> sadd myset2 c\n(integer) 1\n127.0.0.1:6379> sadd myset2 d\n(integer) 1\n127.0.0.1:6379> sadd myset2 e\n(integer) 1\n127.0.0.1:6379> sdiff myset myset2\n1) \"a\"\n2) \"b\"\n127.0.0.1:6379> sinter myset myset2\n1) \"c\"\n127.0.0.1:6379> sunion myset myset2\n1) \"d\"\n2) \"c\"\n3) \"b\"\n4) \"a\"\n5) \"e\"\n```\n\n## Zset（有序集合）\n\n可排序的set，每一个添加值都有一个对应的分数，可通过这个分数进行排序\n\n使用场景：\n\n- 海量数据的排行，例如天梯排名\n\n添加\n\n```bash\n127.0.0.1:6379> zadd myzset 1 value1\n(integer) 1\n127.0.0.1:6379> zadd myzset 2 value2 3 value3\n(integer) 2\n127.0.0.1:6379> zrange myzset 0 -1\n1) \"value1\"\n2) \"value2\"\n3) \"value3\"\n```\n\n排序\n\n```bash\n127.0.0.1:6379> zrangebyscore myzset -inf +inf # 最小值到最大值排序\n1) \"value1\"\n2) \"value2\"\n3) \"value3\"\n127.0.0.1:6379> zrevrange myzset 0 -1 # 从大到小\n1) \"value3\"\n2) \"value2\"\n1) \"value1\"\n```\n\n移除元素\n\n```bash\n zrem myzset value1\n```\n\n获取个数\n\n```bash\nzcard myzset\n```\n\n获取指定区间的成员数量\n\n```bash\nzcount myzset 1 3\n```\n\n## Hash（哈希）\n\n可以理解为Map集合，key-map，值是一个Map集合\n\n使用场景：\n\n- 与String+json相比，存储对象的属性需要频繁修改时，使用Hash，可以针对某个属性单独修改，没有序列化，也不需要修改整个对象。\n\n```bash\n127.0.0.1:6379> hset myhash field1 aaa # 添加一个值\n(integer) 1\n127.0.0.1:6379> hget myhash field1 # 获取一个指定字段的值\n\"aaa\"\n127.0.0.1:6379> hmset myhash field2 bbb field3 ccc # 添加多个键值对\nOK\n127.0.0.1:6379> hmget myhash field1 field2 # 获取多个字段值\n1) \"aaa\"\n2) \"bbb\"\n127.0.0.1:6379> hgetall myhash # 获取全部数据\n1) \"field1\"\n2) \"aaa\"\n3) \"field2\"\n4) \"bbb\"\n5) \"field3\"\n6) \"ccc\"\n```\n\n获取长度\n\n```bash\nhlen myhash\n```\n\n判断字段是否存在\n\n```bash\n127.0.0.1:6379> hexists myhash field1\n(integer) 1\n127.0.0.1:6379> hexists myhash aaaa\n(integer) 0\n```\n\n获取所有字段/值\n\n```bash\n127.0.0.1:6379> hkeys myhash\n1) \"field1\"\n2) \"field2\"\n3) \"field3\"\n127.0.0.1:6379> hvals myhash\n1) \"aaa\"\n2) \"bbb\"\n3) \"ccc\"\n```\n\n自增，自减\n\n```bash\nhincrby myhash field1 1\nhincrby myhash field1 -1\n```\n\n","tags":["Redis"],"categories":["中间件"]},{"title":"Redis入门","url":"/2020/08/04/redis-01/","content":"\n随着数据量的爆发式增加，数据变化率的急剧增加，MySQL等关系型数据库不够用了，就需要使用NoSQL了。<!--more-->\n\n## 什么是Nosql\n\nNoSQL=Not Only SQL\n\n关系型数据库：表格\n\n非关系型数据库：\n\n- 方便拓展，数据之间没有关系\n- 大数据高性能（Redis一秒写8万次，读取11万，NoSQL的缓存是一种细粒度的缓存，性能会比较高）\n- 数据类型是多样型的（不需要事先设计数据库，随取随用！）\n- 没有固定的查询语言\n- 键值对存储，列存储，文档存储，图形数据库\n\n## NoSQL的四大分类\n\n- KV键值对：redis\n- 文档型数据库（bson格式）：MongoDB\n- 列存储：HBase（用于分布式文件系统）\n- 图关系型数据库：Neo4J（存放关系：社交网络，广告推荐）\n\n## Redis概述\n\nRedis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。\n\n## 适用场景\n\n- 数据缓存\n  - 将一些频繁访问且短时间内不会发生变化的数据放入缓存中，提高用户的请求是速度和降低网站的负载。\n- 会话缓存\n  - 保存web会话信息\n- 排行榜、计数器\n- 消息队列\n\n## Window下安装\n\n1、下载压缩包解压即可：\nhttps://github.com/microsoftarchive/redis/releases/tag/win-3.2.100\n2、运行服务redis-server.exe\n![](redis-01/1.png)\n\n3、运行客户端redis-cli.exe来连接redis，使用ping命令测试是否连接成功\n![](redis-01/2.png)\n\n## 基础知识\n\n默认端口号：6379\n\n选择数据库，默认数据库是0\n\n```bash\nselect [0~15]\n```\n\n查看当前数据库的大小\n\n```bash\ndbsize\n```\n\n设置键值对，name为key的值，zyz为value的值\n\n```bash\nset name zyz\n```\n\n获取指定key的value\n\n```bash\nget name\n```\n\n移除key，1表示当前数据库\n\n```bash\nmove name 1\n```\n\n查看数据库的所有key\n\n```bash\nkeys *\n```\n\n判断指定的key是否存在\n\n```bash\nexists name\n```\n\n设置key的有效期\n\n```bash\nexpire name [秒数]\n```\n\n查看剩余多少秒过期\n\n```bash\nttl name\n```\n\n查看key的类型\n\n```bash\ntype name\n```\n\n清空当前数据库\n\n```bash\nflushdb\n```\n\n清空全部数据库\n\n```bash\nflushall\n```\n\n**Redis是单线程的，基于内存操作，CPU不是Redis的性能瓶颈，Redis的性能是根据机器的内存和网络带宽决定的。**\n\nRedis将全部数据存放于内存，所以说使用单线程效率最高，多线程cpu上下文切换耗时，对于内存系统来说，如果没有上下文切换，效率就是最高的。\n\n- 单线程不需要内存切换开销\n- 没有锁的竞争\n- IO多路复用，让单个线程高效的处理多个连接请求，减少网络IO的耗时\n\n","tags":["Redis"],"categories":["中间件"]},{"title":"Git","url":"/2020/08/03/git/","content":"\nGit是目前最先进的分布式版本控制系统。没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网。相互推送就能看到对方的修改了。<!--more-->\nSVN是集中式版本控制系统，版本库是集中放在中央服务器上的，所以工作时首先要从中央服务器得到最新的版本，然后工作，工作完成后推送给服务器。\n\n## 查看不同级别的配置\n\n```bash\n# 查看系统config\ngit config --system --list\n# 查看当前用户\ngit config --global --list\n```\n\n## 设置用户名与邮箱\n\n```bash\ngit config --global user.name \"sweetboyZhang\"  # 名称\ngit config --global user.email \"2824199842@qq.com\"   # 邮箱\n```\n\n## 三个区域\n\nGit本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository），如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。\n<img src=\"git/1.png\" style=\"zoom:80%;\" />\n\n## git项目搭建\n\n**创建工作目录**\n\n工作目录就是git管理的文件夹，可以是项目目录，也可以是空目录。\n![](git/2.png)\n\n**搭建本地仓库**\n\n```bash\n# 在当前目录创建一个全新的仓库\ngit init\n```\n\n**克隆远程仓库**\n\n```bash\n# 克隆一个项目和它整个代码历史\ngit clone [url]\n```\n\n## git文件操作\n\n```bash\n# 查看文件状态\ngit status [filename]\n\n# 查看所有文件状态\ngit status\n\n# 添加所有文件到暂存区\ngit add .\n\n# 提交文件到本地仓库 -m 提交信息\ngit commit -m \"[msg]\"\n```\n\n## 项目中忽略上传文件\n\n.gitignore\n\n```gitignore\n*.class\n*.log\n*.lock\n\n# Package File \n*.jar\n*.war\n*.ear\ntarget/\n\n# idea\n.idea/\n*.iml\nbin/\n.settings/\n.classpath\n.project\n*.ips\n*.iws\n\n*velocity.log*\n\n# STS\n.apt_generared\n.factorypath\n.springbean\n\n*.log\ntmp/\n```\n\n## 绑定远程仓库\n\n```bash\n# 生成公钥\nssh-keygen\n```\n\n在浏览器上创建空仓库后，就可以clone到本地仓库了\n\n![](git/4.png)\n\n## IDEA中集成git\n\n1、创建项目\n\n2、将远程的git文件目录复制到项目中\n\n![](git/3.png)\n\n3、使用命令或者是图形界面添加文件，提交文件，上传文件\n\n```bash\ngit add .\ngit commit -m \"[提交信息]\"\ngit push\n```\n\n## git分支\n\n```bash\n# 列出本地所有分支\ngit branch\n\n# 列出所有远程分支\ngit branch -r\n \n# 新建一个分支，但依然停留在当前分支\ngit branch [branch-name]\n \n# 新建一个分支，并切换到该分支\ngit checkout -b [branch]\n \n# 合并指定分支到当前分支\n$ git merge [branch]\n \n# 删除分支\n$ git branch -d [branch-name]\n \n# 删除远程分支\n$ git push origin --delete [branch-name]\n```\n\n","tags":["Git"],"categories":["工具"]},{"title":"异步任务，邮件发送","url":"/2020/08/03/springboot-07/","content":"\n## 异步任务\n\n1、在启动类添加```@EnableAsync``` ，表示 开启异步注解功能\n\n2、在方法上添加```@Async```，表示异步方法<!--more-->\n\n```java\n@Service\npublic class AsyncService {\n    // 使用注解表示异步任务\n    @Async\n    public  void hello(){\n        try {\n            sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"数据正在处理......\");\n    }\n}\n```\n\n3、在Controller中直接调用即可\n\n## 邮件发送\n\n1、导入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n```\n\n2、打开邮箱的POP3/SMTP服务获取授权码，设置->账户->开启pop3和smtp服务\n\n![](springboot-07/1.png)\n\n3、编写配置文件\n\n```java\n@RestController\npublic class EmailController {\n    @Autowired\n    private JavaMailSenderImpl mailSender;\n\n    @RequestMapping(\"/sendMail\")\n    public String sendMail(){\n        SimpleMailMessage mailMessage = new SimpleMailMessage();\n        mailMessage.setSubject(\"通知\");\n        mailMessage.setText(\"hello\");\n        mailMessage.setTo(\"2824199842@qq.com\");\n        mailMessage.setFrom(\"2824199842@qq.com\");\n        mailSender.send(mailMessage);\n        return \"send ok\";\n    }\n\n    @RequestMapping(\"/sendMail2\")\n    public String sendMail2() throws Exception{\n        MimeMessage mimeMessage = mailSender.createMimeMessage();\n        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true);\n        helper.setSubject(\"通知\");\n        helper.setText(\"<p style='color:red'>hello~</p>\",true);\n        helper.addAttachment(\"1.jpg\",new File(\"C:\\\\Users\\\\28241\\\\Pictures\\\\Saved Pictures\\\\1.jpg\"));// 附件\n        helper.setTo(\"2824199842@qq.com\");\n        helper.setFrom(\"2824199842@qq.com\");\n        mailSender.send(mimeMessage);\n        return \"send ok\";\n    }\n}\n```\n\n","tags":["SpringBoot"],"categories":["微服务"]},{"title":"Swagger简介与使用","url":"/2020/08/02/swagger/","content":"\n背景：前后端分离时代的来临  Vue+Springboot\n\n后端时代：前端至负责管理静态页面；html==>后端。模板引擎jsp=>后端是主力\n\n前后端分离时代：<!--more-->\n\n- 后端：后端控制层，服务层，数据访问层\n- 前端：前端控制层，视图层\n\t- 伪造后端数据，json。不需要后端，前端工程依然能够跑起来\n- 前后端交互：API\n- 前后端相互独立，松耦合\n- 前后端甚至可以分布在不同的服务器上\n\n产生的一个问题：\n\n- 前后端集成联调，前后端人员无法做到“及时协商，尽早解决”，最终导致问题爆发。\n\n解决方案：\n\n- 首先指定schema，实时更新最新的API，降低集成的风险\n- 早些年：\n\t-  指定word计划文档；\n\t- 前端测试后端接口：postman\n\t- 后端提供接口，需要实时更新最新的消息及改动\n- Swagger产生 ！\n\n## Swagger简介\n\n- 号称世界上最流行的API框架\n- ReatFul API 文档在线自动生成工具=>API文档与API自动更新\n- 直接运行，可以在线测试API接口\n- 支持多种语言\n\n## Springboot集成Swagger\n\n1、创建springboot项目并导入web依赖\n\n2、导入相关依赖\n\n```xml\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-swagger2</artifactId>\n    <version>3.0.0</version>\n</dependency>\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-swagger-ui</artifactId>\n    <version>3.0.0</version>\n</dependency>\n```\n\n3、编写一个hellworld\n\n4、编写Swagger配置类\n\n```java\n@Configuration\n@EnableSwagger2  // 开启Swagger2\npublic class SwaggerConfig {\n\n}\n```\n\n5、测试访问：http://localhost:8080/swagger-ui.html\n![](swagger/1.png)\n\n## 配置Swagger\n\nSwagger的bean实例 Docket\n\n```java\n@Configuration\n@EnableSwagger2  // 开启Swagger2\npublic class SwaggerConfig {\n\n    // 配置Swagger的Docket的bean实例\n    @Bean\n    public Docket docket(){\n        return new Docket( new DocumentationType(\"swagger\", \"2.0\"))\n                .apiInfo(apiInfo());\n    }\n\n    // 配置Swagger的apiInfo\n    private ApiInfo apiInfo(){\n        Contact contact = new Contact(\"sweetboyZhang\", \"https://sweetboyZhang.github.io\", \"2824199842@qq.com\");\n        return new ApiInfo(\n                \"My Swagger API 文档\",\n                \"这是一个Swagger测试\",\n                \"1.0\",\n                \"https://sweetboyZhang.github.io\",\n                contact,\n                \"Apache 2.0\",\n                \"http://www.apache.org/licenses/LICENSE-2.0\",\n                new ArrayList<VendorExtension>());\n    }\n    \n}\n```\n\n## 配置Swagger扫描路径\n\n```java\n@Bean\npublic Docket docket(){\n    return new Docket( new DocumentationType(\"swagger\", \"2.0\"))\n            .apiInfo(apiInfo())\n            .select()\n            // RequestHandlerSelectors配置要扫描接口的方式\n            // basePackage 指定要扫描的包\n            // any() 扫描全部\n            // none() 不扫描\n            // withClassAnnotation(xxx.class)扫描类上的注解\n            // withMethodAnnotation(xxx.class)扫描方法上的注解\n            .apis(RequestHandlerSelectors.basePackage(\"com.zyz.controller\"))\n            // .paths 过滤路径\n            .build();\n}\n```\n\n## 根据环境是否开启Swagger\n\n```java\n@Bean\npublic Docket docket(Environment environment){\n    // 设置要显示的Swagger环境\n    Profiles profiles = Profiles.of(\"dev\");\n    // 获取项目环境\n    boolean flag = environment.acceptsProfiles(profiles);\n    return new Docket( new DocumentationType(\"swagger\", \"2.0\"))\n            .apiInfo(apiInfo())\n            .enable(flag)// 设置是否启动Swagger\n            .select()\n            // RequestHandlerSelectors配置要扫描接口的方式\n            // basePackage 指定要扫描的包\n            // any() 扫描全部\n            // none() 不扫描\n            // withClassAnnotation(xxx.class)扫描类上的注解\n            // withMethodAnnotation(xxx.class)扫描方法上的注解\n            .apis(RequestHandlerSelectors.basePackage(\"com.zyz.controller\"))\n            // .paths 过滤路径\n            .build();\n}\n```\n\napplication-dev.properties\n\n```properties\n# 生产环境\nserver.port=8080\n```\n\napplication-pro.properties\n\n```properties\n# 上线环境\nserver.port=8081\n```\n\napplication.properties\n\n```properties\n# 激活生产环境\nspring.profiles.active=dev  \n```\n\n## 配置分组\n\n方便多人协同开发\n\n```java\n.groupName(\"zyz\")\n```\n\n```java\n@Bean\npublic Docket docket1(){\n    return new Docket(DocumentationType.SWAGGER_2).groupName(\"A\");\n}\n@Bean\npublic Docket docket2(){\n    return new Docket(DocumentationType.SWAGGER_2).groupName(\"B\");\n}\n@Bean\npublic Docket docket3(){\n    return new Docket(DocumentationType.SWAGGER_2).groupName(\"C\");\n}\n```\n\n## 配置实体类\n\n```java\n// 只要接口中的返回值有实体类，Swagger就会扫描到\n@ApiOperation(\"user控制方法\")// 方法注释\n@PostMapping(\"/user\")\npublic User user(@ApiParam(\"用户名\")String name,@ApiParam(\"密码\") String password){\n    return new User(name,password);\n}\n```\n\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@ApiModel(\"用户实体类\")// 注释\npublic class User {\n    @ApiModelProperty(\"用户名\")\n    private String name;\n    @ApiModelProperty(\"密码\")\n    private String password;\n}\n```\n\n\n![](swagger/2.png)\n\n","tags":["Swagger"],"categories":["JavaEE"]},{"title":"SpringSecurity","url":"/2020/07/28/springboot-06/","content":"\nSpringSecurity是一个针对于Spring项目的安全框架，侧重于为Spring项目提供身份验证和授权。<!--more-->\n\n将我们之前使用拦截器，过滤器进行权限检查，和身份验证的操作进行了简化，并提供了一套 Web 应用安全性的完整解决方案。\n\n## SpringSecurity使用\n\n仅需引入spring-boot-starter-security模块，进行少量的配置，便可以实现强大的安全管理。\n\n- WebSecurityConfigureAdapter：自定义Security策略\n- AuthenticationManagerBuilder：自定义认证策略\n\nSpringScurity的两个主要目标就是**认证**和**授权**。\n\n### 1、引入SpringSecurity模块\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n```\n\n### 2、创建config目录，添加WebSecurityConfig类\n\n```java\n@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    /**\n     * 配置用户信息 模拟内存用户数据\n     * @param auth\n     * @throws Exception\n     */\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.inMemoryAuthentication()\n                .withUser(\"root\")\n                .password(passwordEncoder().encode(\"root\"))\n                .roles(\"ADMIN\", \"USER\")\n                .authorities(\"sys:add\", \"sys:delete\", \"sys:query\", \"sys:update\")\n                .and()\n                .withUser(\"zyz\")\n                .password(passwordEncoder().encode(\"zyz\"))\n                .roles(\"USER\")\n                .authorities(\"sys:query\");\n    }\n\n    /**\n     * 密码加密器\n     * @return\n     */\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    /**\n     * http控制\n     * @param http\n     * @throws Exception\n     */\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n\n        // 关闭跨站请求伪造\n        http.csrf().disable();\n\n        // 请求拒绝的处理器\n        http.exceptionHandling().accessDeniedHandler(accessDeniedHandler());\n\n        // 登录成功和失败的跳转 前后端返回json字符串\n        http.formLogin()\n                .loginProcessingUrl(\"/loginNew\")// 自定义登录的请求地址\n                .usernameParameter(\"userName\")// 取别名\n                .passwordParameter(\"password\")\n//                .successForwardUrl(\"/welcome\")\n//                .failureForwardUrl(\"/login\");\n                .successHandler(successHandler())\n                .failureHandler(failureHandler())\n                .permitAll();// 放行接口\n\n        // 自定义登出的请求地址\n        http.logout().logoutUrl(\"/logoutNew\");\n\n        // 访问权限的控制 在controller方法上使用@PreAuthorize注解代替（启动类需要开启@EnableGlobalMethodSecurity(prePostEnabled = true)）\n//        http.authorizeRequests()\n//                .antMatchers(\"/addUser\").hasAuthority(\"sys:add\")\n//                .antMatchers(\"/delUser\").hasAnyAuthority(\"sys:del\")\n//                .antMatchers(\"/updateUser\").hasAnyAuthority(\"sys:update\")\n//                .antMatchers(\"/queryUser\").hasAnyAuthority(\"sys:query\")\n//                .antMatchers(\"/testUser\").hasAnyAuthority(\"sys:test\");\n\n        // 其他接口登录后才能访问\n        http.authorizeRequests()\n                .anyRequest()\n                .authenticated();\n    }\n\n\n    /**\n     * 登录成功后的处理 将用户信息存入redis 并返回前端一个token\n     * @return\n     */\n    @Bean\n    public AuthenticationSuccessHandler successHandler() {\n        return (request, response, authentication) -> {\n            // 组装数据给前端\n            Map<String, Object> result = new HashMap<>();\n            result.put(\"code\", HttpStatus.OK.value());\n            result.put(\"msg\", \"登录成功\");\n            // 设置编码\n            response.setContentType(\"application/json;charset=utf-8\");\n            response.getWriter().write(JSON.toJSONString(result));\n        };\n    }\n\n    /**\n     * 登录失败后的处理\n     * @return\n     */\n    @Bean\n    public AuthenticationFailureHandler failureHandler() {\n        return (request, response, exception) -> {\n            Map<String, Object> result = new HashMap<>();\n            result.put(\"code\", HttpStatus.UNAUTHORIZED.value());\n            if (exception instanceof LockedException) {\n                result.put(\"msg\", \"账户被锁定，登陆失败！\");\n            } else if (exception instanceof BadCredentialsException) {\n                result.put(\"msg\", \"账户或者密码错误，登陆失败！\");\n            } else if (exception instanceof DisabledException) {\n                result.put(\"msg\", \"账户被禁用，登陆失败！\");\n            } else if (exception instanceof AccountExpiredException) {\n                result.put(\"msg\", \"账户已过期，登陆失败！\");\n            } else if (exception instanceof CredentialsExpiredException) {\n                result.put(\"msg\", \"密码已过期，登陆失败！\");\n            } else {\n                result.put(\"msg\", \"登陆失败！\");\n            }\n            response.setContentType(\"application/json;charset=utf-8\");\n            response.getWriter().write(JSON.toJSONString(result));\n        };\n    }\n\n    /**\n     * 请求拒绝的处理器\n     * @return\n     */\n    @Bean\n    public AccessDeniedHandler accessDeniedHandler() {\n        return ((request, response, accessDeniedException) -> {\n            response.setContentType(\"application/json;charset=utf-8\");\n            Map<String, Object> result = new HashMap<>();\n            result.put(\"code\", HttpStatus.FORBIDDEN.value());\n            result.put(\"msg\",\"权限不够\");\n            response.getWriter().write(JSON.toJSONString(result));\n        }\n        );\n    }\n}\n```\n\n### 3、测试Controller\n\n```java\n@RestController\npublic class HelloController {\n\n    @GetMapping(\"/hello\")\n    public String helle(){\n        return \"hello\";\n    }\n\n    @GetMapping(\"/getUserInfo\")\n    public Object getUserInfo(Principal principal){\n        return principal;\n    }\n\n    @GetMapping(\"/getUserInfo2\")\n    public Object getUserInfo(){\n        return SecurityContextHolder.getContext().getAuthentication();\n    }\n}\n```\n\n```java\n@RestController\npublic class TestController {\n\n    /**\n     * 登录成功跳转 是一个post请求\n     * @return\n     */\n    @PostMapping(\"welcome\")\n    public String welcome() {\n        return \"welcome\";\n    }\n\n\n    @GetMapping(\"addUser\")\n    @PreAuthorize(\"hasAuthority('sys:add')\")\n    public String addUser() {\n        return \"addUser\";\n    }\n\n    @GetMapping(\"updateUser\")\n    @PreAuthorize(\"hasAuthority('sys:update')\")\n    public String updateUser() {\n        return \"updateUser\";\n    }\n\n    @GetMapping(\"delUser\")\n    @PreAuthorize(\"hasAnyAuthority('sys:del')\")\n    public String delUser() {\n        return \"delUser\";\n    }\n\n    @GetMapping(\"queryUser\")\n    @PreAuthorize(\"hasAnyAuthority('sys:query')\")\n    public String queryUser() {\n        return \"queryUser\";\n    }\n\n    @GetMapping(\"testUser\")\n    @PreAuthorize(\"hasAnyAuthority('sys:test')\")\n    public String testUser() {\n        return \"testUser\";\n    }\n\n    @GetMapping(\"free\")\n    public String free() {\n        return \"free\";\n    }\n}\n```\n\n### 4、从数据库中获取用户信息，作为校验\n\n```java\n/**\n * @Description 用户登录信息 实现SpringSecurity中的UserDetails接口\n * @Author zhangyuzhen\n * @Since JDK 1.8\n * @Version V1.0\n * @Date 2021/10/31 15:38\n */\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class UserLoginInfo implements UserDetails {\n\n    private Integer userId;\n    private String userName;\n    private String userPwd;\n    private Integer status;\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return Collections.emptyList();\n    }\n\n    @Override\n    public String getPassword() {\n        return userPwd;\n    }\n\n    @Override\n    public String getUsername() {\n        return userName;\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return status==1;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return status==1;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return status==1;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return status==1;\n    }\n}\n```\n\n```java\n/**\n * @Description 从数据库中获取登录信息\n * @Author zhangyuzhen\n * @Since JDK 1.8\n * @Version V1.0\n * @Date 2021/10/31 15:26\n */\n@Service\npublic class UserDetailServiceImpl implements UserDetailsService {\n\n    @DubboReference\n    private UserService userService;\n    \n    @Override\n    public UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException {\n        MyThreadLocal.userName.set(userName);\n        User user = userService.selectByName(userName);\n        // 转换对象\n        if (!ObjectUtil.isEmpty(user)) {\n            UserLoginInfo userLoginInfo = new UserLoginInfo();\n            userLoginInfo.setUserId(user.getId());\n            userLoginInfo.setUserName(user.getUsername());\n            userLoginInfo.setUserPwd(user.getPassword());\n            userLoginInfo.setStatus(user.getStatus());\n            return userLoginInfo;\n        }\n        return null;\n    }\n}\n```\n\n## 使用Redis保存用户信息\n\n在登录成功的处理方法successHandler中将token存入redis，并将token返回给前端\n\n```java\n// 生成token 直接用uuid作为redis中用户信息的key\nString token = UUID.randomUUID().toString().replace(\"-\", \"\");\nString value = JSON.toJSONString(authentication.getPrincipal());\nstringRedisTemplate.opsForValue().set(LoginConstant.TOKEN_PREFIX+token,\n                                      JSON.toJSONString(authentication.getPrincipal()), 15 * 60, TimeUnit.SECONDS);\n // 组装数据给前端\nMap<String, Object> result = new HashMap<>();\nresult.put(\"status\", 200);\nresult.put(\"token\", token);\nresult.put(\"expire\", 15 * 60);\nresult.put(\"msg\", \"登录成功\");\nresponse.getWriter().write(JSON.toJSONString(result));\n```\n\n定义过滤器实现token校验\n\n```java\n/**\n * @Description Token校验过滤器\n * @Author zhangyuzhen\n * @Since JDK 1.8\n * @Version V1.0\n * @Date 2021/10/31 16:49\n */\n@Component\npublic class TokenCheckFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        String path = request.getRequestURI();\n        // 放行\n        if (LoginConstant.ALLOW_URLS.contains(path)) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n        // 校验\n        String header = request.getHeader(LoginConstant.HEAD_AUTHORIZATION);\n        if (StringUtils.hasText(header)) {\n            Boolean isExist = stringRedisTemplate.hasKey(LoginConstant.TOKEN_PREFIX+header);\n            if (null != isExist && isExist) {\n                JSONObject jsonObject = JSON.parseObject(stringRedisTemplate.opsForValue().get(LoginConstant.TOKEN_PREFIX + header));\n                String userName = jsonObject.getString(\"username\");\n                // 封装成security内置的对象\n                UsernamePasswordAuthenticationToken authenticationToken =\n                        new UsernamePasswordAuthenticationToken(userName, null, Collections.emptyList());\n                authenticationToken.setDetails(new WebAuthenticationDetails(request));\n                SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n                return;\n            }\n        }\n        Map<String, Object> result = new HashMap<>();\n        result.put(\"status\", 401);\n        result.put(\"msg\", \"验证失败\");\n        response.setContentType(\"application/json;charset=utf-8\");\n        response.getWriter().write(JSON.toJSONString(result));\n    }\n}\n```\n","tags":["SpringBoot"],"categories":["微服务"]},{"title":"整合MyBatis","url":"/2020/07/26/springboot-05/","content":"\n首先创建一个sprinboot项目，并引入web,jbdc,mysql驱动依赖。\n\n## 1、添加springboot整合myBatis的依赖\n\n```xml\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.1.3</version>\n</dependency>\n```\n\n## 2、配置数据库连接信息\n\n```yml\nspring:\n  datasource:\n    username: root\n    password: 2824199842\n    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n## 3、测试是否能连接成功\n\n```java\n@SpringBootTest\nclass Springboot05MybatisApplicationTests {\n    @Autowired\n    DataSource dataSource;\n    @Test\n    void contextLoads() throws SQLException {\n        Connection connection = dataSource.getConnection();\n        System.out.println(connection);\n    }\n}\n```\n\n## 4、创建实体类，导入lombok\n\n```xml\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.4</version>\n</dependency>\n```\n\nUser.java\n\n```java\npackage com.zyz.bean;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n    private Integer id;\n    private String name;\n    private String pwd;\n}\n```\n\n## 5、创建mapper目录，以及对应的mapper接口\n\nUserMapper.java\n\n```java\n@Mapper// 表示这是一个mybatis的mapper类\n@Repository\npublic interface UserMapper {\n\n     List<User> listAllUser();\n\n     User queryUserById(int id);\n\n     int addUser(User user);\n\n     int deleteUser(int id);\n\n     int updateUser(User user);\n}\n```\n\n6、创建对应的sql映射文件UserMapper.xml\n![](springboot-05/1.png)\n\n在项目配置文件中添加mybatis配置\n\n```yml\n# mybatis配置\nmybatis:\n    type-aliases-package: com.zyz.bean # 设置别名 默认为类名\n    mapper-locations: classpath:mybatis/mapper/*.xml # mapper文件位置\n    configuration:\n    \t# 输出sql\n    \tlog-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n    \t# 开启驼峰命名规则\n    \tmap-underscore-to-camel-case: true\n```\n\nUserMapper.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.zyz.mapper.UserMapper\">\n    <select id=\"listAllUser\" resultType=\"User\">\n        select * from user\n    </select>\n\n    <select id=\"queryUserById\" resultType=\"User\">\n        select * from user where id=#{id}\n    </select>\n    \n    <insert id=\"addUser\" parameterType=\"User\">\n        insert into user(name,pwd)values(#{name},#{password})\n    </insert>\n    \n    <delete id=\"deleteUser\" parameterType=\"int\">\n        delete from user where id=#{id}\n    </delete>\n\n    <update id=\"updateUser\" parameterType=\"User\">\n        update user set name=#{name},pwd=#{pwd} where id=#{id}\n    </update>\n</mapper>\n```\n\n## 6、创建controller目录，添加UserController类\n\nUserController.java\n\n```java\n@RestController\npublic class UserController {\n    @Autowired\n    private UserMapper userMapper;\n\n    @GetMapping(\"/listAllUser\")\n    public List<User> list(){\n        return userMapper.listAllUser();\n    }\n\n    @GetMapping(\"/queryUserById/{id}\")\n    public User query(@PathVariable(\"id\") int id){\n        return userMapper.queryUserById(id);\n    }\n\n    @GetMapping(\"/addUser\")\n    public String add(){\n        userMapper.addUser(new User(null,\"马老师\",\"123456\"));\n        return \"add success\";\n    }\n    @GetMapping(\"/deleteUser/{id}\")\n    public String delete(@PathVariable(\"id\") int id){\n        userMapper.deleteUser(id);\n        return \"delete success\";\n    }\n    @GetMapping(\"/updateUser\")\n    public String update(){\n        userMapper. updateUser(new User(1,\"qwer\",\"123456\"));\n        return \"update success\";\n    }\n}\n```\n\n到此为止，MyBatis整合完毕。\n\n","tags":["SpringBoot"],"categories":["微服务"]},{"title":"整合jdbc，Druid","url":"/2020/07/25/springboot-04/","content":"\n对于数据访问层，无论是SQL还是NOSQL，Springboot底层都是采用Spring Data的方式进行统一处理。<!--more-->\n\n## 整合jdbc\n\n### 1、新建项目引入web模块和连接mysql必须的模块，JDBC API，MySQL Driver\n\n![](springboot-04/1.png)\n\n### 2、项目建立完成后，发现已经替我们导入响应的启动器\n\n```xml\n <!--web-->\n <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<!--jdbc-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n<!--mysql-->\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <scope>runtime</scope>\n</dependency>\n```\n\n### 3、编写yaml配置文件连接数据库\n\n```yml\nspring:\n  datasource:\n    username: root\n    password: 2824199842\n    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n### 在测试类中测试连接是否成功 \n\n4、配置完这一些东西后，我们就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置\n\n```java\n@SpringBootTest\nclass Springboot04DataApplicationTests {\n    @Autowired\n    DataSource dataSource;\n    @Test\n    void contextLoads() throws SQLException {\n        // 查看默认数据源 据说是最快的数据库连接池 HikariDataSource\n        System.out.println(dataSource.getClass());\n        // 获取数据库连接\n        Connection connection = dataSource.getConnection();\n        System.out.println(connection);\n        // 关闭连接\n        connection.close();\n    }\n}\n```\n\n### 5、编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试；\n\n```java\n@RestController // 返回json对象给浏览器\npublic class JDBCController {\n    /**\n     * springboot对原生jdbc做了轻量级的封装\n     * 并且通过JdbcTemplate类提供了对数据库的crud操作\n     *\n     * execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；\n     * update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；\n     * batchUpdate方法用于执行批处理相关语句；\n     * query方法及queryForXXX方法：用于执行查询相关语句；\n     * call方法：用于执行存储过程、函数相关语句\n      */\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    // 查询数据库中员工表的所有记录\n    // 没有实体类，从数据库查询到的数据怎么封装？ 使用万能的Map!\n    @GetMapping(\"listAllUser\")\n    public List<Map<String,Object>> listAllUser(){\n        // 原生jdbc操作\n        String sql = \"select * from user\";\n        List<Map<String, Object>> allUser = jdbcTemplate.queryForList(sql);\n        return allUser;\n    }\n\n    @GetMapping(\"/addUser\")\n    public String addUser(){\n        String sql = \"insert into user(name,pwd)value('wd1','123456')\";\n        jdbcTemplate.update(sql);\n        return \"addOK\";\n    }\n\n    @GetMapping(\"/deleteUser/{id}\") //@PathVariable接收路径中占位符的值\n    public String deleteUser(@PathVariable(\"id\") int id){\n        String sql = \"delete from user where id=?\";\n        jdbcTemplate.update(sql,id);\n        return \"deleteOK\";\n    }\n\n    @GetMapping(\"/updateUser/{id}\")\n    public String updateUser(@PathVariable(\"id\") int id){\n        String sql = \"update user set name=?,pwd=? where id=\"+id;\n        // 封装\n        Object[] objects = new Object[2];\n        objects[0]=\"张伟\";\n        objects[1]=\"666666\";\n        jdbcTemplate.update(sql,objects);\n        return \"updateOK\";\n    }\n}\n```\n\n至此，使用原生的jdbc完成了基本的crud操作，因为springboot对jdbc进行了轻量级的封装，在使用上也并不是很繁琐。\n\n## 整合Druid\n\n### 1、添加Druid依赖\n\n```xml\n<!--druid-->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.1.23</version>\n</dependency>\n```\n\n### 2、在配置文件中指定数据源\n\n```yml\nspring:\n  datasource:\n    username: root\n    password: 2824199842\n    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源\n```\n\n### 3、测试并查看数据源\n\n```java\n@SpringBootTest\nclass Springboot04DataApplicationTests {\n\n    @Autowired\n    DataSource dataSource;\n    @Test\n    void contextLoads() throws SQLException {\n        System.out.println(dataSource.getClass());//class com.alibaba.druid.pool.DruidDataSource\n        // 获取数据库连接\n        Connection connection = dataSource.getConnection();\n        System.out.println(connection);\n        // 关闭连接\n        connection.close();\n    }\n}\n```\n\n### 4、获取连接成功后，可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数等设置项\n\n```yml\nspring:\n  datasource:\n    username: root\n    password: 2824199842\n    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源\n\n    #Spring Boot 默认是不注入这些属性值的，需要自己绑定\n    #druid 数据源专有配置\n    initialSize: 5\n    minIdle: 5\n    maxActive: 20\n    maxWait: 60000\n    timeBetweenEvictionRunsMillis: 60000\n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    poolPreparedStatements: true\n\n    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入\n    #需要导入 log4j 依赖\n    filters: stat,wall,log4j\n    maxPoolPreparedStatementPerConnectionSize: 20\n    useGlobalDataSourceStat: true\n    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n```\n\n### 5、导入log4j依赖\n\n```xml\n<!--log4j -->\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n</dependency>\n```\n\n### 6、创建DruidConfig类，用于拓展配置druid\n\n将数据源的配置文件绑定到容器中，无需springboot再创建容器\n\n```java\n@Configuration\npublic class DruidConfig {\n    /**\n     *将自定义的Druid数据源添加到容器中，不再让Spring Boot自动创建\n     *绑定全局配置文件中的druid数据源属性到DruidDataSource从而让它们生效\n     * @return\n     */\n    @Bean\n    @ConfigurationProperties(prefix = \"spring.datasource\")\n    public DruidDataSource druidDataSource(){\n        return new DruidDataSource();\n    }\n}\n```\n\n配置后台监控功能：\nDruid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装路由器 时，人家也提供了一个默认的 web 页面。\n\n```java\n@Bean // 注入到容器中，就相当于web.xml文件\npublic ServletRegistrationBean statViewServlet(){\n    ServletRegistrationBean<StatViewServlet> bean = \n        new ServletRegistrationBean<>(new StatViewServlet(), \"/druid/*\");\n    // 配置后台登录名和密码\n    Map<String, String> initParameters = new HashMap<String, String>();\n    // 增加配置\n    initParameters.put(\"loginUsername\",\"admin\");// loginUsername loginPassword是固定的\n    initParameters.put(\"loginPassword\",\"123456\");\n    // 访问权限\n    initParameters.put(\"allow\",\"\");\n    // 设置初始化参数\n    bean.setInitParameters(initParameters);\n    return bean;\n}\n```\n\n访问http://localhost:8080/druid/\n![](springboot-04/2.png)\n\n登录成功后\n![](springboot-04/3.png)\n\n配置过滤器\n\n```java\n@Bean\npublic FilterRegistrationBean webStatFilter(){\n    FilterRegistrationBean bean = new FilterRegistrationBean();\n    bean.setFilter(new WebStatFilter());\n    // 设置过滤请求\n    HashMap<String, String> initParameters = new HashMap<>();\n    initParameters.put(\"exclusion\",\"*.js,*.css,/druid/*\");// 设置不进行过滤的资源\n    bean.setInitParameters(initParameters);\n    return bean;\n}\n```\n\n","tags":["SpringBoot"],"categories":["微服务"]},{"title":"图书Crud项目","url":"/2020/07/15/ssm/","content":"\n此项目用于回顾ssm整合的过程，加深自己对ssm三大框架的理解以及提高使用框架的能力，同时也是对前端，web，mysql等知识的复习。<!--more-->\n\n# 一、设计数据库\n\n创建一个名为ssm的数据库，由于只是一个图书的crud项目，这里只创建一个books表\n\n```sql\nCREATE DATABASE ssm;\n\nUSE ssm;\n\nDROP TABLE IF EXISTS books ;\n\nCREATE TABLE books(\nid INT(10) NOT NULL PRIMARY KEY auto_increment,\nname VARCHAR(50) NOT NUll,\ncounts INT(11) NOT NULL,\ndetails VARCHAR(200) NOT NULL\n);\n\nINSERT INTO books(id,name,counts,details)VALUES\n(1,'JavaSE',10,'java从入门到精通'),\n(2,'MySQL',23,'MySQL入门'),\n(3,'JavaWeb',40,'使用java编写网站'),\n(4,'JavaEE',40,'JavaWev企业级开发解决方案');\n```\n\n# 二、项目基本环境搭建\n\n1、使用Maven创建项目 SSM。(注意：这里并没有使用模板创建）\n2、导入项目需要的依赖\n\n```xml\n<!--依赖 junit,数据库连接驱动,数据库连接池,servlet,jsp,springmvc,spring-jdbc,mybatis,mybatis-spring-->\n<dependencies>\n    <!--Junit-->\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n    </dependency>\n    <!--数据库驱动-->\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.19</version>\n    </dependency>\n    <!-- 数据库连接池 -->\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid</artifactId>\n        <version>1.1.12</version>\n    </dependency>\n    <!--Servlet - JSP -->\n    <dependency>\n        <groupId>javax.servlet</groupId>\n        <artifactId>servlet-api</artifactId>\n        <version>2.5</version>\n    </dependency>\n    <dependency>\n        <groupId>javax.servlet.jsp</groupId>\n        <artifactId>jsp-api</artifactId>\n        <version>2.2.1-b03</version>\n        <scope>provided</scope>\n    </dependency>\n    <dependency>\n        <groupId>javax.servlet</groupId>\n        <artifactId>jstl</artifactId>\n        <version>1.2</version>\n    </dependency>\n    <!--Spring-->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.2.5.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.2.5.RELEASE</version>\n    </dependency>\n    <!--Mybatis-->\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.2</version>\n    </dependency>\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>2.0.2</version>\n    </dependency>\n</dependencies>\n```\n\n3、Maven资源过滤设置\n\n```xml\n<!--静态资源导出-->\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>false</filtering>\n        </resource>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>false</filtering>\n        </resource>\n    </resources>\n</build>\n```\n\n4、建立项目包结构和配置框架\n![](ssm/1.png)\n\nmybatis-config.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<configuration>\n    \n</configuration>\n```\n\napplication.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n</beans>\n```\n\njdbc.properties\n\n```properties\njdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=Asia/Shanghai\njdbc.username=root\njdbc.password=2824199842\njdbc.maxActive=20\n```\n\n# 三、MyBatis层编写\n\n1、创建实体类Book\n这里使用Lombok（偷懒~），需要导入依赖：（注意：IDEA首次使用时需要安装插件 setting->plugins->lombok）\n\n```xml\n<!--Lombok-->\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.4</version>\n</dependency>\n```\n\n```java\n@Data  // 隐式导入所有get set toString 无参构造等方法\n@AllArgsConstructor // 有参构造，此时无参构造没了，需要加上NoArgsConstructor\n@NoArgsConstructor // 无参构造\npublic class Book {\n    private Integer id;\n    private String name;\n    private Integer counts;\n    private String details;\n\n}\n```\n\n2、编写BookMapper接口\n\n```java\npublic interface BookMapper {\n    /**\n     * 增加图书\n     * @return\n     */\n    int addBook(Book book);\n\n    /**\n     * 删除图书\n     * @param id\n     * @return\n     */\n    int deleteBookById(@Param(\"bookId\") int id);\n\n    /**\n     * 更新图书\n     * @param book\n     * @return\n     */\n    int updateBook(Book book);\n\n    /**\n     * 查询图书\n     * @param id\n     * @return\n     */\n    Book queryBookById(@Param(\"bookId\") int id);\n\n    /**\n     * 查询所有图书\n     * @return\n     */\n    List<Book> queryAllBook();\n}\n```\n\n3、编写BookMapper接口的sql映射文件BookMapper.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.zyz.dao.BookMapper\">\n\n    <insert id=\"addBook\" parameterType=\"com.zyz.bean.Book\">\n        insert into books(name,counts,details) values(#{name},#{counts},#{details})\n    </insert>\n\n    <delete id=\"deleteBookById\" parameterType=\"int\">\n        delete from books where id=#{bookId}\n    </delete>\n\n    <update id=\"updateBook\" parameterType=\"com.zyz.bean.Book\">\n        update books set name=#{name},counts=#{counts},details=#{details}\n        where id=#{id}\n    </update>\n\n    <select id=\"queryBookById\" parameterType=\"int\" resultType=\"com.zyz.bean.Book\">\n        select * from books where id=#{bookId}\n    </select>\n\n    <select id=\"queryAllBook\" resultType=\"com.zyz.bean.Book\">\n        select * from books\n    </select>\n</mapper>\n```\n\n4、在mybtis配置文件中注册sql映射文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<configuration>\n     <!--  打印日志-->\n    <settings>\n        <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n    </settings>\n    <!--  注册映射文件  -->\n    <mappers>\n        <package name=\"com.zyz.dao\"/>\n    </mappers>\n\n</configuration>\n```\n\n至此，Dao层编写完成，下一步编写Service层\n\n5、编写Service层的接口和实现类\n\n```java\npublic interface BookService {\n    /**\n     * 增加图书\n     * @return\n     */\n    int addBook(Book book);\n\n    /**\n     * 删除图书\n     * @param id\n     * @return\n     */\n    int deleteBookById(int id);\n\n    /**\n     * 更新图书\n     * @param book\n     * @return\n     */\n    int updateBook(Book book);\n\n    /**\n     * 查询图书\n     * @param id\n     * @return\n     */\n    Book queryBookById(int id);\n\n    /**\n     * 查询所有图书\n     * @return\n     */\n    List<Book> queryAllBook();\n}\n```\n\n```java\npublic class BookServiceImpl implements BookService{\n\n    @Autowired\n    private BookMapper bookMapper;\n\n    public int addBook(Book book) {\n        return bookMapper.addBook(book);\n    }\n\n    public int deleteBookById(int id) {\n        return bookMapper.deleteBookById(id);\n    }\n\n    public int updateBook(Book book) {\n        return bookMapper.updateBook(book);\n    }\n\n    public Book queryBookById(int id) {\n        return bookMapper.queryBookById(id);\n    }\n\n    public List<Book> queryAllBook() {\n        return bookMapper.queryAllBook();\n    }\n}\n```\n\n# 四、Spring层整合Dao,Service层\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/tx\n       http://www.springframework.org/schema/tx/spring-tx.xsd\">\n\n    <!--  关联数据库配置文件-->\n    <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n    <!--声明数据源  用于连接数据库-->\n    <bean id=\"myDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\n          init-method=\"init\" destroy-method=\"close\">\n        <property name=\"url\" value=\"${jdbc.url}\"/>\n        <property name=\"username\" value=\"${jdbc.username}\"/>\n        <property name=\"password\" value=\"${jdbc.password}\"/>\n        <property name=\"maxActive\" value=\"${jdbc.maxActive}\"/>\n    </bean>\n\n    <!--声明mybatis中的SqlSessionFactoryBean 用于创建SqlSessionFactory对象    -->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <!-- set注入，把数据库连接池赋值给dateSource属性-->\n        <property name=\"dataSource\" ref=\"myDataSource\"/>\n        <!-- mybatis主配置文件的位置-->\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n    </bean>\n\n    <!-- 声明Dao类\n         MapperScannerConfigurer:在内部调用getMapper()生成每一个接口的dao代理对象\n         创建好的dao对象放在spring容器中，默认名称为 接口名首字母小写-->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <!--注入sqlSessionFactory-->\n        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/>\n        <!--要扫描的dao包-->\n        <property name=\"basePackage\" value=\"com.zyz.dao\"/>\n    </bean>\n\n    <!--  声明service的注解@Service所在的包名位置  -->\n    <context:component-scan base-package=\"com.zyz.service\"/>\n\n    <!-- 声明事务管理器   -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <!--  连接的数据库，指定数据源 -->\n        <property name=\"dataSource\" ref=\"myDataSource\"/>\n    </bean>\n    \n\t<!-- 开启事务注解驱动 告诉spring使用注解管理事务，创建代理对象\n         在需要使用事务的方法上添加Transactional注解-->\n    <tx:annotation-driven transaction-manager=\"transactionManager\"/>\n</beans>\n```\n\n然后，需要在Service实现类上添加@Service注解\n\n# 五、SpringMVC层的整合\n\n1、添加web支持\n右键项目\n![](ssm/2.png)\n\n勾选Web Application\n![](ssm/3.png)\n\n配置web.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <!--DispatchServlet-->\n    <servlet>\n        <servlet-name>springmvc</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:springmvc.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>springmvc</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n\n    <!-- 注册监听器  用于创建Spring容器   -->\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:application.xml</param-value>\n    </context-param>\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    <!--乱码过滤-->\n    <filter>\n        <filter-name>encodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>utf-8</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>encodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    <!--Session 有效时间-->\n    <session-config>\n        <session-timeout>15</session-timeout>\n    </session-config>\n\n</web-app>\n```\n\n创建springmvc.xml并进行配置\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/mvc\n       https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <!--注解驱动-->\n    <mvc:annotation-driven/>\n\n    <!--  处理静态资源-->\n    <mvc:default-servlet-handler />\n\n    <!--扫描controller-->\n    <context:component-scan base-package=\"com.zyz.controller\"/>\n\n    <!--声明springmvc框架中的视图解析器 -->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <!--前缀  视图文件的路径-->\n        <property name=\"prefix\" value=\"/WEB-INF/view/\"/>\n        <!--后缀  视图文件的拓展名-->\n        <property name=\"suffix\" value=\".jsp\"></property>\n    </bean>\n</beans>\n```\n\n到此为止，整个ssm项目的配置文件基本上配置完成了，ssm项目与springboot项目相比，最大的不同就是这种繁杂的配置，但是学习ssm是必不可少的，只有这样才能了解到整个Javaweb工程的核心。\n下一步是编写controller层以及与前端页面的交互。\n\n# 六、Controller层与页面之间的交互\n\n编写BookController类,添加crud方法\n\n## 方法一：查询所有图书\n\n```java\n@Controller\n@RequestMapping(\"/book\")\npublic class BookController {\n    // Controller层就是调用service层的一些方法，完成需要的业务\n    @Autowired\n    private BookService bookService;\n\n    /**\n     * 查询所有图书\n     * @return\n     */\n    @RequestMapping(\"/allBooks\")\n    public String list(Model model){\n        List<Book> books = bookService.queryAllBook();\n        model.addAttribute(\"books\",books);\n        return \"allBooks\";\n    }\n}\n```\n\n编写首页：index.jsp\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>首页</title>\n    <style>\n        h3{\n            border: 2px blueviolet solid;\n            text-align: center;\n            width: 200px;\n            height: 50px;\n            background-color: aqua;\n            padding: 20px;\n            border-radius: 10px;\n            margin: 200px auto;/*外边距*/\n            line-height: 50px;/*行高与高度一致则居中*/\n        }\n        a{\n            text-decoration: none;/*去掉链接的下划线*/\n            color: blue;\n            font-size: 30px;\n        }\n    </style>\n</head>\n<body>\n<h3>\n    <a href=\"${pageContext.request.contextPath}/book/allBooks\">查询所有图书</a>\n</h3>\n</body>\n</html>\n```\n\n编写展示所有图书的页面allBook.jsp\n\n```html\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>书籍展示页面</title>\n    <!-- 引入 Bootstrap -->\n    <link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\n</head>\n<body>\n\n<div class=\"container\">\n    <div class=\"row clearfix\">\n        <div class=\"col-md-12 column\">\n            <div class=\"page-header\">\n                <h1><small>书籍列表——显示所有图书</small></h1>\n            </div>\n        </div>\n    </div>\n    \n    <div class=\"row clearfix\">\n        <div class=\"col-md-12 column\">\n            <table class=\"table table-hover table-striped\">\n                <thead>\n                <tr>\n                    <th>书籍编号</th>\n                    <th>书籍名称</th>\n                    <th>书籍数量</th>\n                    <th>书籍详情</th>\n                </tr>\n                </thead>\n                <tbody>\n                <%--遍历从数据库中查到的全部图书--%>\n                <c:forEach var=\"book\" items=\"${books}\">\n                    <tr>\n                        <td>${book.id}</td>\n                        <td>${book.name}</td>\n                        <td>${book.counts}</td>\n                        <td>${book.details}</td>\n                    </tr>\n                </c:forEach>\n                </tbody>\n            </table>\n        </div>\n    </div>\n</div>\n</body>\n</html>\n```\n\n启动Tomcat测试：\n由于我使用maven直接创建的项目，没有使用maven中的模板，所以需要手动将项目目录下的包打包至WEB-INF目录下，Tomcat才能正常启动：\n![](ssm/4.png)\n\n## 方法二：添加图书\n\n1、首先在展示所有图书的页面allBooks.jsp添加一个发起请求的链接\n\n```html\n<div class=\"col-md-12 column\">\n    <div class=\" pull-right\" >\n        <%--跳到新增图书页面--%>\n        <a class=\"btn btn-success\"\n           href=\"${pageContext.request.contextPath}/book/toAddBook\">添加书籍</a>\n    </div>\n</div>\n```\n\n然后在BookConntroller添加一个跳转到添加页面的方法\n\n```java\n/**\n * 跳转到添加图书页面\n * @return\n */\n@RequestMapping(\"/toAddBook\")\npublic String toAddBook(){\n    return \"addBook\";\n}\n```\n\n编写添加图书的页面addBook.jsp，也就是一个表单\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>添加图书页面</title>\n    <!-- 引入 Bootstrap -->\n    <link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\n</head>\n<body>\n<div class=\"container\">\n    <div class=\"row clearfix\">\n        <div class=\"col-md-12 column\">\n            <div class=\"page-header\">\n                <h1><small>添加图书</small></h1>\n            </div>\n        </div>\n\n        <form action=\"${pageContext.request.contextPath}/book/addBook\" method=\"post\">\n            <div class=\"form-group\">\n                <label for=\"bkName\">书籍名称</label>\n                <input type=\"text\" class=\"form-control\" id=\"bkName\" name=\"name\" required>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"bkCounts\">书籍数量</label>\n                <input type=\"number\" class=\"form-control\" id=\"bkCounts\" name=\"counts\" required>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"bkDetails\">书籍详情</label>\n                <input type=\"text\" class=\"form-control\" id=\"bkDetails\" name=\"details\" required>\n            </div>\n            <button type=\"submit\" class=\"btn btn-primary\">添加</button>\n        </form>\n    </div>\n</div>\n</body>\n</html>\n```\n\n最后在BookController中编写添加图书的方法\n\n```java\n/**\n * 添加图书\n * @param book\n * @return\n */\n@RequestMapping(\"/addBook\")\npublic String addBook(Book book){\n    // System.out.println(book);\n    bookService.addBook(book);\n    // 重定向到查询所有图书的Controller\n    return \"redirect:/book/allBooks\";\n}\n```\n\n## 方法三：修改图书\n\n在展示所有图书的页面添加发起请求的链接：\n\n```html\n<td>\n    <a class=\"btn btn-primary\"\n       href=\"${pageContext.request.contextPath}/book/toUpdateBook?id=${book.id}\">修改</a>\n    &nbsp;&nbsp;\n    <a class=\"btn btn-danger\" href=\"\">删除</a>\n</td>\n```\n\n在BookController中添加跳转到修改页面的方法\n\n```java\n/**\n * 跳转到修改页面\n * @return\n */\n@RequestMapping(\"/toUpdateBook\")\npublic String toUpdateBook(int id,Model model){\n    Book book = bookService.queryBookById(id);\n    model.addAttribute(\"book\",book);\n    return \"updateBook\";\n}\n```\n\n编写修改图书的页面updateBook.jsp，又是一个表单\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>修改图书页面</title>\n    <!-- 引入 Bootstrap -->\n    <link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\n</head>\n<body>\n<div class=\"container\">\n    <div class=\"row clearfix\">\n        <div class=\"col-md-12 column\">\n            <div class=\"page-header\">\n                <h1><small>修改图书</small></h1>\n            </div>\n        </div>\n        <form action=\"${pageContext.request.contextPath}/book/updateBook\" method=\"post\">\n            <div class=\"form-group\">\n                <label for=\"bkName\">书籍名称</label>\n                <input type=\"text\" class=\"form-control\" id=\"bkName\" name=\"name\" value=\"${book.name}\" required>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"bkCounts\">书籍数量</label>\n                <input type=\"number\" class=\"form-control\" id=\"bkCounts\" name=\"counts\" value=\"${book.counts}\" required>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"bkDetails\">书籍详情</label>\n                <input type=\"text\" class=\"form-control\" id=\"bkDetails\" name=\"details\" value=\"${book.details}\" required>\n            </div>\n            <button type=\"submit\" class=\"btn btn-primary\">修改</button>\n        </form>\n    </div>\n</div>\n</body>\n</html>\n```\n\n最后在BookController中编写修改图书的方法\n\n```java\n/**\n * 修改图书\n * @param book\n * @return\n */\n@RequestMapping(\"/updateBook\")\npublic String updateBook(Book book){\n    // System.out.println(book);\n    bookService.updateBook(book);\n    return \"redirect:/book/allBooks\";\n}\n```\n\n这里更新不了的原因是因为updateBook中的book对象的id值为空，而更新图书时需要id作为参数去查找哪一本图书要更新。解决方案是在修改图书页面的表单中添加一组隐藏域，将id值传给updateBook()方法即可\n\n```html\n <input type=\"hidden\" name=\"id\" value=\"${book.id}\">### 方法四：删除图书\n```\n\n在展示所有图书的页面添加发起请求的链接\n\n```html\n<td>\n    <a class=\"btn btn-primary\"\n       href=\"${pageContext.request.contextPath}/book/toUpdateBook?id=${book.id}\">修改</a>\n    &nbsp;&nbsp;\n    <a class=\"btn btn-danger\"\n       href=\"${pageContext.request.contextPath}/book/deleteBook?id=${book.id}\">删除</a>\n</td>\n```\n\n## 方法四：删除图书\n\n在BookController中添加删除图书的方法\n\n```java\n/**\n * 删除图书\n * @param id\n * @return\n */\n@RequestMapping(\"/deleteBook\")\npublic String deleteBook(int id){\n    bookService.deleteBookById(id);\n    return \"redirect:/book/allBooks\";\n}\n```\n\n## 方法五：模糊搜索\n\nmapper层：\n\n```java\n /**\n     * 根据书名模糊搜索\n     * @param name\n     * @return\n     */\n    List<Book> queryBookByName(@Param(\"bookName\") String name);\n```\n\n```xml\n<select id=\"queryBookByName\" resultType=\"com.zyz.bean.Book\">\n    select * from books where name like #{bookName}\n</select>\n```\n\nservice层\n\n```java\n/**\n * 通过name模糊查询书籍\n * @param name\n * @return\n */\nList<Book> queryBookByName(String name);\n```\n\n```java\n public List<Book> queryBookByName(String name) {\nString realName = name.trim();// 去掉前后端空格\n      return bookMapper.queryBookByName(\"%\"+realName+\"%\");\n  }\n```\n\ncontroller层\n\n```java\n/**\n * 根据名称模糊查询书籍\n * @param bkName\n * @param model\n * @return\n */\n@RequestMapping(\"/queryBook\")\npublic String queryBook(String bkName,Model model){\n    List<Book> books = bookService.queryBookByName(bkName);\n    System.out.println(books);\n    model.addAttribute(\"books\",books);\n    return \"allBooks\";\n}\n```\n\n前端页面：\n\n```html\n<form action=\"${pageContext.request.contextPath}/book/queryBook\" method=\"post\">\n    <div class=\"col-xs-3\">\n        <input class=\"form-control\" type=\"text\" name=\"bkName\" placeholder=\"请输入要查询的书籍名称\"required>\n    </div>\n    <input class=\"btn btn-primary\" type=\"submit\" value=\"查询\" >\n</form>\n```\n\n# 七、项目总体结构\n\n<img src=\"ssm/5.png\" style=\"zoom:80%;\" />\n\n# 八、最终效果\n\n![](ssm/6.png)\n\n# 九、总结\n\n1、ssm整合的总体思路：使用spring容器去管理Dao,Service对象，springmvc容器管理Controller对象，springmvc容器是spring的子容器，springmvc容器中的controller对象能访问到spring容器中的service对象。\n\n2、对css的一些属性的运用还不是很熟练\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["MyBatis","Spring","SpringMVC"],"categories":["小项目"]},{"title":"Springboot Web开发","url":"/2020/07/11/springboot-03/","content":"\n## 静态资源的导入\n\nresources目录下存放静态资源。\n![](springboot-03/1.png)\n\n## 模板引擎Thymeleaf\n\n就是将后端的数据渲染到前端的页面上去显示，例如 jsp 就是一个模板引擎。\n![](springboot-03/2.png)\n\n**thymeleaf 的使用**\n\n首先导入它的依赖，在springboot中要添加其他组件，没有什么是一个starter解决不了的！\n\n```xml\n<!--thymeleaf-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n\n将测试页面放在templates目录下，编写conntroller跳转页面\n\n```java\n@Controller\npublic class TestController {\n    @RequestMapping(\"/test1\")\n    public String test1(){\n        return \"test1\";\n    }\n}\n```\n\n**thmeleaf 语法**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <h1>test1</h1>\n    <!--所有的html元素都可以被thymeleaf替换接管  th:元素名-->\n    <p th:text=\"${msg}\"></p>\n    <hr/>\n    <!--循环-->\n    <div th:each=\"val:${arr}\" th:text=\"${val}\"></div>\n    <!--传递参数-->\n   <a th:href=\"@{/toUpdate/}+${emp.getId()}\">编辑</a>\n   <a th:href=\"@{/delete/}+${emp.getId()}\">删除</a>\n   <!--引入公共组件-->\n   <div th:replace=\"~{common/common::topbar}\"></div>\n    <!--日期格式化-->\n   <p th:text=\"${#dates.format(emp.getBirth(),'yyyy-MM-dd')}\"></p>\n</body>\n</html>\n```\n\n## 接管SpringMVC\n\n创建config目录，在config目录下编写类，用来接管、扩展SpringMVC\n\n```java\n@Configuration\npublic class MyMvcConfig implements WebMvcConfigurer {\n    @Override // 配置页面映射关系\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(\"/\").setViewName(\"/index\");\n        registry.addViewController(\"/index.html\").setViewName(\"/index\");\n    registry.addViewController(\"/main.html\").setViewName(\"/dashboard\");\n    }\n\n    @Override // 配置拦截器\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/*\")\n            .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\",\"/static/**\");\n    }\n}\n```\n\n编写拦截器的实现类\n\n```java\npublic class LoginHandlerInterceptor implements HandlerInterceptor {\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        // 登录成功后有user的session\n        Object loginUser = request.getSession().getAttribute(\"loginUser\");\n        if(loginUser==null){\n            // 没有登录\n            request.setAttribute(\"msg\",\"没有权限，请登录！\");\n            request.getRequestDispatcher(\"/index.html\").forward(request,response);\n            return false;\n        }\n        return true;\n    }\n}\n```\n\n## 处理器接收页面传参\n\n```html\n<a th:href=\"@{/delete/}+${emp.getId()}\">删除</a>\n```\n\n```java\n@RequestMapping(\"/delete/{id}\")// @PathVarable 接收路径中占位符的值\npublic String delete(@PathVariable(\"id\")Integer id){}\n```\n\n## 项目配置文件\n\n```properties\n# 关闭thymeleaf 缓存\nspring.thymeleaf.cache=false\n\n# 项目路径  localhost:8080/zyz\nserver.servlet.context-path=/springboot_web\n\n# 国际化\n# spring.messages.basename=i18n.login\n\n# 时间日期格式化\nspring.mvc.format.date=yyyy-MM-dd\n```","tags":["SpringBoot"],"categories":["微服务"]},{"title":"Springboot配置","url":"/2020/07/10/springboot-02/","content":"\n## 配置文件\n\nSpringBoot使用一个全局配置文件，用于修改默认配置，文件名固定。\n\n- application.properties：语法结构：key=value\n- application.yml，springboot推荐使用：语法结构：key: &nbsp;value \n\n两个文件同时存在时，先加载application.properties\n\n## yaml概述\n\n1、空格不能省略，key:空格value\n\n2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。\n\n3、属性和值的大小写都是十分敏感的。\n\n## yaml注入配置文件\n\n![](springboot-02/6.png)\n\n测试：\n\n```java\n@SpringBootTest\nclass Springboot02ConfigApplicationTests {\n    @Autowired\n    private Cat cat;\n    @Autowired\n    private Person person;\n    @Test\n    void contextLoads() {\n        System.out.println(cat);\n        System.out.println(person);\n    }\n\n}\n```\n\n结果：\n\n```\nCat{name='小白', age=3}\nPerson{name='zyz', age=22, happy=true, birth=Fri Jul 10 00:00:00 CST 2020, maps={k1=v1, k2=v2}, lists=[1, 2, 3], cat=Cat{name='小花', age=2}}\n```\n\n指定随机uuid:\n\n```yaml\nname: zyz${random.uuid} # 随机uuid\n```\n\n## properties注入\n\n![](springboot-02/7.png)\n\n## JSR303校验\n\nSpringboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。\n\n引入依赖\n\n```xml\n<dependency>\n     <groupId>org.springframework.boot</groupId>\n     <artifactId>spring-boot-starter-validation</artifactId>\n</dependency>\n```\n\n```java\n@Component\n@ConfigurationProperties(prefix = \"person\")\n@Validated  // 数据校验\npublic class Person {\n    @Email(message=\"邮箱格式不合法\")// 使name只能支持Email格式\n    private String name;\n}\n```\n\n运行结果：\n![](springboot-02/8.png)\n\n **常见参数**\n\n空检查\n@Null       验证对象是否为null\n@NotNull    验证对象是否不为null, 无法查检长度为0的字符串\n@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.\n@NotEmpty   检查约束元素是否为NULL或者是EMPTY.\n\nBooelan检查\n@AssertTrue     验证 Boolean 对象是否为 true \n@AssertFalse    验证 Boolean 对象是否为 false \n\n长度检查\n@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  @Length(min=, max=) string is between min and max included\n\n日期检查\n@Past       验证 Date 和 Calendar 对象是否在当前时间之前 \n@Future     验证 Date 和 Calendar 对象是否在当前时间之后 \n@Pattern    验证 String 对象是否符合正则表达式的规则\n\n## 多环境切换\n\n```yaml\n# Springboot多环境配置\nserver:\n  port: 8081 # 默认环境\nspring:\n  profiles:\n    active: dev # 指定环境\n\n---\nserver:\n  port: 8082\nspring:\n  profiles: test\n\n---\nserver:\n  port: 8083\nspring:\n  profiles: dev\n```\n\n","tags":["SpringBoot"],"categories":["微服务"]},{"title":"Springboot简介、自动装配原理","url":"/2020/07/09/springboot-01/","content":"\nspringboot是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处：简化开发，约定大于配置，能迅速的开发web应用，几行代码开发一个http接口。<!--more-->\n\n## springboot-helloworld\n\n1、使用IDEA创建一个springboot 项目\n![](springboot-01/1.png)\n\n2、修改项目名称后添加web依赖\n![](springboot-01/2.png)\n\n3、整理项目结构\n![](springboot-01/3.png)\n\n4、在controller包下添加处理请求的程序\n\n```java\n// 原理：自动装配\n@RestController  // 无法返回视图 相当于@Controller + @ResponseBody\npublic class HelloController {\n    // 接口  http://localhost:8080/hello\n    @RequestMapping(\"/hello\")\n    public String doHello(){\n        return \"Hello,world!\";// 在当前页面打印字符串\n    }\n}\n```\n\n整个过程非常的简单，无需像SpringMVC那样进行过多的配置，只需编写处理业务逻辑的代码，即向前端提供接口。\n\n当然，这都源自springboot的自动装配原理。我们所编写的一个个controller不过是一个个组件，springboot已经帮我们装配好了。\n\n**在application.properties中可以修改项目的端口号**\n\n```properties\n# 更改项目端口号\nserver.port=8081\n```\n\n修改banner，在resource中添加banner.txt添加ASCII艺术字，重新启动项目即可！\n\n康康我的○( ＾皿＾)っHiahiahia…\n<img src=\"springboot-01/4.png\" style=\"zoom:80%;\" />\n\n## 自动装配原理\n\n### pom.xml\n\n**父项目依赖，管理项目的资源过滤及插件**\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.3.1.RELEASE</version>\n    <relativePath/> <!-- lookup parent from repository -->\n</parent>\n```\n\n**web模块正常运行所依赖的组件**：tomcat，springmvc等等\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n### 主启动类\n\n```java\n// 标注这是一个springboot的应用\n@SpringBootApplication\npublic class HelloworldApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloworldApplication.class, args);\n    }\n}\n```\n\nSpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\n\nSpringboot的所有自动配置都是在启动的时候扫描并加载：\n![](springboot-01/5.png)\n\nspring.factories：所有的配置文件都在里面，但是不一定生效，要判断条件成立，只要导入了对应的启动器，自动装配才会成功。\n\n1. SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值\n2. 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；\n3. 整个JavaEE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；\n4. 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；\n5. 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；\n\n> SpringApplication.run(HelloworldApplication.class, args);\n>\n> 一共做了两件事，创建SpringApplication对象，在进行初始化的时候找到spring.factories文件中配置的事件监听器并保存；调用run()方法，刚刚保存的监听器根据当前时机触发不同的事件，比如容器的初始化，容器创建完成等。同时也会刷新容器，进行组件的扫描、创建、加载等工作。\n\n**xxxxAutoConfigurartion：**自动配置类；给容器中添加组件\n\n**xxxxProperties:**封装配置文件中相关属性","tags":["SpringBoot"],"categories":["微服务"]},{"title":"SpringMVC核心技术","url":"/2020/07/05/springmvc-04/","content":"\n## 请求转发与重定向\n\nSpringMVC 框架把原来Servlet 中的请求转发和重定向操作进行了封装。\n现在可以使用简单的方式实现转发和重定向。\nforward:表示转发，实现request.getRequestDispatcher(\"xx.jsp\").forward()\nredirect:表示重定向，实现response.sendRedirect(\"xxx.jsp\")<!--more-->\n\n### 1、请求转发\n\n在框架中，使用forward，redirect，与视图解析器无关。\n\n```java\n@Controller\npublic class MyController {\n    /**\n     * 框架的 forward请求转发\n     * @param name\n     * @param age\n     * @return\n     */\n    @RequestMapping(value = \"/doForward\")\n    public ModelAndView doForward(String name,Integer age) {\n        ModelAndView modelAndView = new ModelAndView();\n        modelAndView.addObject(\"msg\",\"Controller请求转发跳转成功~\");\n        modelAndView.addObject(\"name\",name);\n        modelAndView.addObject(\"age\",age);\n        // 使用forward显式转发\n        // 一般用于跳转到视图解析器中没有指定的路径\n        modelAndView.setViewName(\"forward:/WEB-INF/view/show.jsp\");\n        return modelAndView;\n    }\n}\n```\n\n请求页面：\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<% String basePath = request.getContextPath()+\"/\";%>\n<html>\n<head>\n    <title>index.jsp</title>\n    <base href=\"<%=basePath%>\"/>\n</head>\n<body>\n    <form action=\"doForward\" method=\"post\">\n        姓名: <input type=\"text\" name=\"name\"><br/>\n        年龄: <input type=\"number\" name=\"age\"><br/>\n        <input type=\"submit\" value=\"请求转发\">\n    </form>\n</body>\n</html>\n```\n\n转发页面：\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>show.jsp</title>\n</head>\n<body>\n    <p>msg数据：${msg}</p>\n    <p>name：${name}</p>\n    <p>age：${age}</p>\n</body>\n</html>\n```\n\n### 2、重定向\n\n```java\n/**\n * 框架的 redirect 重定向\n * 1、框架会把 Model中的简单数据类型的数据，转换为String使用，作为hello.jsp的get请求参数\n * 目的是在 doRedirect 和 hello.jsp 两次请求之间传递数据\n * 2、在目标 hello.jsp中使用参数集合对象${param}获取请求参数值\n * @param name\n * @param age\n * @return\n */\n@RequestMapping(value = \"/doRedirect\")\npublic ModelAndView doRedirect(String name,Integer age) {\n    ModelAndView modelAndView = new ModelAndView();\n    modelAndView.addObject(\"msg\",\"Controller重定向跳转成功~\");\n    modelAndView.addObject(\"name\",name);\n    modelAndView.addObject(\"age\",age);\n    // 使用redirect重定向\n    modelAndView.setViewName(\"redirect:/hello.jsp\");\n    return modelAndView;\n}\n```\n\n请求页面：\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<% String basePath = request.getContextPath()+\"/\";%>\n<html>\n<head>\n    <title>index.jsp</title>\n    <base href=\"<%=basePath%>\"/>\n</head>\n<body>\n    <form action=\"doRedirect\" method=\"post\">\n        姓名: <input type=\"text\" name=\"name\"><br/>\n        年龄: <input type=\"number\" name=\"age\"><br/>\n        <input type=\"submit\" value=\"重定向\">\n    </form>\n</body>\n</html>\n```\n\n重定向页面：\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>hello.jsp</title>\n</head>\n<body>\n    <p>msg数据：${param.msg}</p>\n    <p>name：${param.name}</p>\n    <p>age：${param.age}</p>\n</body>\n</html>\n```\n\n## 异常处理\n\nspringmvc采用全局异常处理，把controller中的异常处理集中到一个地方。采用aop的思想，将业务处理与异常处理分开，解耦合。\n\n1、为了方便演示，自定义了几个异常类\n\n自定义用户异常类\n\n```java\npublic class MyUserException extends Exception {\n    public MyUserException() {\n        super();\n    }\n\n    public MyUserException(String message) {\n        super(message);\n    }\n}\n```\n\n再定义两个子类继承用户异常类\n\n```java\npublic class AgeException extends MyUserException {\n    public AgeException() {\n        super();\n    }\n\n    public AgeException(String message) {\n        super(message);\n    }\n}\n```\n\n```java\npublic class NameException extends MyUserException {\n    public NameException() {\n        super();\n    }\n\n    public NameException(String message) {\n        super(message);\n    }\n}\n```\n\n2、编写专门处理异常的controller类\n\n```java\n@ControllerAdvice// 控制器增强，增加异常处理功能 需要配置组件扫描器，声明此类所在的包名\npublic class GlobalExceptionHandler {\n    // 定义方法处理异常\n    /**\n     * 处理 name 异常的方法\n     *\n     * @param e controller抛出的异常对象\n     * @return\n     */\n    @ExceptionHandler(value = NameException.class)// 要处理的异常类型\n    public ModelAndView doNameException(Exception e) {\n        // 1、记录异常，记录到数据库，日志文件，记录日志发生的时间，哪个方法发生的异常，异常错误内容\n        // 2、发送通知，把异常信息发送给相关人员\n        // 3、用户友好的提示\n        ModelAndView modelAndView = new ModelAndView();\n        modelAndView.addObject(\"msg\", \"姓名必须是zyz！\");\n        modelAndView.addObject(\"ex\", e);\n        modelAndView.setViewName(\"nameError\");\n        return modelAndView;\n    }\n\n    @ExceptionHandler(value = AgeException.class)// 要处理的异常类型\n    public ModelAndView doAgeException(Exception e) {\n        ModelAndView modelAndView = new ModelAndView();\n        modelAndView.addObject(\"msg\", \"年龄必须小于80！\");\n        modelAndView.addObject(\"ex\", e);\n        modelAndView.setViewName(\"ageError\");\n        return modelAndView;\n    }\n\n    // 处理未知异常  在开发过程中一般像这样使用，编写一个方法就能处理所有的异常了\n    @ExceptionHandler\n    public ModelAndView doOtherException(Exception e) {\n        ModelAndView modelAndView = new ModelAndView();\n        modelAndView.addObject(\"msg\", \"其他异常\");\n        modelAndView.addObject(\"ex\", e);\n        modelAndView.setViewName(\"defaultError\");\n        return modelAndView;\n    }\n}\n```\n\n3、添加组件扫描器，声明处理异常的方法所在的包\n\n```xml\n<!-- 注解驱动-->\n<mvc:annotation-driven/>\n<!-- 处理异常-->\n<context:component-scan base-package=\"com.zyz.handler\"/>\n```\n\n4、编写异常跳转的页面\n\n## 拦截器\n\n拦截器（interceptor），是一种面向切面编程的实现，将多个模块的通用服务进行分离，如权限管理、日志服务，就可以将其各自封装为一个可重用模块。而这些通用服务的具体实现是通过拦截器来完成，比如用户客户端访问一些保密模块都应先通过权限审查的拦截器来进行权限审查，确定用户是否具有该项操作的权限后方能向下执行。在面向切面编程中就是在调用业务方法前调用一个方法，或者在调用业务方法后调用一个方法。\n\n**拦截器的执行时间：**\n\n1、在请求处理之前，也就是controller类中的方法执行之前先被拦截。\n2、在控制器方法执行之后也会执行拦截器。\n3、在请求处理完成后也会执行拦截器。\n\n**拦截器类**\n\n```java\n// 拦截器类，拦截用户请求\npublic class MyInterceptor implements HandlerInterceptor {\n    /**\n     * 预处理方法\n     * 1、在控制器方法之前执行\n     * 2、获取请求信息，验证请求是否符合要求\n     *   可以验证用户是否登录，是否有权限访问某个链接地址 url\n     *   验证失败，可以截断请求，请求不能被处理。\n     *   验证成功，可以放行请求，执行控制器方法\n     * @param request\n     * @param response\n     * @param handler  被拦截的控制器对象\n     * @return  true 表示验证成功，可以执行处理器中方法\n     *          false 表示验证失败，请求到达拦截器就截止了，请求没有被处理\n     * @throws Exception\n     */\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        System.out.println(\"拦截器MyInterceptor的preHandle()\");\n\n        // 给浏览器一个返回结果\n        request.getRequestDispatcher(\"/tips.jsp\").forward(request,response);\n        return false;\n    }\n\n    /**\n     * 后处理方法\n     * 1、在处理器方法之后执行\n     * 2、能够获取到处理器方法中的返回值ModelAndView，并且可以修改\n     * 3、主要对原来的执行结果做修正\n     * @param request\n     * @param response\n     * @param handler 被拦截的控制器对象\n     * @param modelAndView 处理器方法的返回值\n     * @throws Exception\n     */\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        System.out.println(\"拦截器MyInterceptor的postHandle()\");\n    }\n\n    /**\n     * 最后执行的方法\n     * 1、请求处理完成后执行，即对视图进行了forward\n     * 2、一般是做资源回收，释放内存\n     * @param request\n     * @param response\n     * @param handler\n     * @param ex\n     * @throws Exception\n     */\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        System.out.println(\"拦截器MyInterceptor的afterCompletion()\");\n    }\n}\n```\n\n**声明拦截器**\n\n```xml\n<!-- 声明拦截器  可以有多个-->\n<mvc:interceptors>\n    <mvc:interceptor>\n        <!-- 指定拦截器的url-->\n        <mvc:mapping path=\"/**\"/>\n        <!--声明拦截器对象-->\n        <bean class=\"com.zyz.handler.MyInterceptor\" />\n    </mvc:interceptor>\n</mvc:interceptors>\n```\n\npreHandle()返回true时：\n![](SpringMVC-04/1.png)\n\n![](SpringMVC-04/2.png)\n返回false，跳转到提示页面，请求被终止，不会执行preHandle()以后的方法\n\n当有多个拦截器时\n![](SpringMVC-04/3.png)\n\n\n\n> 拦截器与过滤器的区别\n\n过滤器，是在java web中将你传入的request、response提前过滤掉一些信息，或者提前设置一些参数。然后再传入Servlet或Struts2的 action进行业务逻辑处理。比如过滤掉非法url，或者在传入Servlet或Struts2的action前统一设置字符集，或者去除掉一些非法字符。\n\n通俗理解：\n（1）过滤器（Filter）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。\n（2）拦截器（Interceptor）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。\n\n## 文件上传和下载\n\n### 文件上传\n\n1、导入依赖\n\n```xml\n<!-- springmvc-->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.2.5.RELEASE</version>\n</dependency>\n<!--文件上传-->\n<dependency>\n    <groupId>commons-fileupload</groupId>\n    <artifactId>commons-fileupload</artifactId>\n    <version>1.3.3</version>\n</dependency>\n<!--servlet-api导入高版本的-->\n<dependency>\n    <groupId>javax.servlet</groupId>\n    <artifactId>javax.servlet-api</artifactId>\n    <version>4.0.1</version>\n</dependency>\n```\n\n​      2、如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver\n\n```xml\n<!--文件上传配置-->\n<bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n   <!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 -->\n   <property name=\"defaultEncoding\" value=\"utf-8\"/>\n   <!-- 上传文件大小上限，单位为字节（10485760=10M） -->\n   <property name=\"maxUploadSize\" value=\"10485760\"/>\n   <property name=\"maxInMemorySize\" value=\"40960\"/>\n</bean>\n```\n\n3、编写上传文件的表单\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<form action=\"upload2\" enctype=\"multipart/form-data\" method=\"post\">\n    <input type=\"file\" name=\"file\"/>\n    <input type=\"submit\" value=\"upload\">\n</form>\n</body>\n</html>\n```\n\n4、编写处理文件上传的Controller方法\n\n```java\n@Controller\npublic class FileController {\n    @RequestMapping(\"/upload\")\n    //@RequestParam(\"file\") 将name=file控件得到的文件封装成CommonsMultipartFile 对象\n    //批量上传CommonsMultipartFile则为数组即可\n    public String fileUpload(@RequestParam(\"file\") CommonsMultipartFile file, HttpServletRequest request) throws IOException {\n\n        //获取文件名 : file.getOriginalFilename();\n        String uploadFileName = file.getOriginalFilename();\n\n        //如果文件名为空，直接回到首页！\n        if (\"\".equals(uploadFileName)) {\n            return \"redirect:/index.jsp\";\n        }\n        System.out.println(\"上传文件名 : \" + uploadFileName);\n\n        //上传路径保存设置\n        String path = request.getServletContext().getRealPath(\"/upload\");\n        //如果路径不存在，创建一个\n        File realPath = new File(path);\n        if (!realPath.exists()) {\n            realPath.mkdir();\n        }\n        System.out.println(\"上传文件保存地址：\" + realPath);\n\n        InputStream is = file.getInputStream(); //文件输入流\n        OutputStream os = new FileOutputStream(new File(realPath, uploadFileName)); //文件输出流\n\n        //读取写出\n        int len = 0;\n        byte[] buffer = new byte[1024];\n        while ((len = is.read(buffer)) != -1) {\n            os.write(buffer, 0, len);\n            os.flush();\n        }\n        os.close();\n        is.close();\n        return \"redirect:/index.jsp\";\n    }\n\n    /*\n     * 采用file.TransferTo 来保存上传的文件\n     */\n    @RequestMapping(\"/upload2\")\n    public String fileUpload2(@RequestParam(\"file\") CommonsMultipartFile file, HttpServletRequest request) throws IOException {\n\n        //获取文件名 : file.getOriginalFilename();\n        String uploadFileName = file.getOriginalFilename();\n\n        //如果文件名为空，直接回到首页！\n        if (\"\".equals(uploadFileName)) {\n            return \"redirect:/index.jsp\";\n        }\n        //上传路径保存设置\n        String path = request.getServletContext().getRealPath(\"/upload\");\n        File realPath = new File(path);\n        if (!realPath.exists()) {\n            realPath.mkdir();\n        }\n        //上传文件地址\n        System.out.println(\"上传文件保存地址：\" + realPath);\n\n        //通过CommonsMultipartFile的方法直接写文件（注意这个时候）\n        file.transferTo(new File(realPath + \"/\" + file.getOriginalFilename()));\n\n        return \"redirect:/index.jsp\";\n    }\n}\n```\n\n### 文件下载\n\n```java\n@RequestMapping(value=\"/download\")\npublic String downloads(HttpServletResponse response , HttpServletRequest request) throws Exception{\n    //要下载的图片地址\n    String  path = request.getServletContext().getRealPath(\"/upload\");\n    String  fileName = \"基础语法.png\";\n    //1、设置response 响应头\n    response.reset(); //设置页面不缓存,清空buffer\n    response.setCharacterEncoding(\"UTF-8\"); //字符编码\n    response.setContentType(\"multipart/form-data\"); //二进制传输数据\n\n    // 判断浏览器类型\n    String ua = request.getHeader(\"User-Agent\");\n    String str=\"\";\n    // 判断是否是火狐浏览器\n    if (ua.contains(\"Firefox\")) {\n        // 使用下面的格式进行BASE64 编码后\n        str = \"=?utf-8?B?\" + new BASE64Encoder().encode(fileName.getBytes(\"utf-8\")) + \"?=\";\n    } else {\n        // 把中文名进行UTF-8 编码操作\n        str = URLEncoder.encode(fileName, \"UTF-8\");\n    }\n    //设置响应头\n    response.setHeader(\"Content-Disposition\",\n            \"attachment;fileName=\"+ str);\n\n    File file = new File(path,fileName);\n    //2、 读取文件--输入流\n    InputStream input=new FileInputStream(file);\n    //3、 写出文件--输出流\n    OutputStream out = response.getOutputStream();\n\n    byte[] buff =new byte[1024];\n    int index=0;\n    //4、执行 写出操作\n    while((index= input.read(buff))!= -1){\n        out.write(buff, 0, index);\n        out.flush();\n    }\n    out.close();\n    input.close();\n    return \"redirect:/index.jsp\";\n}\n```\n\n```html\n<a href=\"download\">下载</a>\n```\n\n","tags":["SpringMVC"],"categories":["JavaEE"]},{"title":"SSM整合开发","url":"/2020/07/04/springmvc-03/","content":"\nSSM：SpringMVC + Spring +MyBatis\n\nSpringMVC：视图层，用于接收页面请求，显示处理结果\nSpring：业务层，管理service，dao，工具类对象\nMybatis：持久层，访问数据库<!--more-->\n\n用户发起请求--->SpringMVC接收--->Spring中调用的Service对象处理事务--->MyBatis处理数据\n\n## 1、整合的思路\n\n在进行整合时，有两个容器对象\n1、SpringMVC容器，管理Controller控制器对象\n2、Spring容器，管理Service，Dao，工具类对象\n我们要把使用的对象交给合适的容器去创建，管理。\n把Controller还有web开发相关对象交给SpringMVC容器，将这些web使用的对象写在springmvc配置文件中。\n把Service，Dao对象定义在Spring的配置文件中，让Spring管理这些对象。\n\n **两个容器之间的关系：**\nSpringMVC容器是Spring的子容器，类似于Java中的子父类关系------子类可以访问父类的数据。\n即在子容器SpringMVC中的Controller可以访问父容器Spring中的Service对象，就可以实现Controller使用Service对象。\n\n## 2、整合的步骤\n\n使用之前创建好的mybatis数据库，使用student表\n\n### 1、创建maven web项目\n\n### 2、加入依赖\n\nspringmvc，spring，mybatis三个框架的依赖，jackson依赖，mysql驱动，druid连接池，jsp,servlet依赖\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.11</version>\n        <scope>test</scope>\n    </dependency>\n    <!-- servlet依赖-->\n    <dependency>\n        <groupId>javax.servlet</groupId>\n        <artifactId>javax.servlet-api</artifactId>\n        <version>3.1.0</version>\n        <scope>provided</scope>\n    </dependency>\n    <!-- jsp依赖-->\n    <dependency>\n        <groupId>javax.servlet.jsp</groupId>\n        <artifactId>jsp-api</artifactId>\n        <version>2.2.1-b03</version>\n        <scope>provided</scope>\n    </dependency>\n    <!--springmvc依赖-->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.2.5.RELEASE</version>\n    </dependency>\n    <!--事务-->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-tx</artifactId>\n        <version>5.2.5.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.2.5.RELEASE</version>\n    </dependency>\n    <!--jackson-->\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-core</artifactId>\n        <version>2.9.0</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.9.0</version>\n    </dependency>\n    <!--mybatis-->\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>1.3.1</version>\n    </dependency>\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.1</version>\n    </dependency>\n    <dependency>\n        <!--mysql-->\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.19</version>\n    </dependency>\n    <!--druid-->\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid</artifactId>\n        <version>1.1.12</version>\n    </dependency>\n</dependencies>\n\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/java</directory><!--所在的目录-->\n            <includes><!--包括目录下的.properties,.xml 文件都会扫描到-->\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>false</filtering>\n        </resource>\n    </resources>\n    <plugins>\n        <plugin>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.1</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n### 3、写web.xml\n\n1、注册中央处理器DispatcherServlet，\n目的：1、创建springmvc容器对象，才能创建Controller对象；2、创建的是Servlet，才能接收用户的请求。\n\n2、注册监听器ContextLoaderListener，\n目的：创建spring容器对象，才能创建service，dao等对象\n\n3、注册字符集过滤器CharacterEncodingFilter，\n目的：解决post请求乱码\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n<!--  注册中央调度器  -->\n    <servlet>\n        <servlet-name>myweb</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:conf/springmvc.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>myweb</servlet-name>\n        <url-pattern>*.do</url-pattern>\n    </servlet-mapping>\n\n<!-- 注册监听器  用于创建Spring容器   -->\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:conf/application.xml</param-value>\n    </context-param>\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n<!--注册字符集过滤器-->\n    <filter>\n        <filter-name>characterEncodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>utf-8</param-value>\n        </init-param>\n        <init-param>\n            <param-name>forceRequestEncoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n        <init-param>\n            <param-name>forceResponseEncoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>characterEncodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n</web-app>\n```\n\n### 4、创建包\n\n创建controller、service、dao、bean包\n![](SpringMVC-03/1.png)\n\n### 5、写springmvc，spring，mybatis的配置文件\n\n1、springmvc.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/mvc\n       https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <!--springmvc配置文件，声明 controller和它相关的对象-->\n    <context:component-scan base-package=\"com.zyz.controller\" />\n\n    <!--视图解析器-->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\" />\n        <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n\n    <!--注解驱动-->\n    <mvc:annotation-driven/>\n</beans>\n```\n\n2、applicationContext.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd \n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!--  将数据库配置文件写入单独的文件中        -->\n    <context:property-placeholder location=\"classpath:conf/jdbc.properties\"/>\n    <!--声明数据源  用于连接数据库-->\n    <bean id=\"myDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\n          init-method=\"init\" destroy-method=\"close\">\n        <property name=\"url\" value=\"${jdbc.url}\"/>\n        <property name=\"username\" value=\"${jdbc.username}\"/>\n        <property name=\"password\" value=\"${jdbc.password}\"/>\n        <property name=\"maxActive\" value=\"${jdbc.maxActive}\"/>\n    </bean>\n\n    <!--声明mybatis中的SqlSessionFactoryBean 用于创建SqlSessionFactory对象    -->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <!-- set注入，把数据库连接池赋值给dateSource属性-->\n        <property name=\"dataSource\" ref=\"myDataSource\"/>\n        <!-- mybatis主配置文件的位置-->\n        <property name=\"configLocation\" value=\"classpath:conf/mybatisConfig.xml\"/>\n    </bean>\n\n    <!-- 声明Dao类\n         MapperScannerConfigurer:在内部调用getMapper()生成每一个接口的dao代理对象\n         创建好的dao对象放在spring容器中，默认名称为 接口名首字母小写-->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/>\n        <property name=\"basePackage\" value=\"com.zyz.dao\"/>\n    </bean>\n\n    <!--  声明service的注解@Service所在的包名位置  -->\n    <context:component-scan base-package=\"com.zyz.service\"/>\n\n    <!--  事务配置：注解的配置或aspectj的配置  -->\n</beans>\n```\n\n3、mybatisConfig.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<configuration>\n    <!--  注册映射文件  -->\n    <mappers>\n        <package name=\"com.zyz.dao\"/>\n    </mappers>\n\n</configuration>\n```\n\n4、jdbc.properties\n\n```\njdbc.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai\njdbc.username=root\njdbc.password=2824199842\njdbc.maxActive=20\n```\n\n### 6、编写各个包的代码\n\nbean实体类\n\ndao接口和mapper文件\n\n```java\npackage com.zyz.dao;\n\nimport com.zyz.bean.Employee;\n\nimport java.util.List;\n\npublic interface EmployeeDao {\n\n    public int insertEmp(Employee employee);\n    List<Employee> listAllEmps();\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.zyz.dao.EmployeeDao\">\n    <select id=\"listAllEmps\" resultType=\"com.zyz.bean.Employee\">\n        select name,gender,email,dept_id deptId from employee order by id asc\n    </select>\n\n    <insert id=\"insertEmp\">\n        insert into employee(name,gender,email,dept_id) values (#{name},#{gender},#{email},#{deptId})\n    </insert>\n</mapper>\n```\n\nservice及其实现类\n\n```java\npublic interface EmployeeService {\n    int addEmp(Employee employee);\n    List<Employee> listAllEmps();\n}\n```\n\n```java\n@Service\npublic class EmployeeServiceImpl implements EmployeeService {\n\n    // 引用类型自动注入@Autowired,@Resource    dao对象就在Spring容器中\n    @Resource\n    private EmployeeDao employeeDao;\n    @Override\n    public int addEmp(Employee employee) {\n        return employeeDao.insertEmp(employee);\n    }\n\n    @Override\n    public List<Employee> listAllEmps() {\n        return employeeDao.listAllEmps();\n    }\n}\n```\n\ncontroller\n\n```java\n@Controller\n@RequestMapping(\"/employee\")\npublic class EmployeeController {\n\n    @Resource\n    private EmployeeService employeeService;\n\n    // 员工注册\n    @RequestMapping(\"/addEmployee.do\")\n    public ModelAndView addStudent(Employee employee){\n        ModelAndView modelAndView = new ModelAndView();\n        String tips = \"注册失败\";\n        // 调用service\n        int num = employeeService.addEmp(employee);\n        if(num>0){\n            // 注册成功\n            tips=\"注册成功！\";\n        }\n        // 添加数据\n        modelAndView.addObject(\"tips\",tips);\n        // 指定结果页面\n        modelAndView.setViewName(\"result\");\n        return modelAndView;\n    }\n\n    // 员工查询\n    @RequestMapping(\"/listAllEmps.do\")\n    @ResponseBody\n    public List<Employee> listAllEmp(){\n        return employeeService.listAllEmps();\n    }\n}\n```\n\n### 7、编写页面\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%String basePath = request.getContextPath()+\"/\";%>\n<html>\n<head>\n    <title>首页</title>\n    <base href=\"<%=basePath%>\"/>\n\n</head>\n<body>\n    <div align=\"center\">\n        <img src=\"images/yy.jpg\" style=\"width: 200px;height: 200px\">\n        <table>\n            <tr>\n                <td><a href=\"addEmployee.jsp\">注册员工</a></td>\n            </tr>\n            <tr>\n                <td><a href=\"listAllEmployee.jsp\">浏览员工</a></td>\n            </tr>\n        </table>\n    </div>\n</body>\n</html>\n```\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%String basePath = request.getContextPath() + \"/\";%>\n<html>\n<head>\n    <title>注册员工</title>\n    <base href=\"<%=basePath%>\"/>\n</head>\n<body>\n<div align=\"center\">\n    <form action=\"employee/addEmployee.do\" method=\"post\">\n        <table>\n            <tr>\n                <td>姓名：</td>\n                <td><input type=\"text\" name=\"name\"/></td>\n            </tr>\n            <tr>\n                <td>性别：</td>\n                <td><input type=\"radio\" name=\"gender\" value=\"1\"/>男&nbsp;&nbsp;&nbsp;\n                    <input type=\"radio\" name=\"gender\" value=\"0\"/>女\n                </td>\n            </tr>\n            <tr>\n                <td>电子邮箱：</td>\n                <td><input type=\"text\" name=\"email\"/></td>\n            </tr>\n            <tr>\n                <td>部门编号：</td>\n                <td><input type=\"number\" name=\"deptId\"/></td>\n            </tr>\n            <tr>\n                <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n                <td><input type=\"submit\" value=\"注册\"/></td>\n            </tr>\n        </table>\n    </form>\n</div>\n</body>\n</html>\n```\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%String basePath = request.getContextPath() + \"/\";%>\n<html>\n<head>\n    <title>查询所有员工</title>\n    <base href=\"<%=basePath%>\"/>\n    <script type=\"text/javascript\" src=\"js/jquery-3.4.1.js\"></script>\n    <script type=\"text/javascript\">\n        $(function () {\n            // 当前页面dom对象加载后，立即执行\n            loadEmpData();\n        })\n        function loadEmpData() {\n            $.ajax({\n                url: \"employee/listAllEmps.do\",\n                type: \"get\",\n                dataType: \"json\",\n                success: function (data) {\n                    // alert(data);\n                    // 清除旧数据\n                    $(\"#info\").html(\"\");\n                    $.each(data, function (k, v) {\n                        $(\"#info\").append(\"<tr>\")\n                            .append(\"<td>\" + v.name + \"</td>\")\n                            .append(\"<td>\" + v.gender + \"</td>\")\n                            .append(\"<td>\" + v.email + \"</td>\")\n                            .append(\"<td>\" + v.deptId + \"</td>\")\n                    })\n                }\n            })\n        }\n    </script>\n</head>\n<body>\n<div align=\"center\">\n    <table border=\"1\" cellspacing=\"0\">\n        <tr>\n            <th>姓名</th>\n            <th>性别</th>\n            <th>电子邮箱</th>\n            <th>部门编号</th>\n        </tr>\n        <tr>\n            <tbody id=\"info\"></tbody>\n        </tr>\n    </table>\n</div>\n</body>\n</html>\n```\n\n**项目整体结构：**\n![](SpringMVC-03/2.png)\n","tags":["MyBatis","Spring","SpringMVC"],"categories":["JavaEE"]},{"title":"SpringMVC中的控制器","url":"/2020/06/30/springmvc-02/","content":"\n## 1、对请求提交方式的定义\n\n@RequestMapping 请求映射\n属性:\nvalue,表示所匹配请求的URI\nmethod,表示请求的方式：<!--more-->\nget请求: RequestMethod.GET \npost请求: RequestMethod.POST\n\n推荐使用Resful风格的`GetMapping(\"/xxx\")`与`PostMapping(\"xxx\")`\n\n```java\n@RequestMapping(value=\"/doSome\",method= RequestMethod.GET)\npublic ModelAndView doSome(){}\n```\n\n## 2、处理器的请求参数\n\n处理器方法可以包含以下四类参数，这些参数会在系统调用时由系统自动赋值，即程序员可在方法内直接使用。\n➢ HttpServletRequest\n➢ HttpServletResponse\n➢ HttpSession\n➢ 请求中所携带的请求参数\n\n###  1、逐个参数接收\n\n保证请求参数名与该请求处理方法的参数名相同。\n\n```java\n/**\n * 保证请求参数名与该请求处理方法的参数名相同。\n * 框架接收请求参数\n * 1、使用request对象接收请求参数\n * 2、springmvc框架通过DispatcherServlet 调用myController中的doSome()\n * 并按名称对应，把接收到的参数赋值给形参，框架会提供类型自动转换功能\n * @param name\n * @param age\n * @return\n */\n@RequestMapping(value = \"/other.do\",method = RequestMethod.POST)\npublic ModelAndView doOther(String name,Integer age){}\n```\n\n400错误码：客户端错误，表示提交请求时出现了错误\n\n### 2、解决中文乱码\n\n提交请求参数时，get方式没有乱码，post方式出现中文乱码。\n使用框架提供的过滤器解决乱码：\n\n```xml\n<!-- 注册过滤器，解决post请求的乱码问题-->\n<filter>\n    <filter-name>characterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <!--设置项目中的字符编码-->\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n    <!-- 强制请求对象(HttpServletRequest)使用encoding编码值-->\n    <init-param>\n        <param-name>forceRequestEncoding</param-name>\n        <param-value>true</param-value>\n    </init-param>\n    <!-- 强制响应对象(HttpServletResponse)使用encoding编码值-->\n    <init-param>\n        <param-name>forceResponseEncoding</param-name>\n        <param-value>true</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>characterEncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n### 3、@RequestParam校正请求参数\n\n若请求URL 所携带的参数名称与处理方法中指定的参数名不相同时，则需在处理方法参数前，添加一个注解@RequestParam(“请求参数名”)，指定请求URL 所携带参数的名称。\n\n![](SpringMVC-02/1.png) \n\n![](SpringMVC-02/2.png)\n\n### 4、对象参数接收\n\n将处理器方法的参数定义为一个对象，只要保证**请求参数名与这个对象的属性同名**即可。\n\n```java\npublic class Student {\n    private String name;\n    private Integer age;\n\n    public Student() {\n    }\n\n    public Student(String name, Integer age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n```\n\n```java\n@RequestMapping(value = \"/other.do\",method = RequestMethod.POST)\n    public ModelAndView doOther(Student student){\n        ModelAndView modelAndView = new ModelAndView();\n        modelAndView.addObject(\"student\",student);\n        // 指定视图 框架对视图执行forward操作\n        modelAndView.setViewName(\"show\");\n        // 返回modelAndView\n        return modelAndView;\n    }\n```\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>show.jsp</title>\n</head>\n<body>\n    <p>name：${student.name}</p>\n    <p>age：${student.age}</p>\n</body>\n</html>\n```\n\n## 3、处理器方法的返回值\n\n### 1、返回ModelAndView\n\n处理器方法处理完后，需要跳转到其他资源，并且要在跳转的资源之间传递数据。\n\n### 2、返回String\n\n视图跳转，不传递数据。\n\n```java\n@Controller\npublic class MyController {\n    @RequestMapping(value = \"/returnView.do\")\n    public String doRetyrnView(String name,Integer age) {\n        // show  逻辑视图名称。项目中配置了视图解析器\n        // 框架对视图进行forward转发操作\n        return \"show\";\n    }\n}\n```\n\n### 3、返回void\n\n不能表示数据，也不能表示视图。\n在处理ajax的时候，可以使用void返回值。通过HttpServletResponse输出数据，响应ajax请求。\najax请求服务端返回的就是数据，与视图无关。\n\nstep1：服务端向浏览器传回的是JSON 数据，需要使用一个工具类将字符串包装为JSON 格式，所以需要导入JSON 的依赖。\n\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-core</artifactId>\n    <version>2.9.0</version>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.9.0</version>\n</dependency>\n```\n\n step2：引入jquery\n![](SpringMVC-02/3.png)\n\nstep3：发起ajax请求\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>index.jsp</title>\n    <script type=\"text/javascript\" src=\"js/jquery-3.4.1.js\"></script>\n    <script type=\"text/javascript\">\n        $(function(){\n            $(\"#btn\").click(function(){\n                // alert(\"button click\")\n                $.ajax({\n                    url:\"returnVoid-ajax.do\",\n                    data:{\n                        name:\"zyz\",\n                        age:21\n                    },\n                    type:\"post\",\n                    dataType:\"json\",\n                    // resp是服务器端返回的json格式的字符串\n                    // jquery会把json字符串转化为json对象，赋值给形参\n                    success:function(resp){\n                        alert(\"name:\"+resp.name+\" age:\"+resp.age);\n                    }\n                })\n            })\n        })\n    </script>\n</head>\n<body>\n    <button id=\"btn\">发起ajax请求</button>\n</body>\n```\n\nstep4：响应ajax请求\n\n```java\n@RequestMapping(value = \"/returnVoid-ajax.do\")\npublic void doReturnVoidAjax(HttpServletResponse resp, String name, Integer age) throws Exception {\n    System.out.println(\"name:\" + name);\n    System.out.println(\"age:\" + age);\n    // 处理ajax请求  使用json数据格式\n    Student student = new Student(name, age);\n    // 将数据转换为json格式\n    String studentJson=\"\";\n    if (student != null) {\n        ObjectMapper objectMapper = new ObjectMapper();\n         studentJson= objectMapper.writeValueAsString(student);\n        System.out.println(\"student的json格式：\"+studentJson);\n    }\n    // resp输出数据到页面，响应ajax请求\n    resp.setContentType(\"application/json;charset=utf-8\");\n    PrintWriter writer = resp.getWriter();\n    writer.print(studentJson);\n    writer.flush();\n    writer.close();\n}\n```\n\n### 4、返回Object\n\n处理器返回的对象不是作为逻辑视图出现的，而是作为直接在页面显示的数据出现。\n可以使用对象表示数据，响应ajax请求。\n将对象类型转换为json类型 以及 将结果数据输出到页面，springmvc框架都可以自动帮你完成：\n\n**step1:**\n在pom.xml中引入Jackson相关依赖，Jackson工具库用于将Object转换为Json。\n\n```xml\n<dependency>\n\t<groupId>com.fasterxml.jackson.core</groupId>\n\t<artifactId>jackson-core</artifactId>\n\t<version>2.9.0</version>\n</dependency>\n<dependency>\n\t<groupId>com.fasterxml.jackson.core</groupId>\n\t<artifactId>jackson-databind</artifactId>\n\t<version>2.9.0</version>\n</dependency>\n```\n\n**step2:**\n\n在springmvc.xml配置文件中添加注解驱动。\n将Object 数据转化为JSON 数据，需要由消息转换器HttpMessageConverter 完成。而转换器的开启，需要由```<mvc:annotation-driven/>```来完成。\nSpringMVC 使用消息转换器实现请求数据和对象，处理器方法返回对象和响应输出之间的**自动转换**。\n\n当Spring 容器进行初始化过程中，在```<mvc:annotation-driven/>```处创建注解驱动时，默认创建了八个HttpMessageConverter 对象。也就是说，我们注册```<mvc:annotation-driven/>```，就是为了让容器为我们创建HttpMessageConverter 对象。\n\n```xml\n <!--注解驱动-->\n <mvc:annotation-driven/>\n```\n\n**step3:**\n\n修改处理器方法：\n\n```java\n/**\n * 使用框架来处理ajax请求\n * @return Student\n */\n@RequestMapping(value = \"/returnStudent.do\")\n@ResponseBody  // 处理器返回对象转换为json后，通过HttpServletResponse输出给浏览器\npublic Student doReturnStudentAjax(){\n    Student student = new Student(\"zyz\", 19);\n    return student;// 框架会将obj转为json格式\n}\n```\n\n从页面发起ajax请求：\n\n```js\n$(\"#btn02\").click(function(){\n    $.ajax({\n        url:\"returnStudent.do\",\n        type:\"post\",\n        dataType:\"json\",\n        // resp是服务器端返回的json格式的字符串\n        // jquery会把json字符串转化为json对象，赋值给形参\n        success:function(resp){\n            alert(\"name:\"+resp.name+\" age:\"+resp.age);\n        }\n    })\n})\n```\n\n**处理流程：**\n\n1、框架会把处理器返回的Student类型的数据，调用框架中的```ArrayList<HttpMessageConverter>```中每个类的canWrite()方法，检查哪个HttpMessageConverter接口的类能处理Student类型的数据----MappingJackson2HttpMessageConverter\n2、调用实现类中的Write()方法，将student对象转换为json字符串\n3、调用@ResponseBody把转换好的json数据输出到浏览器，ajax处理完成\n\n#### 返回List集合：\n\n```java\n@RequestMapping(value = \"/returnStudents.do\")\n@ResponseBody \npublic List<Student> doReturnStudentAjax() {\n    List<Student> students = new ArrayList<>();\n    Student student1 = new Student(\"张伟1\", 19);\n    Student student2 = new Student(\"张伟2\", 20);\n    Student student3 = new Student(\"张伟3\", 21);\n    students.add(student1);\n    students.add(student2);\n    students.add(student3);\n    return students;\n}\n```\n\n```js\n$(\"#btn03\").click(function(){\n    $.ajax({\n        url:\"returnStudents.do\",\n        type:\"post\",\n        dataType:\"json\",\n        success:function(resp){\n            $.each(resp,function(i,stu) {\n                alert(stu.name+\" \"+stu.age);\n            })\n        }\n    })\n});\n```\n\n#### 返回String\n\nString表示数据，不是视图。\n\n```java\n@RequestMapping(value=\"/returnString.do\", produces=\"text/plain;charset=utf-8\")\n@ResponseBody\npublic String doReturnStringAjax(){\n    return \"返回的字符串~\";\n}\n```\n\n```js\n$(\"#btn04\").click(function () {\n    $.ajax({\n        url:\"returnString.do\",\n        type:\"post\",\n        success:function (resp) {\n            alert(resp);\n        }\n    })\n});\n```\n\n## 4、解读url-pattern标签\n\n```xml\n<servlet-mapping>\n    <servlet-name>springMVC</servlet-name>\n    <url-pattern>*.do</url-pattern>\n</servlet-mapping>\n```\n\n意思是将所有以.do结尾的请求交给中央调度器（框架）处理。\n但是，当提交一些静态资源，例如图片，html页面，js文件的请求时，服务器也会响应。\n因为tomcat本身就能处理一些未映射的静态资源的访问。\n\n**将所有请求都交给框架处理：**\n\n```\n<servlet-mapping>\n    <servlet-name>springMVC</servlet-name>\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n\n处理方式一：转发给服务器处理\n\n```xml\n<!-- 处理静态资源\n框架会创建控制器对象DefaultServletHttpRequestHandler把接收到的请求转发给tomcat来处理静态资源-->\n<mvc:default-servlet-handler />\n```\n\n处理方式二：框架自己处理\n\n将静态资源集中存放到一个文件夹中\n![](SpringMVC-02/4.png)\n\n```xml\n<!--  处理静态资源方式二\n 创建 ResourceHttpServletHandler处理器对象 让这个对象去处理静态资源的请求  不依赖于tomcat\n mapping:访问静态资源的uri  使用通配符 **\n location:静态资源在项目中的位置-->\n <mvc:resources mapping=\"/static/**\" location=\"/static/\"/>\n```\n\n## 5、绝对地址和相对地址\n\n**绝对地址**\n带有协议的地址，在互联网上唯一的\n\n**相对地址**\n没有协议开头的，不能独立使用，需要一个参考地址。通过参考地址+相对地址本身才能指定资源。\n\n在jsp，html 中使用的地址，都是前端页面中的地址，都是相对地址。\n\n在页面中访问地址不加 ” / “ ，访问的是当前页面地址加上链接地址。使用base标签固定参考地址\n![](SpringMVC-02/5.png)\n\n","tags":["SpringMVC"],"categories":["JavaEE"]},{"title":"SpringMVC简介","url":"/2020/06/20/springmvc-01/","content":"\nSpringMVC是Spring框架的一部分。相当于servlet的一个升级。SpringMVC创建控制器对象，放入SpringMVC容器中。<!--more-->\n\n## SpringMVC使用\n\n### 1、在web工程中添加依赖\n\n```xml\n<dependency>\n    <groupId>javax.servlet</groupId>\n    <artifactId>javax.servlet-api</artifactId>\n    <version>3.1.0</version>\n    <scope>provided</scope>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.2.5.RELEASE</version>\n</dependency>\n```\n\n### 2、在web.xml文件中注册中央处理对象DispacherServlet\n\n```xml\n<!--注册springMVC核心依赖DispatcherServlet\n   tomcat服务器启动后创建DispatcherServlet实例对象，同时读取配置文件创建容器对象-->\n<servlet>\n    <servlet-name>springMVC</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <!--自定义读取配置文件的位置-->\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:springmvc.xml</param-value>\n    </init-param>\n    <!-- 在tomcat启动后，创建Servlet对象  数值越小创建越早-->\n    <load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>springMVC</servlet-name>\n    <url-pattern>*.do</url-pattern>\n</servlet-mapping>\n```\n\n### 3、在springmvc配置文件中注册组件扫描器\n\n```xml\n   <!-- 声明组件扫描器 创建Controller对象  -->\n<context:component-scan base-package=\"com.zyz.controller\"/>\n```\n\n### 4、编写MyController处理请求\n\n```java\n@Controller\npublic class MyController {\n    /**\n     * 处理some.do请求\n     * @return 请求处理完成后，返回用户的数据\n     */\n    @RequestMapping(\"/hello\")// 请求映射，将请求地址与请求方法绑定\n    public ModelAndView doSome(){\n        ModelAndView modelAndView = new ModelAndView();\n        // 添加数据 框架请求的最后将数据放入Request域中\n        modelAndView.addObject(\"msg\",\"hello,SpringMVC\");\n        // 指定视图 框架对视图执行forward操作\n        modelAndView.setViewName(\"/show.jsp\");\n        // 返回modelAndView\n        return modelAndView;\n    }\n}\n```\n\n### 5、页面\n\n请求页面：index.jsp\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>index.jsp</title>\n</head>\n<body>\n    <p>第一个springMVC程序</p>\n    <p><a href=\"some.do\">发起some.do请求</a></p>\n</body>\n</html>\n```\n\n跳转页面：show.jsp\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>show.jsp</title>\n</head>\n<body>\n    <p>msg数据：${msg}</p>\n</body>\n</html>\n```\n\n## SpringMVC请求的处理过程\n\n![](SpringMVC-01/1.png)\n\n\nSpringMVC内部执行流程：\n![](SpringMVC-01/4.png)\n\n## 使用视图解析器\n\n在springmvc配置文件中声明视图解析器：\n\n```xml\n<!--  声明springmvc框架中的视图解析器  帮助开发人员设置视图文件的路径  -->\n<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n    <!--前缀  视图文件的路径-->\n    <property name=\"prefix\" value=\"/WEB-INF/view/\" />\n    <!--后缀  视图文件的拓展名-->\n    <property name=\"suffix\" value=\".jsp\"></property>\n</bean>\n```\n\n```java\n// 配置视图解析器后,可直接使用文件名指定视图\nmodelAndView.setViewName(\"show\");\n```\n\n","tags":["SpringMVC"],"categories":["JavaEE"]},{"title":"Web项目环境搭建","url":"/2020/06/20/spring-05/","content":"\n# 实现一个简单的注册功能\n\n项目整体结构：<!--more-->\n![](Spring-05/2.jpg)\n\n## 1、使用maven创建web项目\n\n![](Spring-05/1.jpg)\n\n## 2、添加依赖和插件\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.11</version>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.5.RELEASE</version>\n    </dependency>\n    <!--    Spring事务-->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-tx</artifactId>\n        <version>5.2.5.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.2.5.RELEASE</version>\n    </dependency>\n    <!--    MyBatis依赖-->\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.1</version>\n    </dependency>\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>1.3.1</version>\n    </dependency>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.19</version>\n    </dependency>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid</artifactId>\n        <version>1.1.12</version>\n    </dependency>\n\n    <!-- servlet依赖-->\n    <dependency>\n        <groupId>javax.servlet</groupId>\n        <artifactId>javax.servlet-api</artifactId>\n        <version>3.1.0</version>\n        <scope>provided</scope>\n    </dependency>\n    <!-- jsp依赖-->\n    <dependency>\n        <groupId>javax.servlet.jsp</groupId>\n        <artifactId>jsp-api</artifactId>\n        <version>2.2.1-b03</version>\n        <scope>provided</scope>\n    </dependency>\n\t<!-- 监听器依赖-->\n      <dependency>\n          <groupId>org.springframework</groupId>\n          <artifactId>spring-web</artifactId>\n          <version>5.2.5.RELEASE</version>\n      </dependency>\n</dependencies>\n\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/java</directory><!--所在的目录-->\n            <includes><!--包括目录下的.properties,.xml文件都会扫描到-->\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>false</filtering>\n        </resource>\n    </resources>\n    <plugins>\n        <plugin>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.1</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n将spring-mybatis整合的代码复制到src下\n\n## 3、编写页面\n\nindex.jsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>注册页面</title>\n</head>\n<body>\n    <h1>员工注册</h1>\n    <form action=\"registerServlet\" method=\"post\">\n        <table>\n            <tr>\n                <td>姓名</td>\n                <td><input type=\"text\" name=\"name\"></td>\n            </tr>\n            <tr>\n                <td>性别</td>\n                <td><input type=\"radio\" name=\"gender\" value=\"1\">男\n                <input type=\"radio\" name=\"gender\" value=\"0\">女</td>\n            </tr>\n            <tr>\n                <td>电子邮件</td>\n                <td><input type=\"text\" name=\"email\"></td>\n            </tr>\n            <tr>\n                <td>部门编号</td>\n                <td><input type=\"radio\" name=\"deptId\" value=\"1\">1\n                <input type=\"radio\" name=\"deptId\" value=\"2\">2</td>\n            </tr>\n            <tr>\n                <td colspan=\"2\">\n                    <input type=\"submit\" value=\"注册提交\">\n                </td>\n            </tr>\n        </table>\n    </form>\n</body>\n</html>\n```\n\nregisterSuccess.jsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>注册成功页面</title>\n</head>\n<body>\n    <p>注册成功</p>\n</body>\n</html>\n```\n\n## 4、编写servlet\n\n### 1.在web.xml中注册servlet和listener\n\n```xml\n<!--注册servlet-->\n<servlet>\n    <servlet-name>RegisterServlet</servlet-name>\n    <servlet-class>com.zyz.controller.RegisterServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>RegisterServlet</servlet-name>\n    <url-pattern>/registerServlet</url-pattern>\n</servlet-mapping>\n\n<!--注册监听器ContextLoaderListener  自动创建容器对象，并放入全局作用域ServletContext中\n                                       用户发起请求时可以直接使用对象，不需要再创建容器-->\n<!--自定义配置文件路径  创建容器对象时需要读取配置文件-->\n<context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>classpath:applicationContext.xml</param-value>\n</context-param>\n<listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n```\n\n### 2、编写servlet程序\n\n```java\npublic class RegisterServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String name = request.getParameter(\"name\");\n        String gender = request.getParameter(\"gender\");\n        String email = request.getParameter(\"email\");\n        String deptId = request.getParameter(\"deptId\");\n\n        WebApplicationContext webApplicationContext = null;\n        /*// 从ServletContext中获取容器对象\n        String key = WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE;\n        Object attribute = getServletContext().getAttribute(key);\n        if(attribute!=null){\n            webApplicationContext = (WebApplicationContext) attribute;\n        }*/\n\n       // 使用框架提供的工具类直接从ServletContext中获取创建好容器对象\n        ServletContext servletContext = getServletContext();\n        webApplicationContext = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n\n        // 获取service\n        EmployeeService employeeService = (EmployeeService) webApplicationContext.getBean(\"employeeService\");\n        Employee employee = new Employee(null,name,gender,email,Integer.parseInt(deptId));\n        employeeService.addEmp(employee);\n\n        // 注册成功 页面跳转\n        request.getRequestDispatcher(\"/registerSuccess.jsp\").forward(request,response);\n\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n    }\n}\n```\n\n","tags":["Spring"],"categories":["JavaEE"]},{"title":"Spring事务","url":"/2020/06/19/spring-04/","content":"\nspring提供一种处理事务的统一模型，能使用统一的步骤，完成多种不同数据库访问技术的事务处理。<!--more-->\n![](Spring-04/1.png)\n\n## spring管理事务的三个方面\n\n1、事务管理器\n事务管理器是一个接口和它的众多实现类，由事务管理器对象完成事务的提交和回滚。\n实现类：spring将每一种数据库访问技术对应的事务处理类都创建好了\nmybatis访问数据库-------DateSourceTransactionManager\nhibernate访问数据库---------HibernateTransactionManager\n使用方法：告诉spring你使用的那种数据库的访问方式\n\n```xml\n<bean id=\"  \" class=\"  ...DateSourceTransaction\"/>\n```\n\n2、事务的类型\n（1）事务的隔离级别\n![](Spring-04/2.jpg)\n(2)事务的超时时间\n表示一个方法的最长执行时间，如果方法执行超过了该时间，事务就回滚\n(3)事务的传播行为\nPROPAGATION_REQUIRED：指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是Spring 默认的事务传播行为。\nPROPAGATION_REQUIRES_NEW：总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。\nPROPAGATION_SUPPORTS：指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。\n\n3、spring提交事务，回滚事务的时机\n(1)业务方法执行成功，没有异常抛出，spring会在方法指向后提交事务\n(2)业务方法抛出运行时异常，spring执行回滚\n运行时异常定义：RuntimeException和它的子类都是运行时异常，NullPointException，NumberFormatException\n(3)业务方法抛出非运行时异常，受查异常时，提交事务。\n受查异常：写代码时必须处理的异常，IOException，SQLException\n\n##  事务应用——购买商品项目\n\n实现购买商品，模拟用户下订单，向订单中添加销售记录，从商品表中减少库存。\n\n### 注解方式\n\n1、在spring配置文件添加事务管理器和事务注解驱动\n\n```xml\n<!-- 声明事务管理器   -->\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <!--  连接的数据库，指定数据源 -->\n    <property name=\"dataSource\" ref=\"myDataSource\"/>\n</bean>\n\n<!-- 开启事务注解驱动 告诉spring使用注解管理事务，创建代理对象-->\n<tx:annotation-driven transaction-manager=\"transactionManager\"/>\n```\n\n2、在需要使用事务的方法上添加Transactional注解\n\n```java\npublic class BuyGoodsServiceImpl implements BuyGoodsService {\n    private SaleDao saleDao;\n    private GoodsDao goodsDao;\n\n    public void setSaleDao(SaleDao saleDao) {\n        this.saleDao = saleDao;\n    }\n\n    public void setGoodsDao(GoodsDao goodsDao) {\n        this.goodsDao = goodsDao;\n    }\n\n    /*@Transactional(\n            propagation = Propagation.REQUIRED,// 传播行为(默认)\n            isolation = Isolation.DEFAULT,// 隔离级别(默认)\n            readOnly = false,\n            rollbackFor = { // 发生指定异常时回滚\n                    RuntimeException.class\n            }\n\n    )*/\n    @Transactional\n    @Override\n    public void buy(Integer gid, Integer nums) {\n        System.out.println(\"buy开始\");\n        // 记录销售信息，向sale表中添加记录\n        saleDao.insertSale(new Sale(null, gid, nums));\n\n        Goods goods = goodsDao.selectGoodsById(gid);\n        if (goods == null) {\n            throw new RuntimeException(\"商品不存在！\");\n        }else if(goods.getAmount()<nums){\n            throw new RuntimeException(\"商品不足\");\n        }\n\n        // 更新库存\n        goodsDao.updateGoods(new Goods(gid,null,nums,null));\n\n        System.out.println(\"buy结束\");\n    }\n}\n```\n\n### 使用aspectj完成事务配置\n\n1、添加aspectj依赖\n\n```xml\n<dependency>\n\t<groupId>org.springframework</groupId>\n\t<artifactId>spring-aspects</artifactId>\n\t<version>5.2.5.RELEASE</version>\n</dependency>\n```\n\n2、声明事务管理器\n\n```xml\n<!-- 声明事务管理器   -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <!--  连接的数据库，指定数据源 -->\n        <property name=\"dataSource\" ref=\"myDataSource\"/>\n    </bean>\n```\n\n3、声明业务方法及事务属性\n\n```xml\n<!--  声明业务方法及事务属性（隔离级别、传播行为、超时时间）  -->\n<tx:advice id=\"myAdvice\" transaction-manager=\"transactionManager\">\n    <tx:attributes><!-- name 方法名称  可使用通配符-->\n        <tx:method name=\"buy\" propagation=\"REQUIRED\" isolation=\"DEFAULT\"\n                   rollback-for=\"java.lang.RuntimeException\"/>\n        <!--修改方法  -->\n        <tx:method name=\"update*\"/>\n        <!--删除方法  -->\n        <tx:method name=\"delete*\"/>\n        <!--查询方法  -->\n        <tx:method name=\"query*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n    </tx:attributes>\n</tx:advice>\n```\n\n4、配置aop\n\n```xml\n<!--配置aop  -->\n<aop:config>\n    <!--配置切入点表达式：指定哪些包中的类需要使用事务\n        id:切入点表达式的名称，唯一值\n        expression:切入点表达式，指定哪些类需要使用事务，aspectj会自动创建代理对象-->\n    <aop:pointcut id=\"servicePt\" expression=\"execution(* *..service..*.*(..))\"></aop:pointcut>\n    <!--配置增强器  关联advice和pointcut\n                    advice-ref  通知,tx:advice的id值\n                    pointcut-ref  切入点表达式aop:pointcut的id值 -->\n    <aop:advisor advice-ref=\"myAdvice\" pointcut-ref=\"servicePt\"/>\n</aop:config>\n```","tags":["Spring"],"categories":["JavaEE"]},{"title":"Spring集成MyBatis","url":"/2020/06/16/spring-03/","content":"\n整合的想法：使用spring的ioc核心技术， 把mybatis中使用的对象交给spring统一创建和管理。spring是容器，存放项目中使用的各种对象，例如Service对象，Dao对象，工具类对象等等。<!--more-->\n\n项目结构：\n![](Spring-03/3.jpg)\n\n##  1、在pom.xml文件中添加依赖及插件\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.11</version>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.5.RELEASE</version>\n    </dependency>\n    <!--    Spring事务-->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-tx</artifactId>\n        <version>5.2.5.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.2.5.RELEASE</version>\n    </dependency>\n    <!--    MyBatis依赖-->\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.1</version>\n    </dependency>\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>1.3.1</version>\n    </dependency>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.19</version>\n    </dependency>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid</artifactId>\n        <version>1.1.12</version>\n    </dependency>\n</dependencies>\n```\n\n```xml\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/java</directory><!--所在的目录-->\n            <includes><!--包括目录下的.properties,.xml文件都会扫描到-->\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>false</filtering>\n        </resource>\n    </resources>\n    <plugins>\n        <plugin>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.1</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n## 2、交给spring的mybatis对象\n\n1.数据源\n\n2.SqlSessionFactory对象\n\n3.Dao对象\n\n4.Service对象\n创建spring配置文件applicationContext.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd \n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!--  将数据库配置文件写入单独的文件中        -->\n    <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n    <!--声明数据源  用于连接数据库-->\n    <bean id=\"myDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\n          init-method=\"init\" destroy-method=\"close\">\n        <property name=\"url\" value=\"${jdbc.url}\"/>\n        <property name=\"username\" value=\"${jdbc.username}\"/>\n        <property name=\"password\" value=\"${jdbc.password}\"/>\n        <property name=\"maxActive\" value=\"${jdbc.maxActive}\"/>\n    </bean>\n\n    <!--声明mybatis中的SqlSessionFactoryBean 用于创建SqlSessionFactory对象    -->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <!-- set注入，把数据库连接池赋值给dateSource属性-->\n        <property name=\"dataSource\" ref=\"myDataSource\"/>\n        <!-- mybatis主配置文件的位置-->\n        <property name=\"configLocation\" value=\"classpath:mybatisConfig.xml\"/>\n    </bean>\n\n    <!-- 声明Dao类\n         MapperScannerConfigurer:在内部调用getMapper()生成每一个接口的dao代理对象\n         创建好的dao对象放在spring容器中，默认名称为 接口名首字母小写-->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/>\n        <property name=\"basePackage\" value=\"com.zyz.dao\"/>\n    </bean>\n\n    <!--  声明Service类  -->\n    <bean id=\"employeeService\" class=\"com.zyz.service.impl.EmployeeServiceImpl\">\n        <property name=\"employeeDao\" ref=\"employeeDao\"/>\n    </bean>\n</beans>\n```\n\njdbc.propeties\n\n```properties\njdbc.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai\njdbc.username=root\njdbc.password=2824199842\njdbc.maxActive=20\n```\n\n## 3、mybatis配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<configuration>\n<!--  打印日志-->\n    <settings>\n        <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n    </settings>\n<!--  注册映射文件  -->\n    <mappers>\n        <package name=\"com.zyz.dao\"/>\n    </mappers>\n\n</configuration>\n```\n\n##  4、在dao包下添加sql映射文件\n\n```sql\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.zyz.dao.EmployeeDao\">\n    <insert id=\"insertEmp\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n        insert into employee(name,gender,email,dept_id) values(#{name},#{gender},#{email},#{deptId})\n    </insert>\n\n    <select id=\"selectAllEmps\" resultType=\"com.zyz.bean.Employee\">\n        select id, name, gender, email, dept_id deptId from employee\n    </select>\n</mapper>\n```\n\n## 5、创建service包添加相应的Service接口并实现\n\n```java\npublic interface EmployeeService {\n    public int addEmp(Employee employee);\n\n    public List<Employee> queryAllEmps();\n}\n```\n\n```java\npublic class EmployeeServiceImpl implements EmployeeService {\n\n    private EmployeeDao employeeDao;\n\n    // 使用set注入赋值\n    public void setEmployeeDao(EmployeeDao employeeDao) {\n        this.employeeDao = employeeDao;\n    }\n\n    @Override\n    public int addEmp(Employee employee) {\n\n        return employeeDao.insertEmp(employee);\n    }\n\n    @Override\n    public List<Employee> queryAllEmps() {\n        return employeeDao.selectAllEmps();\n    }\n}\n```\n\n## 6、创建测试类\n\n```java\npublic class TestDao {\n    @Test\n    public void test1() {\n        String config = \"applicationContext.xml\";\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(config);\n        EmployeeDao employeeDao = (EmployeeDao) applicationContext.getBean(\"employeeDao\");\n        Employee employee = new Employee(null,\"zyz001\",'1',\"2824199842@qq.com\",1);\n        employeeDao.insertEmp(employee);\n\n    }\n\n    @Test\n    public void test2() {\n        String config = \"applicationContext.xml\";\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(config);\n        EmployeeDao employeeDao = (EmployeeDao) applicationContext.getBean(\"employeeDao\");\n        List<Employee> employees = employeeDao.selectAllEmps();\n        for (Employee e:employees) {\n            System.out.println(e);\n        }\n\n    }\n}\n```\n\n```java\npublic class TestService {\n    @Test\n    public void test1(){\n        String config = \"applicationContext.xml\";\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(config);\n        EmployeeService employeeService = (EmployeeService) applicationContext.getBean(\"employeeService\");\n        Employee employee = new Employee(null,\"zhangsan\",'1',\"zhangsan@126.com\",1);\n        // 事务自动提交\n        employeeService.addEmp(employee);\n    }\n\n    @Test\n    public void test2(){\n        String config = \"applicationContext.xml\";\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(config);\n        EmployeeService employeeService = (EmployeeService) applicationContext.getBean(\"employeeService\");\n        Employee employee1 = new Employee(null,\"zhangsan\",'1',\"zhangsan@126.com\",1);\n        // 事务自动提交\n        List<Employee> employees = employeeService.queryAllEmps();\n        for(Employee employee:employees){\n            System.out.println(employee);\n        }\n    }\n\n}\n```\n\n","tags":["Spring"],"categories":["JavaEE"]},{"title":"AOP面向切面编程","url":"/2020/06/12/spring-02/","content":"\n## 代理模式\n\n![](Spring-02/1.jpg)\n\n### 静态代理\n\n角色分析：\n抽象角色：一般使用接口或抽象类来实现。一是通过继承被代理类的方式实现其子类，重写父类方法；二是与被代理类实现共同的一个接口。\n真实角色：被代理的角色。\n代理角色：代理真实角色，执行附属操作。\n客户：使用代理角色来进行一些操作。\n代码步骤 ：\n\n1、接口\n\n```java\npublic interface Rent {\n    public void rent();\n}\n```\n\n2、真实角色\n\n```java\npublic class Host implements Rent {\n    @Override\n    public void rent() {\n        System.out.println(\"Host提供租房服务~\");\n    }\n}\n```\n\n3、代理角色\n\n```java\npublic class Proxy {\n\n    private Host host;\n\n    public Proxy() {\n    }\n\n    public Proxy(Host host) {\n        this.host = host;\n    }\n\n    // 代理Host对象提供服务\n    public void rent(){\n        host.rent();\n    }\n}\n```\n\n4、客户端访问代理角色\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        Host host = new Host();\n        Proxy proxy = new Proxy(host);\n        proxy.rent();\n    }\n}\n```\n\n好处：\n1、可以使真实角色的操作更加纯粹，不用去关注其他公共的业务\n2、公共业务交给代理角色，实现业务分工\n3、公共业务发生拓展时，方便集中管理\n缺点：\n一个真实角色就会产生一个代理角色，造成代码量翻倍\n\n### 动态代理\n\n代理类是动态生成的，不是我们直接写好的。交给程序去自动生成代理类（在程序运行期间由JVM根据反射等机制动态的生成源码 ）。\n动态代理分为两大类：基于接口的JDK动态代理；基于类cglib动态代理。\n1、接口\n\n```java\npublic interface UserService {\n    public void add();\n    public void delete();\n    public void update();\n    public void query();\n}\n```\n\n2、真实角色\n\n```java\npublic class UserServiceImpl implements UserService {\n    @Override\n    public void add() {\n        System.out.println(\"添加\");\n    }\n\n    @Override\n    public void delete() {\n        System.out.println(\"删除\");\n    }\n\n    @Override\n    public void update() {\n        System.out.println(\"修改\");\n    }\n\n    @Override\n    public void query() {\n        System.out.println(\"查询\");\n    }\n}\n```\n\n3、实现InvocationHandler接口\n\n```java\npublic class MyInvocationHandler implements InvocationHandler {\n\n    // 目标对象\n    private Object target;\n\n     public void setTarget(Object target) {\n        this.target = target;\n    }\n\n    // 通过代理对象执行方法时，会调用invoke\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"执行了MyInvocationHandler中的invoke方法\");\n        // 执行目标类方法\n        return method.invoke(target,args);\n    }\n}\n```\n\n4、创建并使用代理对象\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        // 创建目标对象\n        UserServiceImpl target = new UserServiceImpl();\n        // 创建MyInvocationHandler对象\n        MYInvocationHandler myInvocationHandler = new MyInvocationHandler();\n        myInvocationHandler.setTarget(target);\n        // 使用Proxy创建代理对象\n        UserService proxy = (UserService) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), myInvocationHandler);\n        // 通过代理执行方法，会调用myIvocationHandler中的invoke方法\n        proxy.add();\n    }\n}\n```\n\n动态代理作用：\n1、在目标类源代码不改变的情况下，增加功能。\n2、减少代码重复\n3、专注业务逻辑代码\n4、解耦合\n\n## AOP定义\n\n面向切面编程，基于动态代理，可使用jdk,cglib两种代理方式。\nSpring会根据具体的Bean是否具有实现接口去选择动态代理方式，如果有接口，使用的是Jdk的动态代理方式，如果没有接口，使用的是cglib的动态代理方式。\nAOP就是动态代理的规范化，供开发人员以统一的方式使用动态代理。\n比如你写了个方法用来做一些事情，但这个事情要求登录用户才能做，你就可以在这个方法执行前验证一下，执行后记录下操作日志，把前后的这些与业务逻辑无关的代码抽取出来放一个类里，这个**类就是切面（Aspect），**这个**被环绕的方法就是切点（Pointcut），**你所做的**执行前执行后的**这些方法统一叫做**增强处理（Advice）。**\n\n面向切面编程实现：\n1、需要在分析项目功能时，找出切面\n2、合理的安排切面的执行时间（目标方法前，还是目标方法后）---->通知注解\n3、合理的安排切面执行的位置（在哪个类，哪个方法增加增强方法）---->切入点表达式\n\n## AOP实现\n\naspectj：开源的aop实现框架\n加入aspectj依赖\n\n```xml\n<dependency>\n\t<groupId>org.springframework</groupId>\n\t<artifactId>spring-aspects</artifactId>\n\t<version>5.2.5.RELEASE</version>\n</dependency>\n```\n\n1、真实对象的接口：\n\n```java\npublic interface SomeService {\n    public void doSome();\n}\n```\n\n2、实现真实对象\n\n```java\npublic class SomeServiceImpl implements SomeService {\n    @Override\n    public void doSome() {\n        System.out.println(\"doSome方法执行\");\n    }\n}\n```\n\n3、切面对象，用于给业务增加功能\n\n```java\n/**\n * @Aspect 表示当前类是切面类。\n * 切面类：用于给业务方法增加功能\n */\n@Aspect\npublic class MyAspect {\n    /**\n     * @Before  前置通知 \n     * 定义方法，实现切面功能\n     * 必须为  public void\n     * 切入点表达式：execution(访问修饰符 返回值 包名.类名.方法名(方法参数) 异常类型)\n     */\n    \n    /**@Pointcut(\"execution(* com.zyz.service..*.pageList*(..))\")\n    *public void pagePointcut(){}\n\n\n    *@Before(\"pagePointcut()\")\n    */\n    @Before(value = \"execution(public void com.zyz.SomeServiceImpl.doSome())\")\n    public void mybefore(JoinPoint joinPoint){// JoinPoint 获取执行方法的信息  必须是第一个参数\n        // 获取方法名\n        System.out.println(joinPoint.getSignature().getName());\n        System.out.println(\"前置通知：\"+new Date());\n    }\n}\n```\n\n> 常用Pointcut表达式\n>\n> **拦截所有公共方法**\n>\n> ```java\n> execution(public * *(..))\n> ```\n>\n> **拦截以set开头的所有方法**\n>\n> ```java\n> execution(* set*(..))\n> ```\n>\n> **拦截类或接口中的所有方法**\n>\n> ```java\n> execution(* com.zyz.service.xxxService.*(..))\n> ```\n>\n> **拦截包中定义的方法，不包含子包中的方法**\n>\n> ```java\n> execution(* com.zyz.service.*.*(..))\n> ```\n>\n> **拦截包或者子包中定义的方法**\n>\n> ```java\n> execution(* com.zyz.service..*.*(..))\n> ```\n\n4、添加配置文件，由spring创建需要的对象\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n<!--    将对象交给spring容器，由spring容器统一创建，管理对象-->\n<!--    声明目标对象-->\n    <bean id=\"someService\" class=\"com.zyz.SomeServiceImpl\"/>\n<!--    声明切面对象-->\n    <bean id=\"myAspection\" class=\"com.zyz.MyAspect\"/>\n<!-- 声明自动代理生成器：使用aspectj框架内部的功能，创建目标对象的代理对象\n    将spring容器中所有目标对象，一次性生成代理对象-->\n    <aop:aspectj-autoproxy />\n</beans>\n```\n\n5、测试\n\n```java\n@Test\npublic void test1() {\n    String config = \"applicationContext.xml\";\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(config);\n    SomeService proxy = (SomeService) applicationContext.getBean(\"someService\");\n    proxy.doSome();\n}\n```\n\n结果：\n![](Spring-02/2.jpg)\n\n后置通知：\n\n```java\n/**\n * returning   目标方法返回值\n * @param res\n */\n@AfterReturning(value = \"execution(public Integer com.zyz.SomeService.doOther(Integer))\",returning = \"res\")\npublic void myAfterReturn(Object res){\n    System.out.println(\"后置通知  获取的返回值为\"+res);\n}\n```\n\n环绕通知：\n\n```java\n/**\n * @param proceedingJoinPoint  固定参数\n */\n@Around(value = \"execution(public Integer com.zyz.SomeService.doAround(Integer))\")\npublic void myAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n    System.out.println(\"环绕通知:目标方法前\");\n    Object res = null;\n    res = proceedingJoinPoint.proceed();// method.invoke()\n    System.out.println(\"目标方法返回值：\"+res);\n    System.out.println(\"环绕通知：目标方法后\");\n}\n```\n\n","tags":["Spring"],"categories":["JavaEE"]},{"title":"Maven","url":"/2020/06/01/maven/","content":"\n## Maven简介\n\nMaven是一款自动化构建工具，专注服务于java平台的项目构建和依赖管理。<!--more-->\n1、maven可以管理jar包及其各个版本，并且可以自动下载和引入项目中\n2、maven可以把jar包依赖的包自动下载并引入项目中\n3、maven可以编译代码，测试代码\n4、打包文件，形成jar文件，或是war文件\n5、部署项目\n项目的构建：构建是面向过程的，包括项目的编译，测试，运行，打包，部署等等\nMaven支持的构建包括：\n1、清理，把之前项目编译的东西删除，为新的编译代码做准备\n2、编译，把程序的源代码编译成可执行文件。（批量进行）\n3、测试，maven可以执行测试程序代码，验证所需的功能是否正确。（批量进行）\n4、报告，生成测试结果文件\n5、打包，把项目中的所有class文件，配置文件等所有资源文件放到一个压缩文件中。\n6、安装，把打包好的文件jar，war安装到本机仓库\n7、部署，把程序安装好可以执行\n\n## Maven核心概念\n\n1、POM：一个文件pom.xml，项目对象模型，把一个项目当作一个模型来使用。控制maven构建项目的过程，管理jar依赖。\n2、约定的目录结构：maven项目的目录和文件的位置都是规定的。\n3、坐标：是一个唯一的字符串，用来表示资源。\n4、依赖管理：管理项目中的jar包\n5、仓库管理：资源存放的位置\n6、生命周期：maven构建项目的过程\n7、插件和目标：执行maven构建的时候用的 工具\n8、继承\n9、聚合\n\n## Maven安装\n\n1、下载解压\n2、配置环境变量\nMAVEN_HOME=d:/apache-maven-3.3.9 \npath=%MAVEN_HOME%/bin;\n3、验证是否安装成功\nmvn -v\n![](Maven/1.jpg)\n\n## Maven工程约定的目录结构\n\n![](Maven/2.jpg)\n\n## 仓库\n\n存放maven使用的jar包和我们项目使用的jar包\n仓库的分类：\n本地仓库：个人计算机上的一个文件夹，存放jar包\n远程仓库：在互联网上使用网络才能使用的仓库。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、中央仓库：最权威的，所有开发人员都共享使用的一个集中仓库\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、中央仓库的镜像：就是中央仓库的备份，分布在各大州，重要城市。减轻中央仓库的压力\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、私人服务器：在公司内部，局域网中使用，不对外使用\n仓库的使用：\nmaven仓库的使用不需要认为参与\nmaven首先查本地仓库--->私服--->镜像--->中央仓库\n\n## POM文件\n\n项目对象模型，Maven 把一个项目的结构和内容抽象成一个模型，在xml 文件中进行声明，以方便进行构建和描述，pom.xml 是Maven 的灵魂。\n1、坐标，唯一值，在互联网中唯一标识一个项目\n\n```xml\n <groupId>com.maven</groupId><!-- 公司域名的倒写-->\n <artifactId>ch01-maven</artifactId> <!-- 自定义项目的名称-->\n <version>1.0-SNAPSHOT</version> <!-- 自定义版本号-->\n```\n\n2、packaging：打包后压缩文件的扩展名，默认为jar，web应用是war\n3、依赖dependencies和dependency，相当于java中的import\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.13</version>\n    </dependency>\n</dependencies>\n```\n\n4、设置属性properties\n5、build：与构建相关的配置信息\n\n## IDEA集成Maven\n\n![](Maven/3.jpg)\n\n![](Maven/4.jpg)\n\n选择Settings for New Projects再次设置\n![](Maven/5.jpg)\n\n##  创建Maven版的普通的java项目\n\n使用模板创建：\n![](Maven/6.jpg)\n\n项目结构：\n![](Maven/7.jpg)\n\n## 创建Maven版的web项目\n\n![](Maven/8.jpg)\n\n项目结构：\n![](Maven/9.jpg)\n\n添加依赖：\n\n```xml\n<dependency>\n    <groupId>javax.servlet</groupId>\n    <artifactId>javax.servlet-api</artifactId>\n    <version>3.1.0</version>\n    <scope>provided</scope>\n</dependency>\n<dependency>\n    <groupId>javax.servlet.jsp</groupId>\n    <artifactId>jsp-api</artifactId>\n    <version>2.1</version>\n    <scope>provided</scope>\n</dependency>\n```\n\n创建一个Servlet程序\n![](Maven/10.jpg)\n\n再运行环境中添加Tomcat服务器：\n![](Maven/11.jpg)\n\n","tags":["Maven"],"categories":["工具"]},{"title":"Spring简介、IOC控制反转","url":"/2020/06/01/spring-01/","content":"\n## Spring简介\n\nSpring用于减轻项目模块之间的管理，类与类之间的管理，帮助开发人员创建对象，管理对象之间的关系。\nSpring核心技术是IOC，AOP。能实现模块之间的，类之间的解耦合。<!--more-->\n优点：\n1、轻量\n2、针对接口编程，IOC解耦合\n3、AOP面向切面编程\n4、方便集成其他各种框架\n\n## Spring体系结构\n\n![](Spring-01/1.jpg)\n\nSpring 框架是一个分层架构，由 7 个定义良好的模块组成。\n\n Spring DAO，  Spring Web，SpringMVC，Spring AOP，Spring上下文，Spring ORM，核心容器。所以，Spring是一系列轻量级Java EE框架的集合。\n\n## IOC控制反转\n\nInversion of control：控制反转，是一个概念，一种思想。\n是指把对象的创建、赋值、管理工作都交给代码以外的容器实现，控制反转就是对对象控制权的转移，由程序代码本身反转到了程序外部容器。\n**控制：**创建对象，对象属性的赋值，对象之间关系的管理。\n**反转：**把原来开发人员管理，创建对象的权力交给代码之外的容器。由容器代替开发人员管理对象。\n正转：由开发人员在代码中，使用new 构造方法 创建对象，开发人员主动管理对象。\n容器：一个服务器软件，一个框架(Spring)。\nIOC的好处：减少对代码的改动，也能实现不同的功能。实现解耦合。\nIOC的体现：Servlet ,Tomcat作为容器创建Servlet对象。\nIOC的技术实现：\nDI(Dependency Injection) 依赖注入，只需要在程序中提供对象的名称，至于对象是如何在容器中创建，赋值，查找都是由容器内部实现的。\nSpring使用DI实现了IOC的功能，Spring底层创建对象使用的是反射机制。\nSpring是一个容器。\n\n## 使用Spring\n\n### 1、使用Maven创建一个普通的java项目\n\n![](Spring-01/2.jpg)\n\n### 2、引入Spring依赖\n\n```xml\n<dependency>\n\t<groupId>org.springframework</groupId>\n\t<artifactId>spring-context</artifactId>\n\t<version>5.2.5.RELEASE</version>\n</dependency>\n```\n\n插件可加可不加，指明jdk版本(前面已经指定)\n\n```xml\n<build>\n\t<plugins>\n\t\t<plugin>\n\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n\t\t\t<version>3.1</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>ss\n\t\t</plugin>\n\t</plugins>\n</build>\n```\n\n### 3、创建Spring配置文件\n\nbean.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n<!-- 声明bean 一个bean标签声明一个对象-->\n    <bean id=\"someService\" class=\"com.zyz.service.impl.SomeServiceImpl\"/>\n</beans>\n```\n\n### 4、使用spring创建对象，调用对象方法\n\n```java\n// 使用Spring 容器创建对象\n@Test\npublic void test2(){\n    // 1、指明spring配置文件名称\n    String config = \"beans.xml\";\n    // 2、创建spring容器对象 ApplicationContext\n    // 从类路径加载配置文件（创建配置文件中的所有对象）\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(config);\n    // 3、从容器中获取对象\n    SomeService someService = (SomeService) applicationContext.getBean(\"someService\");// 通过id\n    someService.doSome();\n}\n```\n\n## di依赖注入\n\n常用的注入方式主要有三种：构造方法注入，setter注入，基于注解的注入。\n\n### 基于xml文件\n\n```xml\n<!--普通类型  set注入-->\n<bean id=\"myPerson\" class=\"com.zyz.bean.Person\">\n    <property name=\"id\" value=\"10001\"/>\n    <property name=\"name\" value=\"Tony\"/>\n    <!-- 引用类型  set注入-->\n    <property name=\"school\" ref=\"mySchool\"/>\n</bean>\n<bean id=\"mySchool\" class=\"com.zyz.bean.School\">\n    <property name=\"id\" value=\"1001\"/>\n    <property name=\"schoolName\" value=\"长江大学\"></property>\n</bean>\n```\n\n```xml\n<!--  构造注入\n constructor-arg  形参属性\n        name   构造方法形参名\n\t\tindex  表示构造方法的参数位置  从左到右0,1,2 ...\n        普通类型   value\n        引用类型   ref\n-->\n<bean id=\"myPersonConstructor\" class=\"com.zyz.bean.Person\">\n    <constructor-arg name=\"id\" value=\"10002\"/>\n    <constructor-arg name=\"name\" value=\"zyz\"/>\n    <constructor-arg name=\"school\" ref=\"mySchool\"/>\n</bean>\n<bean id=\"mySchool\" class=\"com.zyz.bean.School\">\n    <property name=\"id\" value=\"1001\"/>\n    <property name=\"schoolName\" value=\"长江大学\"></property>\n</bean>\n```\n\n```xml\n<bean id=\"myPersonConstructor2\" class=\"com.zyz.bean.Person\">\n    <constructor-arg index=\"0\" value=\"10003\"/>\n    <constructor-arg index=\"1\" value=\"wd\"/>\n    <constructor-arg index=\"2\" ref=\"mySchool2\"/>\n</bean>\n<bean id=\"mySchool2\" class=\"com.zyz.bean.School\">\n    <property name=\"id\" value=\"1002\"/>\n    <property name=\"schoolName\" value=\"清华大学\"/>\n</bean>\n```\n\n![](Spring-01/3.jpg)\n\n引用类型自动注入：\n\n- byName：java类中引用类型属性名 与spring配置文件中的bean标签中的id值相同\n\n\t![](Spring-01/4.jpg)\n\t```xml\n\t<bean id=\"myPersonConstructor2\" class=\"com.zyz.bean.Person\" autowire=\"byName\">\n\t        <constructor-arg index=\"0\" value=\"10003\"/>\n\t        <constructor-arg index=\"1\" value=\"wd\"/>\n\t</bean>\n\t<bean id=\"school\" class=\"com.zyz.bean.School\">\n\t        <property name=\"id\" value=\"1002\"/>\n\t        <property name=\"schoolName\" value=\"清华大学\"/>\n\t</bean>\n\t```\n\t\n- byType：使用byType 方式自动注入，要求：配置文件中被调用者bean 的class 属性指定的类，要与代码中调用者bean 类的某引用类型属性类型同源。即要么相同，要么有is-a 关系（子类，或是实现类）。**但这样的同源的被调用bean 只能有一个。**\n\n\t```java\n\t<bean id=\"person\" class=\"com.zyz.bean.Person\" autowire=\"byType\">\n\t        <property name=\"id\" value=\"10004\"/>\n\t        <property name=\"name\" value=\"wd788\"/>\n\t</bean>\n\t<bean id=\"school\" class=\"com.zyz.bean.School\">\n\t        <property name=\"id\" value=\"1001\"/>\n\t        <property name=\"schoolName\" value=\"北京大学\"/>\n\t </bean>\n\t```\n\n### 基于注解\n\n![](Spring-01/5.jpg)\n\n​\tvalue可省略\n\n在配置文件中声明组件扫描器\n\n```xml\n<!--   声明组件扫描器  组件就是java对象-->\n<context:component-scan base-package=\"com.zyz.component\"/>\n```\n\n另外，Spring 还提供了3 个创建对象的注解：\n@Repository 用于对DAO 实现类进行注解\n@Service 用于对Service 实现类进行注解\n@Controller 用于对Controller 实现类进行注解\n这三个注解与@Component 都可以创建对象，但这三个注解还有其他的含义，@Service创建业务层对象，业务层对象可以加入事务功能，@Controller 注解创建的对象可以作为处理器接收用户的请求。\n@Repository，@Service，@Controller 是对@Component 注解的细化，标注不同层的对象。即持久层对象，业务层对象，控制层对象。\n\n`@Autowired`注入\n\n- byType自动注入（默认）\n  ![](Spring-01/7.jpg)\n\n![](Spring-01/8.jpg)\n\n- byName自动注入（当一个接口有多个实现类时，需要使用次方式注入）\n  ![](Spring-01/9.jpg)\n\n\n![](Spring-01/8.jpg)\n\n**JDK注解`@Resource`自动注入**\n\n- byName（默认）。如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略，如果找不到相同名称的，就会去找相同类型的，再找不到才报错。\n  ![](Spring-01/10.jpg)\n\n## bean 作用域\n\nSpring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说**Spring容器中的Bean本身不具备线程安全的特性**，但是具体还是要结合具体scope的Bean去研究。\n\n1、singleton:单例，默认作用域。\n\n2、prototype:原型，每次创建一个新对象。\n\n3、request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下。\n\n4、session:会话，同一个会话共享一个实例，不同会话使用不用的实例。\n\n5、global-session:全局会话，所有会话共享一个实例。\n\n对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。\n\n如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。\n\n对于有状态的bean，Spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法，比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等。\n**注： Spring容器本身并没有提供线程安全的策略，因此是否线程安全完全取决于Bean本身的特性。**\n\n> 使用ThreadLocal\n\n使得多线程场景下，多个线程对这个单例Bean的成员变量并不存在资源的竞争，因为ThreadLocal为每个线程保存线程私有的数据。\n\n## bean的生命周期\n\n**实例化 -> 属性赋值 -> 初始化 -> 销毁**\n\n1. 通过构造器或工厂方法**创建bean实例**\n\n2. 为bean的**属性设置值**和对其他bean的引用\n\n3. 将bean实例传递给bean后置处理器的**postProcessBeforeInitialization()**方法\n\n4. 调用bean的**初始化**方法\n\n5. 将bean实例传递给bean后置处理器的**postProcessAfterInitialization()**方法\n\n6. 使用bean\n\n7. 当容器关闭时调用bean的**销毁**方法\n   \n\n## Spring 中使用的设计模式\n\n   - **工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。\n   - **代理设计模式** : Spring AOP 功能的实现。\n   - **单例设计模式** : Spring 中的 Bean 默认都是单例的。\n   - **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。\n   - **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。\n   - **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。\n   - **适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。\n   - ……\n\n   \n\n","tags":["Spring"],"categories":["JavaEE"]},{"title":"MyBatis缓存机制","url":"/2020/05/31/mybatis-05/","content":"\nMyBatis系统中默认定义了两级缓存。\n一级缓存和二级缓存：\n1、默认情况下，只有一级缓存开启。(SqlSession级别的缓存，也称本地缓存)\n2、二级缓存需要手动开启和配置。(namespace级别全局缓存)\n3、MyBatis定义了缓存接口Cache，可以通过实现Cache接口自定义二级缓存<!--more-->\n\n## 一级缓存\n\n与数据库<font color=\"red\">同一次会话期间</font>查询到的数据会存放在本地缓存中；\n以后如果需要获取相同的数据，会从缓存中查找，不会访问数据库。\n\n```java\n@Test\npublic void testFirstLevelCache()throws IOException{\n    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();\n    SqlSession sqlSession = null;\n    try{\n        sqlSession = sqlSessionFactory.openSession();\n        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);\n        Employee empById1 = mapper.getEmpById(1);\n        System.out.println(empById1);\n        // 再次查询相同的数据\n        Employee empById2 = mapper.getEmpById(1);\n        System.out.println(empById2);\n        System.out.println(empById1==empById2);// true\n    }finally {\n        if(sqlSession!=null){\n            sqlSession.close();\n        }\n    }\n}\n```\n\n![](MyBatis-05/1.jpg)\n\n可以看见在两次查询中，sql语句只向数据库发送了一次，并且第二次查询得到的对象与第一次完全相同，说明第二次查询访问的是内存中的缓存。\n\n**一级缓存失效的情况：**\n1、不同的SqlSession对应不同的一级缓存；\n2、同一个SqlSession但是查询条件不同；\n3、同一个SqlSession两次查询期间执行了任何一次增删改操作；\n4、同一个SqlSession两次查询期间手动清空了缓存。sqlSession.clearCache()\n\n## 二级缓存\n\n工作机制：\n1、一个会话，查询一条数据，这个数据就会被保存在当前会话的一级缓存中；\n2、**如果会话关闭**，一级缓存中的数据就会保存到二级缓存中。新的会话就会参照二级缓存。\n3、不同的namespace查出的数据会放在自己对应的缓存中(map)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqlSession--------EmployeeMapper-------Employee\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--------DepartmentMapper-------Department\n使用：\n1、开启全局二级缓存\n\n```xml\n<!--  开启全局缓存-->\n<setting name=\"cacheEnabled\" value=\"true\"/>\n```\n\n2、在sql映射文件mapper.xml中配置使用二级缓存\n只需在mapper标签的第一行添加：\n\n```xml\n<!-- cache参数：\n          eviction 缓存回收策略  默认LRU 最近最少使用\n          flushInterval 缓存刷新间隔  默认不刷新\n          readOnly  是否只读 默认flase\n          size 缓存大小\n          type 自定义缓存全类名(实现Cache接口)-->\n<cache></cache>\n```\n\n3、JavaBean对象需要实现序列化Serializable接口\n\n```java\n@Test\npublic void testSecondLevelCache() throws IOException {\n    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();\n    SqlSession sqlSession1 = null;\n    SqlSession sqlSession2 = null;\n    try {\n        sqlSession1 = sqlSessionFactory.openSession();\n        sqlSession2 = sqlSessionFactory.openSession();\n        EmployeeMapper mapper1 = sqlSession1.getMapper(EmployeeMapper.class);\n        EmployeeMapper mapper2 = sqlSession2.getMapper(EmployeeMapper.class);\n        // 使用不同的sqlSession 查询相同的数据\n        Employee empById1 = mapper1.getEmpById(1);\n        System.out.println(empById1);\n        // 关闭会话，数据才会存入二级缓存  从一级缓存转移到二级缓存\n        if (sqlSession1 != null) {\n            sqlSession1.close();\n        }\n        Employee empById2 = mapper2.getEmpById(1);\n        System.out.println(empById2);\n        System.out.println(empById1 == empById2);// false empById1是一级缓存里面的 empById2是从二级缓存中获取的 故地址值不相同\n    } finally {\n        if (sqlSession2 != null) {\n            sqlSession2.close();\n        }\n    }\n}\n```\n\n![](MyBatis-05/2.jpg)\n\n## 关闭缓存\n\n1、cacheEnabled=false：关闭二级缓存，一级缓存还可以使用\n2、每一个select标签都有useCache = \"true\"（默认）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useCache = \"false\"：关闭二级缓存，一级缓存还可以使用\n3、每一个增删改标签默认flushCache=\"true\"，查询标签默认flushCache=\"false\"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;增删改操作执行完后就会清空缓存\n4、sqlSession.clearCache()：只是清空当前sqlSession的一级缓存\n\n## 缓存原理图\n\n![](MyBatis-05/3.jpg)\n\n\n\n","tags":["MyBatis"],"categories":["JavaEE"]},{"title":"MyBatis动态SQL","url":"/2020/05/30/mybatis-04/","content":"\n动态SQL可以极大的简化拼装SQL的操作。类似于JSTL。<!--more-->\n\n## if标签\n\n动态传入查询所需要的条件。\n\n```java\npublic interface EmployeeMapperDynamicSQL {\n    public List<Employee> getEmpByConditionIf(Employee emp);\n}\n```\n\n```xml\n<mapper namespace=\"dao.EmployeeMapperDynamicSQL\">\n   <!-- 查询某些条件没带上可能会出现sql拼接问题\n        1.给where后面加上1=1,以后的条件都and xxx\n        2.去掉where,使用<where></where>标签将所有查询条件包括在内\n            只会去掉前面的多余的and或or-->\n    <select id=\"getEmpByConditionIf\" resultType=\"bean.Employee\">\n        select * from employee\n        <where>\n        <if test=\"id!=null\">id=#{id}</if>\n        <if test=\"name!=null and name.trim()!=''\">and name like #{name}</if>\n        <if test=\"email!=null and email.trim()!=''\">and email=#{email}</if>\n        <if test=\"deptId!=null\"> and dept_id=#{deptId}</if>\n        <if test=\"gender==0 or gender==1\">gender=#{gender}</if>\n        </where>\n    </select>\n</mapper>\n```\n\n ## choose标签\n\n```xml\n<select id=\"getEmpByConditionChoose\" resultType=\"bean.Employee\">\n    select * from employee\n    <where>\n    <!-- 如果带了id就用id查，如果带了name就用name查；只会进入其中一个-->\n        <choose>\n            <when test=\"id!=null\">id=#{id}</when>\n            <when test=\"name!=null\">name like #{name}</when>\n            <when test=\"email!=null\"> emial=#{email}</when>\n            <otherwise>gender=0</otherwise>\n        </choose>\n    </where>\n</select>\n```\n\n## set标签\n\n```xml\n<update id=\"updateEmp\">\n    update employee\n    <set>\n        <if test=\"name!=null and name.trim()!=''\"> name=#{name},</if>\n        <if test=\"email!=null and email.trim()!=''\">email=#{email},</if>\n        <if test=\"deptId!=null\">dept_id=#{deptId},</if>\n        <if test=\"gender==0 or gender==1\">gender=#{gender}</if>\n    </set>\n    where id=#{id}\n</update>\n```\n\n## foreach标签\n\n```java\n// 查询员工 id在给定集合中\npublic List<Employee> getEmpByConditionForeach( @Param(\"ids\") List<Integer> ids);\n```\n\n```xml\n<select id=\"getEmpByConditionForeach\" resultType=\"bean.Employee\">\n    select  * from employee where id in\n    <!-- collection 指定要遍历的集合  list类型的参数会被封装成map\n                    item  将当前遍历出的元素赋值给指定变量\n                    separator  每个元素之间的分割符\n                    #{变量名}  取出遍历的值\n                    open 遍历出所有的结果拼接一个起始字符\n                    close 遍历出所有的结果拼接一个结束字符\n                    index 遍历list时是索引  遍历map时是key-->\n    <foreach collection=\"ids\" item=\"item_id\" separator=\",\" open=\"(\" close=\")\">\n        #{item_id}\n    </foreach>\n</select>\n```\n\n```java\nList<Employee> employeeList = mapper.getEmpByConditionForeach(Arrays.asList(5, 6, 7));\nfor(Employee emp:employeeList){\n    System.out.println(emp);\n}\n```\n\n## foreach批量添加数据\n\n```java\n// 批量添加\npublic void addEmps(@Param(\"emps\") List<Employee> emps);\n```\n\n```xml\n<insert id=\"addEmps\">\n    INSERT INTO employee(name,email,gender,dept_id)\n    VALUES\n    <foreach collection=\"emps\" item=\"emp\" separator=\",\">\n        (#{emp.name},#{emp.email},#{emp.gender},#{emp.deptId})\n    </foreach>\n</insert>\n```\n\n```java\nList<Employee> emps = new ArrayList<Employee>();\nemps.add(new Employee(null,\"wd123\",\"1\",\"wd123@qq.com\",1,new Department()));\nemps.add(new Employee(null,\"lz123\",\"1\",\"lz123@qq.com\",2,new Department()));\nmapper.addEmps(emps);\nsqlSession.commit();\n```","tags":["MyBatis"],"categories":["JavaEE"]},{"title":"MyBatis映射文件","url":"/2020/05/25/mybatis-03/","content":"\n## 实现增删改查功能\n\n映射文件指导着MyBatis如何进行数据库增删改查\n在EmployeeMapper接口中添加增删改查的方法:<!--more-->\n\n```java\npackage dao;\n\npublic interface EmployeeMapper {\n\n    public Employee getEmpById(Integer id);\n\n    public void addEmp(Employee employee);\n\n    public void updateEmp(Employee employee);\n\n    public void deleteEmpById(Integer id);\n}\n```\n\n在映射文件Employee.xml添加相应的sql映射：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!-- namespace  名称空间  1.通过 namespace.id 来确定要执行的sql语句\n                         2.指定为接口的全类名，用于绑定接口\n     id  唯一标识   用于唯一标识一条sql语句\n     result  返回值类型\n     #{id}  从传递过来的参数中取出id值\n-->\n<mapper namespace=\"dao.EmployeeMapper\">\n<!--public Employee getEmpById(Integer id);-->\n    <select id=\"getEmpById\" resultType=\"bean.Employee\">\n        select * from employee where id = #{id}\n    </select>\n<!--public void addEmp(Employee employee);-->\n <!-- parameterType： 参数类型  可以省略\n         mysql支持自增主键，自增主键的获取，mybatis也是利用statement.getGenerateKeys()\n         useGenerateKey=\"true\":使用自增主键获取主键值策略\n         keyProperty:指定对应的主键值类型，也就是mybatis获取到主键后封装给javaBean的哪个属性-->\n    <insert id=\"addEmp\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n        insert into employee(name,gender,email) values(#{name},#{gender},#{email})\n    </insert>\n\n\n<!--public void updateEmp(Employee employee);-->\n    <update id=\"updateEmp\">\n        update employee set name=#{name},gender=#{gender},email=#{email} where id=#{id}\n    </update>\n<!--public void deleteEmpById(Integer id);-->\n    <delete  id=\"deleteEmpById\">\n        delete from employee where id=#{id}\n    </delete>\n</mapper>\n```\n\n测试增删改方法：\n\n```java\n@Test\n    public void test3() throws IOException {\n        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();\n        SqlSession sqlSession = null;\n        try {\n            sqlSession = sqlSessionFactory.openSession();// 不会自动提交\n            EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);\n            // 添加\n            Employee employee = new Employee(null, \"Tom\", \"1\", \"tom@126.com\");\n            mapper.addEmp(employee);\n            // 获取自增主键的值\n            System.out.println(employee.getId());// 5\n            // 修改\n            //mapper.updateEmp(new Employee(2,\"zyz001\",\"1\",\"zyz001@qq.com\"));\n            // 删除\n            //mapper.deleteEmpById(2);\n            // 手动提交\n            sqlSession.commit();\n        } finally {\n            if (sqlSession != null) {\n                sqlSession.close();\n            }\n        }\n    }\n```\n\n## MyBatis参数处理\n\n单个参数：mybatis不会做特殊处理。&nbsp;&nbsp;&nbsp;&nbsp;#{参数名}：取出参数\n多个参数：mybatis会做特殊处理，多个参数封装成一个map\nkey：参数param1,param2...\nvalue：传入的参数值\n#{param1}或#{0}：取出参数值1\n**通过注解明确指定封装类型的key：**\n\n```java\npublic Employee getEmpByIdAndName(@Param(\"id\")Integer id,@Param(\"name\")String name);\n```\n\n#{指定的key}：取出对应的参数值\n**#{}与${}的区别：**\n#{}：是以预编译的形式，将参数设置到sql；防止sql注入\n${}：直接拼装到sql中；有安全问题\n\n## select元素\n\n1、返回list对象\n\n```java\n public List<Employee> getEmpsByNameLike(String name);\n```\n\n```xml\n<select id=\"getEmpsByNameLike\" resultType=\"bean.Employee\">\n    select * from employee where name like #{name}\n</select>\n```\n\n```java\nList<Employee> employeeList = mapper.getEmpsByNameLike(\"%o%\");// 查询name含有o的所有记录\n```\n\n2、返回map对象(单条记录)\n\n```java\n // 返回一条记录的map key:列名   value:对应的值\n    public Map<String,Object> getEmpByIdReturnMap(Integer id);\n```\n\n```xml\n   <select id=\"getEmpByIdReturnMap\" resultType=\"map\">\n        select * from employee where id=#{id}\n    </select>\n```\n\n```java\n Map<String,Object> map = mapper.getEmpByIdReturnMap(1);\n System.out.println(map);// {gender=1, name=zyz001, id=1, email=zyz001@qq.com}\n```\n\n2、返回map对象(多条记录)\n\n```java\n  // 返回多条记录发map key:主键  value:封装后的bean对象\n    // 告诉mybatis封装这个map的时候使用哪个属性作为map的主键\n    @MapKey(\"id\")\n    public Map<Integer,Employee> getEmpsByNameLikeReturnMap(String name);\n```\n\n```xml\n <select id=\"getEmpsByNameLikeReturnMap\" resultType=\"bean.Employee\">\n        select * from employee where name like #{name};\n </select>\n```\n\n```java\n Map<Integer,Employee> employeeMap = mapper.getEmpsByNameLikeReturnMap(\"%o%\");\n```\n\n## resultMap 自定义结果集封装规则\n\n```xml\n<!-- resultMap  自定义结果集规则\n            id  方便引用\n            type 自定义规则的java类型\n            -->\n<resultMap id=\"MyEmp\" type=\"bean.Employee\">\n    <!--  id 指定主键封装规则\n             column  指定哪一列\n             property  指定对应Javabean的哪一个属性-->\n    <id column=\"id\" property=\"id\"/>\n    <!-- 定义普通列封装规则 不指定则自动封装       -->\n    <result column=\"name\" property=\"name\"></result>\n    <result column=\"gender\" property=\"gender\"></result>\n    <result column=\"email\" property=\"email\"></result>\n</resultMap>\n<select id=\"getEmpById\" resultMap=\"MyEmp\">\n    select * from employee where id=#{id}\n</select>\n```\n\n联合查询：级联属性封装结果集 \n\n```xml\n<resultMap id=\"MyEmpAndDept\" type=\"bean.Employee\">\n        <id column=\"id\" property=\"id\"/>\n        <result column=\"name\" property=\"name\"></result>\n        <result column=\"gender\" property=\"gender\"></result>\n        <result column=\"email\" property=\"email\"></result>\n        <result column=\"dept_id\" property=\"deptId\"></result>\n        <result column=\"d_id\" property=\"dept.id\"></result>\n        <result column=\"dept_name\" property=\"dept.departmentName\"></result>\n</resultMap>\n<select id=\"getEmpAndDept\" resultMap=\"MyEmpAndDept\">\n        SELECT e.id id,e.name name,e.gender gender,e.email email,\n        e.dept_id dept_id,d.id d_id,d.dept_name dept_name\n        from employee e,dept d WHERE e.dept_id=d.id AND e.id=#{id};\n</select>\n```\n\n 联合查询：通过association标签封装结果集   \n\n```xml\n<resultMap id=\"MyEmpAndDept2\" type=\"bean.Employee\">\n    <id column=\"id\" property=\"id\"/>\n    <result column=\"name\" property=\"name\"></result>\n    <result column=\"gender\" property=\"gender\"></result>\n    <result column=\"email\" property=\"email\"></result>\n    <result column=\"dept_id\" property=\"deptId\"></result>\n    <!-- association 可以指定联合的javabean对象\n                    property=\"dept\"  指定javabean中的哪个属性是联合的对象\n                    javaType  指定联合对象的类型-->\n    <association property=\"dept\" javaType=\"bean.Department\">\n        <id column=\"d_id\" property=\"id\"/>\n        <result column=\"dept_name\" property=\"departmentName\"></result>\n    </association>\n</resultMap>\n```\n\n分部查询：先查询员工，得到员工信息后再根据员工的部门编号，查询部门信息\n\n```java\npublic interface DepartmentMapper {\n    public Department getDeptById(Integer id);\n}\n```\n\nDepartmentMapper.xml\n\n```xml\n<mapper namespace=\"dao.DepartmentMapper\">\n    <select id=\"getDeptById\" resultType=\"bean.Department\">\n        select id,dept_name departmentName from dept where id=#{id}\n    </select>\n</mapper>\n```\n\nEmployeeMapper.xml\n\n```xml\n<!--  分部查询  可以启动延迟加载-->\n    <resultMap id=\"MyEmpByStep\" type=\"bean.Employee\">\n        <id column=\"id\" property=\"id\"/>\n        <result column=\"name\" property=\"name\"></result>\n        <result column=\"gender\" property=\"gender\"></result>\n        <result column=\"email\" property=\"email\"></result>\n        <result column=\"dept_id\" property=\"deptId\"></result>\n        <!-- 定义关联对象封装规则\n        select 表明当前属性是调用指定的方法后查询出来的结果\n        column  指定哪一列的值传给这个方法-->\n        <association property=\"dept\"\n                     select=\"dao.DepartmentMapper.getDeptById\" column=\"dept_id\">\n        </association>\n    </resultMap>\n    <select id=\"getEmpByIdStep\" resultMap=\"MyEmpByStep\">\n        select * from employee where id=#{id}\n    </select>\n```\n\nmybatis-config.xml\n\n```xml\n<setting>\n\t<!--  开启延迟加载 -->\n\t<setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n\t<!-- 按需加载-->\n\t<setting name=\"aggressiveLazyLoading\" value=\"false\"/>\n</setting>\n```\n\n使用时才进行加载：\n\n```java\nEmployee empByIdStep = mapper.getEmpByIdStep(1);\nSystem.out.println(empByIdStep.getName());\n```\n\n![](MyBatis-03/1.jpg)\n\n```java\nEmployee empByIdStep = mapper.getEmpByIdStep(1);\nSystem.out.println(empByIdStep);\n```\n\n![](MyBatis-03/2.jpg)\n\n**Collection集合类型&嵌套结果集：**\n通过部门编号查找所有在该部门的员工，返回一个List员工集合\n\n```java\nprivate Integer id;\nprivate String departmentName;\nprivate List<Employee> emps;\n```\n\n```java\npublic interface DepartmentMapper {\n    public Department getDeptByIdPlus(Integer id);\n}\n```\n\n```xml\n<resultMap id=\"MyDept\" type=\"bean.Department\">\n    <id column=\"did\" property=\"id\"/>\n    <result column=\"dept_name\" property=\"departmentName\"/>\n    <!-- collection标签用来定义关联集合类型的属性的封装规则\n                    ofType  指定集合里面元素的类型 -->\n    <collection property=\"emps\" ofType=\"bean.Employee\">\n        <id column=\"eid\" property=\"id\"/>\n        <result column=\"name\" property=\"name\"/>\n        <result column=\"gender\" property=\"gender\"/>\n        <result column=\"email\" property=\"email\"/>\n        <result column=\"dept_id\" property=\"deptId\"/>\n    </collection>\n</resultMap>\n<select id=\"getDeptByIdPlus\" resultMap=\"MyDept\">\n    SELECT d.id did ,dept_name,e.id eid,e.`name`,e.gender,e.email,e.dept_id\n    FROM dept d LEFT JOIN employee e ON d.id=e.dept_id WHERE d.id=#{id}\n</select>\n```\n\n```java\nDepartment deptByIdPlus = mapper.getDeptByIdPlus(1);\nSystem.out.println(deptByIdPlus);\nSystem.out.println(deptByIdPlus.getEmps());\n```\n\n![](MyBatis-03/3.jpg)\n\n结果集包含`List<String> orderIds`时\n\n```xml\n<!-- 一对多，变成list<String> -->\n<collection property=\"orderIds\" ofType=\"String\">\n    <constructor>\n        <arg column=\"order_Id\"/>\n    </constructor>\n</collection>\n```\n\n","tags":["MyBatis"],"categories":["JavaEE"]},{"title":"MyBatis全局配置文件","url":"/2020/05/25/mybatis-02/","content":"\n便于在编写xml文件时有提示信息<!--more-->\n![](MyBatis-02/1.jpg)\n\n![](MyBatis-02/2.jpg)\n\n## properties属性\n\n```properties\njdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai\njdbc.username=root\njdbc.password=2824199842\n```\n\n```xml\n<!-- properties标签引入properties配置文件\n     resource 引入类路径下的资源\n     url 引入网络或磁盘路径下的文件-->\n<properties resource=\"dbConfig.properties\">\n</properties>\n```\n\n```xml\n<dataSource type=\"POOLED\">\n    <property name=\"driver\" value=\"${jdbc.driver}\"/>\n    <property name=\"url\" value=\"${jdbc.url}\"/>\n    <property name=\"username\" value=\"${jdbc.username}\"/>\n    <property name=\"password\" value=\"${jdbc.password}\"/>\n</dataSource>\n```\n\n## setting属性\n\nsetting包含一些重要的设置，会改变MyBatis运行时行为\n\n![](MyBatis-02/3.jpg)\n\n```xml\n<!--  settings标签包含很多重要的设置项  -->\n<settings>\n    <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n</settings>\n```\n\n## typeAliases别名处理器\n\n```xml\n<!--typeAliases 别名处理器-->\n<typeAliases>\n<!-- <typeAlias type=\"bean.Employee\" alias=\"emp\"/>-->\n<!-- package 为某个包下的所有类批量起别名\n             name:指定包名 为当前包下的所有后代包的每一个类起一个默认别名-->\n    <package name=\"bean\"/>\n</typeAliases>\n```\n\n![](MyBatis-02/4.jpg)\n\n## typeHandlers类型处理器\n\n无论是MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换成Java 类型。\n![](MyBatis-02/5.jpg)\n\n## plugins插件\n\n插件是MyBatis提供的一个非常强大的机制，我们可以通过插件来修改MyBatis的一些核心行为。插件通过动态代理机制，可以介入四大对象的任何一个方法的执行。\n![](MyBatis-02/6.jpg)\n\n## environment环境配置\n\n```xml\n<!--  配置多个环境  default快速指定环境\n      id  唯一标识环境\n      transactionManager  事务管理器\n      dataSource  数据源\n                自定义数据源：实现DataSourceFactory接口-->\n<environments default=\"development\">\n    <environment id=\"development\">\n        <transactionManager type=\"JDBC\"/>\n        <dataSource type=\"POOLED\">\n            <property name=\"driver\" value=\"${jdbc.driver}\"/>\n            <property name=\"url\" value=\"${jdbc.url}\"/>\n            <property name=\"username\" value=\"${jdbc.username}\"/>\n            <property name=\"password\" value=\"${jdbc.password}\"/>\n        </dataSource>\n    </environment>\n</environments>\n```\n\n**实际开发中我们使用Spring管理数据源，并进行事务控制的配置来覆盖上述配置**\n\n## databaseIdProvider环境\n\nMyBatis 可以根据不同的数据库厂商执行不同的语句。\n![](Mybatis-02/7.jpg)\n\n![](MyBatis-02/8.jpg)\n\n## mapper映射\n\n```xml\n<!-- 将写好的sql映射文件注册到全局配置文件中-->\n <mappers>\n <!-- <mapper resource=\"EmployeeMapper.xml\"/>-->\n<!--  批量注册    xml文件必须与接口文件名相同且在同一个包下  -->\n     <package name=\"dao\"/>\n </mappers>\n```\n\n","tags":["MyBatis"],"categories":["JavaEE"]},{"title":"MyBatis简介及测试","url":"/2020/05/24/mybatis-01/","content":"\n## MyBatis简介\n\nMyBatis是一个半自动化的持久层框架。\nsql与java编码分开，功能边界清晰，一个专注业务，一个专注数据。<!--more-->\n![](MyBatis-01/1.jpg)\n\n## MyBatis的使用\n\n**创建测试的数据库mybatis，再创建一个student表**\n\n![](MyBatis-01/1.png)\n\n### 1、导入MyBatis.jar等相应的数据库连接驱动等相应的包\n\nlog4j.jar用于打印数据库日志（需要编写相应的.xml配置文件）\n![](MyBatis-01/2.jpg)\n\n### 2、创建对应于数据库中表的javaBean对象\n\n```java\npackage bean;\n\npublic class Employee {\n    private Integer id;\n    private String name;\n    private String gender;\n    private String email;\n\n    public Employee() {\n    }\n\n    public Employee(Integer id, String name, String gender, String email) {\n        this.id = id;\n        this.name = name;\n        this.gender = gender;\n        this.email = email;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getGender() {\n        return gender;\n    }\n\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    @Override\n    public String toString() {\n        return \"Employee{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", gender='\" + gender + '\\'' +\n                \", email='\" + email + '\\'' +\n                '}';\n    }\n}\n```\n\n### 3、编写全局配置文件\n\nmybatis-config.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"2824199842\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n   <!-- 将写好的sql映射文件注册到全局配置文件中-->\n    <mappers>\n        <mapper resource=\"EmployeeMapper.xml\"/>\n    </mappers>\n</configuration>\n```\n\n### 4、编写sql映射文件(采用面向接口的方式)\n\n创建dao层，并添加EmployeeDao接口\n\n```java\npackage dao;\n\npublic interface EmployeeDao {\n\n    public Employee getEmpById(Integer id);\n}\n```\n\nEmployeeMapper.xml\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!-- namespace  名称空间  1.通过 namespace.id 来确定要执行的sql语句\n                         2.指定为接口的全类名，用于绑定接口(一般使用这种方式)\n     id  唯一标识   用于唯一标识一条sql语句\n     result  返回值类型\n     #{id}  从传递过来的参数中取出id值\n-->\n<mapper namespace=\"dao.EmployeeDao\">\n    <!-- 将接口中的函数与sql语句绑定-->\n    <select id=\"getEmpById\" resultType=\"bean.Employee\">\n        select * from employee where id = #{id}\n    </select>\n</mapper>\n\n```\n\n### 5、测试是否成功\n\nMybaitTest.java\n\n```java\npackage test;\n\npublic class MyBatisTest {\n\n    public SqlSessionFactory getSqlSessionFactory() throws IOException {\n        String resource = \"mybatis-config.xml\";\n        InputStream inputStream = Resources.getResourceAsStream(resource);\n        // 根据 xml 配置文件创建一个SqlSessionFactory对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        return sqlSessionFactory;\n    }\n\n    @Test\n    public void test2() throws IOException {\n        SqlSession sqlSession = null;\n        try {\n            // 1.获取SqlSessionFactory对象\n            SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();\n            // 2.获取sqlSession对象 用于执行sql语句\n            sqlSession = sqlSessionFactory.openSession();\n            // 3.获取接口实现类对象\n            // 会为接口自动创建一个代理对象  代理对象去执行增删改查方法\n            EmployeeDao mapper = sqlSession.getMapper(EmployeeDao.class);\n            System.out.println(mapper.getClass());// 代理对象\n            // 4.使用接口实现类对象调用接口中的方法\n            Employee emp = mapper.getEmpById(1);\n            System.out.println(emp);\n        } finally {\n            if(sqlSession!=null){\n                sqlSession.close();\n            }\n        }\n    }\n}\n```\n\n","tags":["MyBatis"],"categories":["JavaEE"]},{"title":"Json,AJAX","url":"/2020/05/15/javaweb-08/","content":"\n## json概念\n\njson是一种轻量级的数据交换格式。\n1、比xml更为轻量，解析速度更快。\n2、数据交换指的是客户端和服务器之间业务数据的传递格式。<!--more-->\n\n## json在javaScipt中的使用\n\n```javascript\n// json的定义\nvar jsonObj = {\n\t\t\"key1\":666,\n\t\t\"key2\":\"qwer\",\n\t\t\"key3\":true,\n\t\t\"key4\":[111,\"abc\",false],\n\t\t\"key5\":{\n\t\t\t\"key5_1\":222,\n\t\t\t\"key5_2\":\"aaaa\"\n\t\t},\n\t\t\"key6\":[{\"key6_1_1\":333,\"key6_1_2\":444},{\"key6_2_1\":555}]\n};\nalert(jsonObj);//object  json就是一个对象\nalert(jsonObj.key1);// 666\nalert(jsonObj.key4[1])// abc\n// json对象转字符串\nvar jsonString = JSON.stringify(jsonObj);\nalert(jsonString);符串\n// json字符串转json对象\nvar jsonObj2 = JSON.parse(jsonString);\nalert(jsonObj2);\n```\n\n **json的存在有两种形式：**\n1、对象的形式：操作json中的数据时，使用json对象；\n2、字符串的形式：客户端与服务端之间进行数据交换时，使用json字符串。\nJSON.stringify()：把json对象转换为json字符串 \nJSON.parse()：把json字符串转换为json对象\n\n## json在java中的使用\n\n```java\npublic class JsonTest {\n    // javaBean和json的相互转换\n    @Test\n    public void test1(){\n        Person p1 = new Person(10001,\"Tom\");\n        Gson gson = new Gson();\n        // javaBean转json字符串\n        String p1JsonString = gson.toJson(p1);\n        System.out.println(p1JsonString);\n        // json字符串转javaBean\n        Person p2 = gson.fromJson(p1JsonString, Person.class);\n        System.out.println(p2);\n    }\n\n    @Test\n    // List 和json的相互转换\n    public void test2(){\n        List<Person> personList = new ArrayList<Person>();\n        personList.add(new Person(10001,\"Tom\"));\n        personList.add(new Person(10002,\"Tony\"));\n        personList.add(new Person(10003,\"Nick\"));\n\n        Gson gson = new Gson();\n        // List转json字符串数组\n        String jsonStringArr = gson.toJson(personList);\n        System.out.println(jsonStringArr);\n        // json字符串数组转List\n        // List<Person> personList1 = gson.fromJson(jsonStringArr, new PersonListType().getType());\n        List<Person> personList1 = gson.fromJson(jsonStringArr, new TypeToken<List<Person>>(){}.getType());\n        System.out.println(personList1);\n        System.out.println(personList1.get(1));\n    }\n\n    @Test\n    // Map 和json的相互转换\n    public void test3(){\n        Map<Integer,Person> personMap = new HashMap<Integer, Person>();\n        personMap.put(1,new Person(10001,\"Tom1\"));\n        personMap.put(2,new Person(10002,\"Tom2\"));\n        personMap.put(3,new Person(10003,\"Tom3\"));\n        Gson gson = new Gson();\n        // Map转json字符串集合\n        String jsonStringMap = gson.toJson(personMap);\n        System.out.println(jsonStringMap);\n        // json字符串集合转Map\n        // Map<Integer,Person> personMap1 = gson.fromJson(jsonStringMap, new PersonMapList().getType());\n        Map<Integer,Person> personMap1 = gson.fromJson(jsonStringMap, new TypeToken<Map<Integer,Person>>(){}.getType());\n        System.out.println(personMap1);\n        System.out.println(personMap1.get(1));\n    }\n}\n```\n\n## ajax请求\n\nAJAX是一种创建交互式网页应用的开发技术。\n浏览器通过javaScript异步发起请求，局部更新页面的技术。\n浏览器地址栏不会发生变化；局部更新不会舍弃原来页面的内容。\n\n## 原生AJAX请求\n\n```java\nprotected void javaScriptAjax(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    System.out.println(\"javaScriptAjax调用了~\");\n    Person person = new Person(1,\"Tony\");\n    // 将需要返回给客户端的对象转换为json字符串\n    Gson gson = new Gson();\n    String personJsonString = gson.toJson(person);\n    resp.getWriter().write(personJsonString);\n}\n```\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n    <meta http-equiv=\"pragma\" content=\"no-cache\"/>\n    <meta http-equiv=\"cache-control\" content=\"no-cache\"/>\n    <meta http-equiv=\"Expires\" content=\"0\"/>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <title>Insert title here</title>\n    <script type=\"text/javascript\">\n        // 使用js发起Ajax请求，访问服务器AjaxServlet中的javascriptAjax()\n        function ajaxRequest() {\n// \t\t\t\t1、我们首先要创建XMLHttpRequest \n            var xmlHttpRequest = new XMLHttpRequest();\n// \t\t\t\t2、调用open方法设置请求参数 open(请求方法,请求地址,异步(true))\n            xmlHttpRequest.open(\"GET\", \"http://localhost:8080/11_json/ajaxServlet?action=javaScriptAjax\", true);\n// \t\t\t\t3、在send方法前绑定onreadystatechange事件，处理请求完成后的操作。\n            xmlHttpRequest.onreadystatechange = function () {\n                if (xmlHttpRequest.readyState == 4 && xmlHttpRequest.status == 200) {\n                    // 将json字符串转换为json对象\n                    var jsonObj = JSON.parse(xmlHttpRequest.responseText);\n                    // 将响应数据显示在页面上\n                    document.getElementById(\"div01\").innerHTML = \"编号：\" + jsonObj.id + \"<br/>姓名：\" + jsonObj.name;\n                }\n            }\n            // 4、调用send方法发送请求\n            xmlHttpRequest.send();\n        }\n    </script>\n</head>\n<body>\n<button onclick=\"ajaxRequest()\">ajax request</button>\n<div id=\"div01\">\n</div>\n</body>\n</html>\n```\n\n## jquery中的ajax请求\n\n**$.ajax 方法**\nurl：表示请求的地址\ntype：表示请求的类型GET 或POST 请求\ndata：表示发送给服务器的数据\ndata的格式有两种：\n一：name=value&name=value\n二：{key:value}\nsuccess：请求成功，响应的回调函数\ndataType：响应的数据类型\n常用的响应数据类型有：text、xml、json\n\n```javaScript\n// ajax请求\n$(\"#ajaxBtn\").click(function () {\n    $.ajax({\n        url: \"http://localhost:8080/11_json/ajaxServlet\",\n        data: \"action=jqueryAjax\",\n        type: \"GET\",\n        success: function (data) {\n            alert(\"服务器返回的数据：\" + data);\n            $(\"#msg\").html(\"编号：\" + data.id + \" 姓名：\" + data.name);\n        },\n        dataType: \"json\"\n    });\n});\n```\n\n**$.get 方法和$.post 方法**\nurl： 请求的url 地址\ndata： 发送的数据\ncallback： 成功的回调函数\ntype ：返回的数据类型\n\n```javaScript\n// ajax--get请求\n$(\"#getBtn\").click(function () {\n    $.get(\n        \"http://localhost:8080/11_json/ajaxServlet\",\n        \"action=jqueryAjax\",\n        function (data) {\n            alert(\"服务器返回的数据：\" + data);\n            $(\"#msg\").html(\"编号：\" + data.id + \" 姓名：\" + data.name);\n        },\n        \"json\"\n    );\n});\n\n// ajax--post请求\n$(\"#postBtn\").click(function () {\n    // post请求\n    $.post(\n        \"http://localhost:8080/11_json/ajaxServlet\",\n        \"action=jqueryAjax\",\n        function (data) {\n            alert(\"服务器返回的数据：\" + data);\n            $(\"#msg\").html(\"编号：\" + data.id + \" 姓名：\" + data.name);\n        },\n        \"json\"\n    );\n});\n```\n\n**$.getJSON 方法**\nurl： 请求的url 地址\ndata： 发送给服务器的数据\ncallback： 成功的回调函数\n\n```javaScript\n// ajax--getJson请求\n$(\"#getJSONBtn\").click(function () {\n    $.getJSON(\n        \"http://localhost:8080/11_json/ajaxServlet\",\n        \"action=jqueryAjax\",\n        function (data) {\n            alert(\"服务器返回的数据：\" + data);\n            $(\"#msg\").html(\"编号：\" + data.id + \" 姓名：\" + data.name);\n       });\n});\n```\n\n**表单序列化serialize()**\nserialize()可以把表单中所有的表单项都获取到，并以name1=value1&name2=value2 的形式拼接。\n\n```javaScript\n$(\"#submit\").click(function () {\n     // 把参数序列化\n     var params = $(\"#form01\").serialize();\n     $.getJSON(\"http://localhost:8080/11_json/ajaxServlet\",\n         \"action=serializeAjax&\"+params,\n          function (data) {\n          alert(\"服务器返回的数据：\" + data);\n          $(\"#msg\").html(\"编号：\" + data.id + \" 姓名：\" + data.name);\n     });\n});\n```\n\n\n\n","tags":["JavaWeb"],"categories":["前端"]},{"title":"Filter,ThreadLocal","url":"/2020/05/13/javaweb-07/","content":"\n## Filter过滤器的作用\n\n作用：拦截请求，过滤响应\n拦截请求常见的应用场景：1、权限检查 ；2、日志操作；3、事务管理 ……<!--more-->\n![](javaweb-07/1.png)\n\n### Filter过滤器的使用\n\n1.编写一个类去实现Filter接口\n2.实现过滤  方法doFilter()\n3.到web.xml中配置Filter的拦截路径\n\n```java\n@Override\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    HttpServletRequest req = (HttpServletRequest) request;\n    HttpSession session = req.getSession();\n    Object user = session.getAttribute(\"user\");\n    if(user==null){\n        request.getRequestDispatcher(\"/login.jsp\").forward(request,response);\n        return;\n    }else{\n        // 让程序继续向下访问用户的目标资源\n        chain.doFilter(request,response);\n    }\n}\n```\n\n```xml\n <filter>\n        <filter-name>AdminFilter</filter-name>\n        <filter-class>filter.AdminFilter</filter-class>\n    </filter>\n<!--  配置拦截路径  -->\n    <filter-mapping>\n        <filter-name>AdminFilter</filter-name>\n        <url-pattern>/admin/*</url-pattern>\n    </filter-mapping>\n</web-app>\n```\n\n### Filter的生命周期\n\nFilter生命周期包含的方法：\nWeb工程启动时就创建了：1、构造器方法；2、init 初始化方法\n每次拦截到请求就开始执行：3、doFilter 过滤方法\nWeb工程停止时：4、destory  销毁方法\n\n### FilterConfig类\n\n包含了Filter过滤器的配置信息\nFilterConfig类的作用是获取filter过滤器的配置信息：\n1、获取Filter的名称filter-name的内容\n2、获取Filter中配置的init-param的初始化参数\n3、获取ServletContext对象\n\n### FilterChain过滤器链\n\n![](javaweb-07/2.png)\n\n### Filter的拦截路径\n\n1、精确匹配，拦截的是指定路径的一个资源，请求地址必须是 : ```http://ip:port/工程路径/a.jsp```\n\n```xml\n<filter-mapping>\n        <filter-name>AdminFilter</filter-name>\n        <url-pattern>/admin/a.jsp</url-pattern>\n</filter-mapping>\n```\n\n2、目录匹配，拦截的是目录下的所有资源\n\n```xml\n<filter-mapping>\n        <filter-name>AdminFilter</filter-name>\n        <url-pattern>/admin/*</url-pattern>\n</filter-mapping>\n```\n\n3、后缀名匹配，拦截的是指定后缀名的资源\n\n```xml\n<filter-mapping>\n        <filter-name>AdminFilter</filter-name>\n        <url-pattern>*.html</url-pattern>\n</filter-mapping>\n```\n\nFilter只关心请求地址是否匹配，不关心资源是否存在。\n\n## ThreadLocal的使用\n\n作用：解决线程安全问题。\nThreadLocal可以给当前线程关联一个数据(普通变量，对象，数组，集合)。\nThreadLocald 特点：\n1、ThreadLocal可以为当前线程关联一个数据；(可以像Map一样存取数据，key为当前线程)；\n2、每一个ThreadLoacl对象，只能为当前线程关联一个数据；\n3、每个ThreadLocal对象实例化时，一般都是static类型；\n4、ThreadLocal中保存的数据，在线程销毁后，JVM自动释放。","tags":["JavaWeb"],"categories":["JavaWeb"]},{"title":"二叉树","url":"/2020/05/09/datastructure-06/","content":"\n树结构提高了数据的存储、读取速度。<!--more-->\n\n## 二叉树基本概念\n\n每个节点最多只能有两个子节点，分别为左节点，右节点。\n\n满二叉树：节点数=2^n-1，n为层数。\n\n完全二叉树：如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且**最后一层的叶子节点在左边连续**，**倒数第二层的叶子节点在右边连续**。\n\n## 二叉树的遍历\n\n前序遍历: **先输出父节点**，再遍历左子树和右子树\n\n中序遍历: 先遍历左子树，**再输出父节点**，再遍历右子树\n\n后序遍历: 先遍历左子树，再遍历右子树，**最后输出父节点**\n\n```java\npublic class BinaryTreeDemo {\n    public static void main(String[] args) {\n        // 创建二叉树\n        BinaryTree tree = new BinaryTree();\n        // 创建节点\n        Node root = new Node(1);\n        Node node1 = new Node(2);\n        Node node2 = new Node(3);\n        Node node3 = new Node(4 );\n        // 在树中添加节点\n        tree.setRoot(root);\n        root.setLeft(node1);\n        root.setRight(node2);\n        node1.setLeft(node3);\n        System.out.println(\"前序遍历：\");\n        tree.preOrder();// 1243\n        System.out.println(\"中序遍历：\");\n        tree.midOrder();// 4213\n        System.out.println(\"后序遍历：\");\n        tree.lastOrder();// 4231\n    }\n\n}\n\n// 创建二叉树\nclass BinaryTree {\n    private Node root; // 根节点\n\n    public BinaryTree() {\n    }\n\n    public Node getRoot() {\n        return root;\n    }\n\n    public void setRoot(Node root) {\n        this.root = root;\n    }\n\n    // 前序遍历\n    public void preOrder() {\n        if (root != null) {\n            root.preOrder();\n        } else {\n            System.out.println(\"当前二叉树为空！\");\n        }\n    }\n\n    // 中序遍历\n    public void midOrder() {\n        if (root != null) {\n            root.midOrder();\n        } else {\n            System.out.println(\"当前二叉树为空！\");\n        }\n    }\n\n    // 后序遍历\n    public void lastOrder() {\n        if (root != null) {\n            root.lastOrder();\n        } else {\n            System.out.println(\"当前二叉树为空！\");\n        }\n    }\n\n}\n\n\n// 创建节点\nclass Node {\n    private int no;// 存储的数据\n    private Node left; // 左节点\n    private Node right; // 右节点\n\n    public Node(int no) {\n        this.no = no;\n    }\n\n    public int getNo() {\n        return no;\n    }\n\n    public void setNo(int no) {\n        this.no = no;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    @Override\n    public String toString() {\n        return \"Node{\" +\n                \"no=\" + no +\n                '}';\n    }\n\n    // 前序遍历\n    public void preOrder() {\n        // 打印根节点(当前节点)\n        System.out.println(this);\n        // 递归遍历左子树\n        if (this.left != null) {\n            this.left.preOrder();\n        }\n        // 递归遍历右子树\n        if (this.right != null) {\n            this.right.preOrder();\n        }\n    }\n\n    // 中序遍历\n    public void midOrder() {\n        // 递归遍历左子树\n        if (this.left != null) {\n            this.left.midOrder();\n        }\n        // 打印根节点(当前节点)\n        System.out.println(this);\n        // 递归遍历右子树\n        if (this.right != null) {\n            this.right.midOrder();\n        }\n    }\n\n    // 后续遍历\n    public void lastOrder() {\n        // 递归遍历左子树\n        if (this.left != null) {\n            this.left.lastOrder();\n        }\n        // 递归遍历右子树\n        if (this.right != null) {\n            this.right.lastOrder();\n        }\n        // 打印根节点\n        System.out.println(this);\n    }\n}\n```\n\n## 二叉树查找指定节点\n\n```java\n// 前序遍历查找节点\npublic Node preOrderSearch(int no) {\n    Node node = null;\n    // 判断是否是当前节点\n    if (no == this.no) {\n        return this;\n    }\n    // 判断当前节点的左子节点是否为空，不为空则递归查找\n    if (this.left != null) {\n        node = this.left.preOrderSearch(no);\n    }\n    // 找到后直接返回\n    if (node != null) {\n        return node;\n    }\n    // 判断当前节点的右子节点是否为空，不为空则递归查找\n    if (this.right != null) {\n        this.right.preOrderSearch(no);\n    }\n    return node;\n}\n```\n\n```java\n// 前序遍历查找节点\npublic Node preOrderSearch(int no) {\n    if (root != null) {\n        return root.preOrderSearch(no);\n    } else {\n        System.out.println(\"当前二叉树为空！\");\n        return null;\n    }\n}\n```\n\n## 删除指定节点\n\n```java\n// 删除指定节点\npublic void delete(int no) {\n    // 判断左子节点是否为该节点\n    if (this.left != null && this.left.no == no) {\n        this.left = null;\n        return;\n    }\n    // 判断右子节点是否为该节点\n    if (this.right != null && this.right.no == no) {\n        this.right = null;\n    }\n    // 如果左子节点不是该节点，则对左子树进行递归删除\n    if(this.left!=null){\n        this.left.delete(no);\n    }\n    // 如果右子节点不是该节点，则对右子树进行递归删除\n    if(this.right!=null){\n        this.right.delete(no);\n    }\n}\n```\n\n```java\n// 删除指定节点\npublic void delete(int no) {\n    if (root != null) {\n        if (root.getNo() == no) {\n            root = null;\n        } else {\n            root.delete(no);\n        }\n    } else {\n        System.out.println(\"当前二叉树为空！\");\n    }\n}\n```","tags":["数据结构"],"categories":["数据结构"]},{"title":"递归","url":"/2020/05/08/datastructure-05/","content":"\n递归就是方法自己调用自己，每次调用时传入不同的变量。<!--more-->\n\n递归调用规则：\n1、当程序执行到一个方法时，就会开辟一个独立的空间(栈)\n2、每个空间的数据(局部变量)，是独立的。\n3、如果方法中使用的是引用数据类型的变量，就会共享该变量。\n4、递归必须向退出递归的条件逼近\n5、当一个方法执行完毕，或者遇到return，就会返回到调用它的那个方法中，继续执行该方法。\n\n```java\npublic class RecursionTest {\n    public static void main(String[] args) {\n        test(4);\n        // System.out.println(factorial(3));\n    }\n\n    // 打印\n    public static void test(int n) {\n        if (n > 2) {\n            test(n - 1);\n        }\n        System.out.println(\"n=\" + n);\n\n    }\n\n    // 阶乘\n    public static int factorial(int n){\n        if(n==1){\n            return 1;\n        }else{\n            return factorial(n-1)*n;\n        }\n    }\n}\n```\n\n![](dataStructure-05/1.png)\n\n输出结果：\n\n```\nn=2\nn=3\nn=4\n```\n\n加入else后输出n=2\n\n> 斐波那契数列实现\n\n```java\npublic static int getFeibo(int num){\n    if(num<=0){\n        throw new RuntimeException(\"参数非法！\");\n    }\n    if(num==1||num==2){\n        return 1;\n    }\n    return getFeibo(num-1)+getFeibo(num-2);\n}\n```\n\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"栈","url":"/2020/05/07/datastructure-04/","content":"\n栈是一个**先进后出**的有序列表，是限制表中元素的插入和删除**只能在线性表的同一端**进行的一种特殊线性表。<!--more-->\n\n## 栈的实现\n\n数组模拟栈思路分析图：\n![](dataStructure-04/1.png)\n\n1、定义一个top表示栈顶，初始化top=-1;\n2、入栈，top++;stack[top]=data;\n3、出栈，int value=stack[top];top--;return value;\n\n```java\nimport java.util.Scanner;\n\npublic class ArrayStackDemo {\n    public static void main(String[] args) {\n        ArrayStack arrayStack = new ArrayStack(4);\n        String key = \"\";// 输入内容\n        Boolean loop = true;// 控制是否退出菜单\n        Scanner scanner = new Scanner(System.in);\n        while (loop) {\n            System.out.println(\"遍历栈：show  入栈：push   出栈：pop  退出：exit\");\n            System.out.println(\"请输入：\");\n            key = scanner.next();\n            switch (key) {\n                case \"show\":\n                    arrayStack.list();\n                    break;\n                case \"push\":\n                    System.out.println(\"请输入一个数：\");\n                    int num = scanner.nextInt();\n                    arrayStack.push(num);\n                    break;\n                case \"pop\":\n                    try {\n                        int value = arrayStack.pop();\n                        System.out.println(\"出栈元素：\" + value);\n                        break;\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                case \"exit\":\n                    scanner.close();\n                    loop = false;\n                    break;\n                default:\n                    break;\n            }\n        }\n\n    }\n}\n\n\nclass ArrayStack {\n    private int maxSize;// 栈的大小\n    private int[] stack;// 数组，用于存放栈中的数据\n    private int top = -1;\n\n    // 构造器 初始化栈\n    public ArrayStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.stack = new int[maxSize];\n    }\n\n    // 栈满\n    public boolean isFull() {\n        return top == maxSize - 1;\n    }\n\n    // 栈空\n    public boolean isEmpty() {\n        return top == -1;\n    }\n\n    // 入栈\n    public void push(int value) {\n        // 栈满？\n        if (isFull()) {\n            System.out.println(\"栈满！\");\n            return;\n        }\n        top++;\n        stack[top] = value;\n    }\n\n    // 出栈\n    public int pop() {\n        // 栈空？\n        if (isEmpty()) {\n            // 抛出异常\n            throw new RuntimeException(\"栈空！\");\n        }\n        int value = stack[top];\n        top--;\n        return value;\n    }\n\n    // 遍历栈\n    public void list() {\n        // 从栈顶开始\n        if (isEmpty()) {\n            System.out.println(\"栈空\");\n        }\n        for (int i = top; i >= 0; i--) {\n            System.out.println(stack[i]);\n        }\n    }\n}\n```\n\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"双向链表","url":"/2020/05/05/datastructure-03/","content":"\n## 1.单向链表与双向链表的区别\n\n1、单向链表查找方向只能是一个方向，而双向链表可以向前或向后查找。\n2、单向链表不能自我删除，需要靠赋辅助节点，而双向链表则可以自我删除。<!--more-->\n![](dataStructure-03/1.png)\n\n## 2.双向链表的创建、插入、删除和显示\n\n```java\npackage linkedlist;\n\npublic class DoubleLinkedListDemo {\n\tpublic static void main(String[] args) {\n\t\t// 创建节点\n\t\tHeroNode2 hero1 = new HeroNode2(1000, \"wd\");\n\t\tHeroNode2 hero2 = new HeroNode2(1001, \"lz\");\n\t\tHeroNode2 hero3 = new HeroNode2(1002, \"lp\");\n\t\t// 创建链表\n\t\tDoubleLinkedList heroList2 = new DoubleLinkedList();\n\t\t// 添加节点到 链表\n\t\theroList2.add(hero1);\n\t\theroList2.add(hero2);\n\t\theroList2.add(hero3);\n\t\t// 遍历链表\n\t\theroList2.list(heroList2.head);\n\t\t// 修改节点\n\t\theroList2.update(new HeroNode2(1002, \"gf\"));\n\t\t// 再次遍历\n\t\tSystem.out.println(\"修改后： \");\n\t\theroList2.list(heroList2.head);\n\t\t// 删除id=1001的节点\n\t\theroList2.delete(1000);\n\t\t// 再次遍历\n\t\tSystem.out.println(\"删除id=1000的节点后： \");\n\t\theroList2.list(heroList2.head);\n\t}\n}\n\n//定义HeroNode2 ,每一个HeroNode 对象就是一个节点\nclass HeroNode2 {\n\tpublic int id;\n\tpublic String name;\n\tpublic HeroNode2 pre; // 指向前一个节点\n\tpublic HeroNode2 next;// 指向下一个节点\n\n\tpublic HeroNode2() {\n\t\tsuper();\n\t}\n\n\tpublic HeroNode2(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"HeroNode2 [id=\" + id + \", name=\" + name + \"]\";\n\t}\n}\n\n// 创建一个双向链表的类\nclass DoubleLinkedList {\n\tHeroNode2 head = new HeroNode2();\n\n\t// 从链表尾添加节点\n\tpublic void add(HeroNode2 newNode) {\n\t\tHeroNode2 cur = head;\n\t\t// 找到最后一个节点\n\t\twhile (true) {\n\t\t\tif (cur.next == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t} // 循环结束后cur指向最后一个节点\n\t\t\t// 将新节点添加到链表中\n\t\tcur.next = newNode;\n\t\tnewNode.pre = cur;\n\t}\n\n\t// 遍历双向链表\n\tpublic void list(HeroNode2 head) {\n\t\tif (head.next == null) {\n\t\t\tSystem.out.println(\"链表为空！\");\n\t\t\treturn;\n\t\t}\n\t\tHeroNode2 cur = head.next;\n\t\twhile (true) {\n\t\t\tif (cur == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSystem.out.println(cur);\n\t\t\tcur = cur.next;\n\t\t}\n\t}\n\n\t// 根据id修改节点\n\tpublic void update(HeroNode2 newNode) {\n\t\tif (head.next == null) {\n\t\t\tSystem.out.println(\"链表为空！\");\n\t\t}\n\t\tHeroNode2 cur = head.next;\n\t\twhile (true) {\n\t\t\tif (cur == null) {\n\t\t\t\t// 遍历完成没有找到\n\t\t\t\tSystem.out.println(\"没有id相同的节点~\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (cur.id == newNode.id) {\n\t\t\t\t// 找到该节点\n\t\t\t\tcur.name = newNode.name;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t}\n\n\t// 删除指定id的节点\n\tpublic void delete(int id) {\n\t\tif (head.next == null) {\n\t\t\tSystem.out.println(\"链表位空！\");\n\t\t\treturn;\n\t\t}\n\t\tHeroNode2 cur = head.next;\n\t\twhile (true) {\n\t\t\tif (cur == null) {\n\t\t\t\tSystem.out.println(\"没有找到指定id的节点~\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (cur.id == id) {\n\t\t\t\t// 找到该节点 将待删除节点前后的节点链接到一起\n\t\t\t\tif (cur.next == null) {// 待删除的节点是最后一个节点\n\t\t\t\t\tcur.pre.next = null;\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tcur.pre.next = cur.next;\n\t\t\t\t\tcur.next.pre = cur.pre;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t}\n}\n```\n\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"单链表","url":"/2020/04/30/datastructure-02/","content":"\n## 1、链表介绍\n\n链表是有序的列表，在内存中的存储结构：<!--more-->\n![](dataStructure-02/1.png)\n\n小结:\n1)链表是以节点的方式来存储,是链式存储\n2)每个节点包含 data 域， next 域：指向下一个节点\n3)如图：发现链表的**各个节点不一定是连续存储**.\n4)链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定逻辑结构图：\n![](dataStructure-02/2.png)\n\n## 2、单链表的创建，插入，删除，显示\n\n```java\npackage linkedlist;\n\npublic class SingleLinkedListDemo {\n\tpublic static void main(String[] args) {\n\t\t// 创建节点\n\t\tHeroNode hero1 = new HeroNode(1000, \"wd\");\n\t\tHeroNode hero2 = new HeroNode(1001, \"lz\");\n\t\tHeroNode hero3 = new HeroNode(1002, \"lp\");\n\t\t// 创建链表\n\t\tSingleLinkedList heroList = new SingleLinkedList();\n\t\t// 添加节点\n//\t\theroList.add(hero1);\n//\t\theroList.add(hero3);\n//\t\theroList.add(hero2);\n\n\t\theroList.addByOrder(hero3);\n\t\theroList.addByOrder(hero2);\n\t\theroList.addByOrder(hero1);\n\n\t\t// 修改\n\t\tHeroNode hero4 = new HeroNode(1002, \"ljb\");\n\t\theroList.update(hero4);\n\t\t\n\t\t// 删除\n\t\theroList.delete(1000);\n\t\t// 显示\n\t\theroList.list();\n\t}\n}\n\n// 定义HeroNode ,每一个HeroNode 对象就是一个节点\nclass HeroNode {\n\tpublic int id;\n\tpublic String name;\n\tpublic HeroNode next;// 指向下一个节点\n\n\tpublic HeroNode() {\n\t\tsuper();\n\t}\n\n\tpublic HeroNode(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"HeroNode [id=\" + id + \", name=\" + name + \"]\";\n\t}\n}\n\n// 定义SingleLinkedList\nclass SingleLinkedList {\n\t// 初始化头节点 不存放具体的数据 表示单链表的头\n\tprivate HeroNode head = new HeroNode();\n\n\t// 添加节点到单链表\n\tpublic void add(HeroNode heroNode) {\n\t\t// head节点不能动，需要创建一个临时节点\n\t\tHeroNode temp = head;\n\t\t// 1.找到当前链表的最后一个节点\n\t\twhile (true) {\n\t\t\tif (temp.next == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 如果没有找到，将temp后移\n\t\t\ttemp = temp.next;\n\t\t}\n\t\t// 当退出while循环时，temp就指向了链表的最后\n\t\t// 2.将最后的这个节点指向新的节点\n\t\ttemp.next = heroNode;\n\t}\n\n\t// 显示当前链表\n\tpublic void list() {\n\t\t// 判断链表是否为空\n\t\tif (head.next == null) {\n\t\t\tSystem.out.println(\"链表为空！\");\n\t\t\treturn;\n\t\t}\n\t\t// 遍历输出\n\t\tHeroNode temp = head.next;\n\t\twhile (true) {\n\t\t\tif (temp == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 输出节点信息\n\t\t\tSystem.out.println(temp);\n\t\t\t// 将temp 后移\n\t\t\ttemp = temp.next;\n\t\t}\n\t}\n\n\t// 根据排名添加节点到指定位置\n\tpublic void addByOrder(HeroNode heroNode) {\n\t\t// 1.找到要添加节点的前一个节点\n\t\tHeroNode temp = head;\n\t\tboolean flag = false; // 标识添加的编号是否 存在\n\t\twhile (true) {\n\t\t\tif (temp.next == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (temp.next.id > heroNode.id) {\n\t\t\t\t// 位置找到 就在temp 与 temp.next 之间\n\t\t\t\tbreak;\n\t\t\t} else if (temp.next.id == heroNode.id) {\n\t\t\t\t// 要插入的节点的编号已经存在\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 后移\n\t\t\ttemp = temp.next;\n\t\t}\n\t\t// 判断flag的值\n\t\tif (flag) {\n\t\t\tSystem.out.printf(\"准备插入的英雄的编号%d已经存在，不能添加！\", heroNode.id);\n\t\t} else {\n\t\t\t// 2.插入到链表中 \n\t\t\theroNode.next = temp.next;// 插入节点的next指向原有节点的下一个节点\n\t\t\ttemp.next = heroNode;// 原有节点的next指向插入节点\n\t\t}\n\t}\n\n\t// 根据编号修改节点信息\n\tpublic void update(HeroNode heroNode) {\n\t\t// 判链表是否为空\n\t\tif (head.next == null) {\n\t\t\tSystem.out.println(\"链表为空！\");\n\t\t\treturn;\n\t\t}\n\t\tHeroNode temp = head.next;\n\t\tboolean flag = false; // 判断是否找到\n\t\twhile (true) {\n\t\t\tif (temp == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (temp.id == heroNode.id) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp = temp.next;\n\t\t}\n\t\tif (flag) {\n\t\t\ttemp.name = heroNode.name;\n\t\t} else {\n\t\t\tSystem.out.printf(\"没有找到编号为%d的节点！\", heroNode.id);\n\t\t}\n\t}\n\n    // 根据编号删除节点信息\n\tpublic void delete(int id) {\n\t\tif (head.next == null) {\n\t\t\tSystem.out.println(\"链表为空！\");\n\t\t\treturn;\n\t\t}\n\t\tHeroNode temp = head;\n\t\tboolean flag = false;\n\t\twhile(true) {\n\t\t\t// 1.找到待删除节点的前一个节点\n\t\t\tif(temp.next == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(temp.next.id == id) {\n\t\t\t\tflag =true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp = temp.next;\n\t\t}\n\t\tif(flag) {\n\t\t\t// 2.使原有节点的next指向  待删除节点(temp.next)  的下一个节点\n\t\t\ttemp.next = temp.next.next;\n\t\t}else {\n\t\t\tSystem.out.printf(\"没有找到编号为%d的节点\",id);\n\t\t}\n\t}\n}\n```\n\n## 3、求单链表有效节点个数\n\n```java\npublic int getLength(HeroNode head) {\n\tif (head.next == null) {\n\t\treturn 0;\n\t}\n\tint length = 0;\n\tHeroNode cur = head.next;\n\twhile (cur != null) {\n\t\tlength++;\n\t\tcur = cur.next;\n\t}\n\treturn length;\n}\n```\n\n## 4、查找倒数第 k 个节点\n\n```java\npublic HeroNode findLastIndexNode(HeroNode head, int index) {\n\t// 判断链表是否为空\n\tif (head.next == null) {\n\t\treturn null;\n\t}\n\t// 获取链表长度\n\tint length = this.getLength(head);\n\t// 验证 index 是否合法\n\tif(index<=0||index>length) {\n\t\treturn null;\n\t}\n\t// for循环定位到倒数第 index 个节点\n\tHeroNode cur = head.next;\n\tfor (int i = 0; i < length-index; i++) {\n\t\tcur = cur.next;\n\t}\n\treturn cur;\n}\n```\n\n## 5、单链表的反转\n\n![](dataStructure-02/3.png)\n\n ```java\npublic void reverseList(HeroNode head) {\n\t\tif (head.next == null || head.next.next == null) {\n\t\t\tSystem.out.println(\"链表为空或长度为 1！\");\n\t\t\treturn;\n\t\t}\n\t\tHeroNode cur = head.next;\n\t\tHeroNode next = null;// 指向当前节点的下一个节点\n\t\tHeroNode reverseHead = new HeroNode();\n\t\t// 遍历原来的链表\n\t\twhile (cur != null) {\n\t\t\tnext = cur.next;// 先暂时保存当前节点的下一个节点\n\t\t\tcur.next = reverseHead.next;// 使当前节点指向新链表的第一个节点\n\t\t\treverseHead.next = cur;// 使 新链表的头节点指向当前节点\n\t\t\tcur = next;// 当前节点后移\n\t\t}\n\t\t\n\t\t// 将新链表的第一个节点连接到原来链表的头节点上\n\t\thead.next = reverseHead.next;\n\t}\n ```\n\n## 6、逆序打印单链表\n\n```java\npublic void reversePrint(HeroNode head) {\n\t\tif(head.next == null) {\n\t\t\tSystem.out.println(\"链表为空！\");\n\t\t\treturn;\n\t\t}\n\t\t// 创建一个栈\n\t\tStack<HeroNode> stack = new Stack<HeroNode>();\n\t\t// 创建一个指针用于遍历\n\t\tHeroNode cur = head.next;\n\t\t// 遍历单链表\n\t\twhile(cur != null) {\n\t\t\tstack.push(cur);// 将遍历的节点入栈\n\t\t\tcur = cur.next;// 后移\n\t\t}\n\t\twhile(stack.size()>0) {\n\t\t\tSystem.out.println(stack.pop());\n\t\t}\n}\n```\n\n\n\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"队列","url":"/2020/04/28/datastructure-01-2/","content":"\n## 队列\n\n队列是一个有序列表，可以用数组和链表来实现。\n遵循**先进先出**原则。<!--more-->\n![](DataStructure-01-2/3.png)\n\n### 1、数组模拟队列\n\n```java\npublic class ArrayQueueDemo {\n\tpublic static void main(String[] args) {\n\t\tArrayQueue queue = new ArrayQueue(3);\n\t\tchar key = ' ';\n\t\tScanner in = new Scanner(System.in);\n\t\tboolean loop = true;\n\t\twhile(loop) {\n\t\t\tSystem.out.println(\"s:显示队列   a:添加数据到队列   g:取出数据  h:查看队列头  e:退出\");\n\t\t\tSystem.out.println(\"请输入要执行的操作：\");\n\t\t\tkey = in.next().charAt(0);\n\t\t\tswitch (key) {\n\t\t\tcase 's':\n\t\t\t\tqueue.showQueue();\n\t\t\t\tSystem.out.println();\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tSystem.out.print(\"请输入一个数字：\");\n\t\t\t\tint num = in.nextInt();\n\t\t\t\tqueue.addQueue(num);\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\ttry {\n\t\t\t\t\tint num1 = queue.getQueue();\n\t\t\t\t\tSystem.out.println(\"取出的数据为：\"+ num1);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.getMessage();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\ttry {\n\t\t\t\t\tint head = queue.headQueue();\n\t\t\t\t\tSystem.out.println(\"队列头为：\"+ head);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.getMessage();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tloop = false;\n\t\t\t\tSystem.out.println(\"程序退出\");\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\t\t\n\t\t}\n\t}\n}\n\n// 使用数组模拟队列---编写一个ArrayQueue类\nclass ArrayQueue {\n\tprivate int maxSize;// 表示数组的最大容量\n\tprivate int front;// 队列头\n\tprivate int rear;// 队列尾\n\tprivate int[] arr;// 用于存放数据，模拟队列\n\t\n\t// 创建队列的构造器\n\tpublic ArrayQueue(int maxSize){\n\t\tthis.maxSize = maxSize;\n\t\tthis.arr = new int [maxSize];\n\t\tthis.front = -1;// 指向队列头部的前一个位置\n\t\tthis.rear = -1;// 指向队列尾部\n\t}\n\t\n\t// 判断队列是否满\n\tpublic boolean isFull() {\n\t\treturn rear == maxSize-1;\n\t}\n\t\t\n\t// 判断队列是否为空\n\tpublic boolean isEmpty() {\n\t\treturn front == rear;\n\t}\n\t\n\t// 添加数据到队列，入队列\n\tpublic void addQueue(int num) {\n\t\t// 判断队列是否已满\n\t\tif(isFull()) {\n\t\t\tSystem.out.println(\"队列已满！\");\n\t\t\treturn ;\n\t\t}else {\n\t\t\trear++; // 让rear后移\n\t\t\tarr[rear]=num;\n\t\t}\n\t}\n\t\n\t// 获取队列数据，出队列\n\tpublic int getQueue() {\n\t\t// 判断队列是否为空\n\t\tif(isEmpty()) {\n\t\t\tthrow new RuntimeException(\"队列为空！\");// 抛出异常\n\t\t}\n\t\tfront++;\n\t\treturn arr[front];\n\t}\n\t\n\t// 显示队列所有数据\n\tpublic void showQueue() {\n\t\t// 遍历\n\t\tif(isEmpty()) {\n\t\t\tSystem.out.println(\"队列为空\");\n\t\t}else {\n\t\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\t\tSystem.out.print(arr[i]+\" \");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// 显示队列的头数据\n\tpublic int headQueue() {\n\t\tif(isEmpty()) {\n\t\t\tthrow new RuntimeException(\"队列为空！\");\n\t\t}\n\t\treturn arr[front+1];\n\t}\t\n}\n```\n\n### 2、环形队列\n1.目前数组使用一次之后就不能再使用了，没有达到复用的效果。\n2.将数组使用算法，改进成为一个环形队列&nbsp;&nbsp;&nbsp;取模%\n![](DataStructure-01-2/4.png)\n\n> 循环队列中，由于入队时尾指针向前追赶头指针；出队时头指针向前追赶尾指针，造成队空和队满时头尾指针均相等。因此，无法通过条件front==rear来判别队列是\"空\"还是\"满\"。\n> 解决这个问题的方法至少有三种：\n> ① 另设一布尔变量以区别队列的空和满；\n> ② 少用一个元素的空间。约定入队前，测试尾指针在循环意义下加1后是否等于头指针，若相等则认为队满\n\n```java\nclass CircleQueue {\n\tprivate int maxSize;// 表示数组的最大容量\n\tprivate int front;// 队列头\n\tprivate int rear;// 队列尾\n\tprivate int[] arr;// 用于存放数据，模拟队列\n\n\tpublic CircleQueue(int maxSize) {\n\t\tthis.maxSize = maxSize;\n\t\tthis.arr = new int[maxSize];\n\t\t// this.front = 0;// 指向队列头部\n\t\t// this.rear = 0;// 指向队列尾部的后一个位置\n\t}\n\n\tpublic boolean isFull() {\n\t\treturn (rear + 1) % maxSize == front;\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn rear == front;\n\t}\n\n\t// 添加数据到队列，入队列\n\tpublic void addQueue(int num) {\n\t\t// 判断队列是否已满\n\t\tif (isFull()) {\n\t\t\tSystem.out.println(\"队列已满！\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tarr[rear] = num;\n\t\t\trear = (rear + 1) % maxSize; // 让rear后移\n\t\t}\n\t}\n\n\t// 获取队列数据，出队列\n\tpublic int getQueue() {\n\t\t// 判断队列是否为空\n\t\tif (isEmpty()) {\n\t\t\tthrow new RuntimeException(\"队列为空！\");// 抛出异常\n\t\t}\n\t\t// 1.将front对应的值保存\n\t\tint value = arr[front];\n\t\t// 2.front后移\n\t\tfront = (front + 1) % maxSize;\n\t\t// 3.返回保存的front对应的值\n\t\treturn value;\n\t}\n\n\t// 当前队列的有效数据个数\n\tpublic int size() {\n\t\treturn (rear - front + maxSize) % maxSize;\n\t}\n\n\t// 显示队列所有数据\n\tpublic void showQueue() {\n\t\t// 遍历\n\t\tif (isEmpty()) {\n\t\t\tSystem.out.println(\"队列为空\");\n\t\t} else {// 从front开始遍历\n\t\t\tfor (int i = front; i < front + size(); i++) {\n\t\t\t\tSystem.out.print(arr[i % maxSize] + \" \");\n\t\t\t}\n\t\t}\n\t}\n\n\t// 显示队列的头数据\n\tpublic int headQueue() {\n\t\tif (isEmpty()) {\n\t\t\tthrow new RuntimeException(\"队列为空！\");\n\t\t}\n\t\treturn arr[front];\n\t}\n}\n```","tags":["数据结构"],"categories":["数据结构"]},{"title":"稀疏数组","url":"/2020/04/25/datastructure-01/","content":"\n## 数据结构概述\n\n数据结构包括：线性结构和非线性结构.<!--more-->\n**线性结构：**\n1.数据元素之间存在**一对一**的线性关系。\n2.线性结构有两种不同的存储结构，即**顺序存储结构(数组)**和**链式存储结构(链表)**。\n3.顺序存储的线性表称为顺序表，存储的元素是**连续的**；\n&nbsp;&nbsp;&nbsp;链式存储的线性表称为链表，存储的元素**不一定是连续的**，元素节点中存放着数据元素和相邻元素的地址信息。\n4.线性结构常见的有：数组，队列，链表和栈。\n**非线性结构：**\n非线性结构包括：二维数组，多维数组，广义表，树，图。\n\n## 稀疏数组\n\n当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。\n稀疏数组的处理方法是:\n1)记录数组一共有几行几列，有多少个不同的非零值。\n2)把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。\n\n### 1、基本介绍：\n\n![](DataStructure-01/1.png)\n\n### 2、应用实例：\n\n![](DataStructure-01/2.png)\n\n```java\npublic class SparseArray {\n\tpublic static void main(String[] args) {\n\t\t// 创建原始的二维数组11*11\n\t\t// 0：表示没有棋子 1:表示黑色棋子 2：表示蓝色棋子\n\t\tint chessArr1[][] = new int[11][11];\n\t\tchessArr1[1][2] = 1;\n\t\tchessArr1[2][3] = 2;\n\t\tSystem.out.println(\"原始的二维数组：\");\n\t\tfor (int[] row : chessArr1) {\n\t\t\tfor (int data : row) {\n\t\t\t\tSystem.out.print(data + \"  \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\t// 将二维数组转换为稀疏数组\n\t\t// 1.先遍历二维数组 得到非零数据的个数\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < chessArr1.length; i++) {\n\t\t\tfor (int j = 0; j < chessArr1[0].length; j++) {\n\t\t\t\tif (chessArr1[i][j] != 0) {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// System.out.println(sum);\n\t\t// 2.创建对应的稀疏数组\n\t\tint sparseArr[][] = new int[sum + 1][3];\n\t\t// 3.给稀疏数组赋值\n\t\tsparseArr[0][0] = chessArr1.length;\n\t\tsparseArr[0][1] = chessArr1[0].length;\n\t\tsparseArr[0][2] = sum;\n\t\t// 遍历二维数组将非零值存放到稀疏数组中\n\t\tint count = 0; // 用于记录是第几个非零数据\n\t\tfor (int i = 0; i < chessArr1.length; i++) {\n\t\t\tfor (int j = 0; j < chessArr1[0].length; j++) {\n\t\t\t\tif (chessArr1[i][j] != 0) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tsparseArr[count][0] = i;\n\t\t\t\t\tsparseArr[count][1] = j;\n\t\t\t\t\tsparseArr[count][2] = chessArr1[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"稀疏数组：\");\n\t\tfor (int[] row : sparseArr) {\n\t\t\tfor (int data : row) {\n\t\t\t\tSystem.out.printf(\"%d\\t\", data);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\t// 稀疏数组转换为二维数组\n\t\t// 1.读取稀疏数组的第一行，根据第一行的数据创建原始的二维数组\n\t\tint chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];\n\t\t// 2.读取其余的几行数据，并赋值给原始的 二维数组\n\t\tfor (int i = 1; i < sparseArr.length; i++) {\n\t\t\tint row = sparseArr[i][0];\n\t\t\tint col = sparseArr[i][1];\n\t\t\tint value = sparseArr[i][2];\n\t\t\tchessArr2[row][col] = value;\n\t\t}\n\t\tSystem.out.println(\"恢复后的二维数组：\");\n\t\tfor (int[] row : chessArr2) {\n\t\t\tfor (int data : row) {\n\t\t\t\tSystem.out.print(data + \"  \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"Cookie,session","url":"/2020/04/23/javaweb-06/","content":"\n## Cookie\n\nCookie是服务器通知客户端保存键值对的一种技术。\n客户端有了Cookie后，每次请求都会发送给服务器。\nCookie 的值可以唯一地标识客户端，因此 Cookie 常用于会话管理。\n每个Cookie的 大小不能超过4kb。<!--more-->\n\n### 1.创建Cookie\n\n![](javaweb-06/1.png)\n\n```java\npublic class CookieServlet extends BaseServlet {\n    protected void createCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 1.创建Cookie对象\n        Cookie cookie = new Cookie(\"key1\", \"value\");\n        // 2.通知客户端保存Cookie\n        resp.addCookie(cookie);\n        resp.getWriter().write(\"Cookie创建成功\");\n    }\n}\n```\n\n### 2.服务器获取Cookie\n\n![](javaweb-06/2.png)\n\n```java\nprotected void getCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    Cookie[] cookies = req.getCookies();\n    for(Cookie cookie:cookies){\n        // getName()返回cookie的key\n        // getValue()返回cookie的value\n        resp.getWriter().write(\"Cookie[\"+cookie.getName()+\"=\"+cookie.getValue()+\"]<br/>\");\n    }\n    Cookie iwantCookie = null;\n    /*for(Cookie cookie:cookies){\n            // 给到想要的cookie\n            if(\"key1\".equals(cookie.getName())){\n                iwantCookie = cookie;\n                break;\n            }\n        }*/\n    iwantCookie = CookieUtils.findCookie(\"key1\",req.getCookies());    if(iwantCookie!=null){\n    resp.getWriter().write(\"找到了指定的cookie\");\n    }\n}\n```\n\n**将查找指定Cookie封装成工具类：**\n\n```java\npackage Utils;\n\npublic class CookieUtils {\n    /**\n     * 查找指定名称的cookie\n     * @param name\n     * @param cookies\n     * @return cookie\n     */\n    public static Cookie findCookie(String name,Cookie[] cookies){\n        if(name==null||cookies==null||cookies.length==0){\n            return null;\n        }\n        for(Cookie cookie:cookies){\n            // 给到想要的cookie\n            if(name.equals(cookie.getName())){\n                return cookie;\n            }\n        }\n        return null;\n    }\n}\n```\n\n### 3.Cookie值的修改\n\n**方案一：**\n1、先创建一个要修改的同名（指的就是key）的Cookie 对象\n2、在构造器，同时赋于新的Cookie 值。\n3、调用response.addCookie( Cookie );\n\n**方案二：**\n1、先查找到需要修改的Cookie 对象\n2、调用setValue()方法赋于新的Cookie 值。\n3、调用response.addCookie()通知客户端保存修改\n\n```java\nprotected void updateCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n   /* // 方式一：\n    // 1、先创建一个要修改的同名（指的就是key）的Cookie 对象\n    // 2、在构造器，同时赋于新的Cookie 值。\n    Cookie cookie = new Cookie(\"key1\", \"value2\");\n    // 3、调用response.addCookie( Cookie );通知客户端保存cookie\n    resp.addCookie(cookie);\n   */\n\n    // 方式二：\n    // 1、先查找到需要修改的Cookie 对象\n    Cookie cookie = CookieUtils.findCookie(\"key1\",req.getCookies());\n    // 2、调用setValue()方法赋于新的Cookie 值。\n    if(cookie!=null){\n    cookie.setValue(\"value3\");\n    }\n    // 3、调用response.addCookie()通知客户端保存修改\n    resp.addCookie(cookie);\n}\n```\n\n### 4.Cookie的生命控制\n\n管理cookie什么时候被销毁(删除)\nsetAge()：\n正数表示在指定的秒数后过期；\n负数表示浏览器关闭后，cookie就会销毁；（）默认值为-1\n0表示马上删除cookie。\n\n```java\nprotected void defaultLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    Cookie cookie = new Cookie(\"defaultLife\",\"defaultLife\");\n    cookie.setMaxAge(-1); // 设置存活时间\n    resp.addCookie(cookie);\n}\n```\n\n```java\nprotected void deleteCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    Cookie cookie = CookieUtils.findCookie(\"defaultLife\",req.getCookies());\n    if(cookie!=null){\n    cookie.setMaxAge(0);// 马上删除cookie\n    resp.addCookie(cookie);\n    resp.getWriter().write(\"cookie[defaultLife=defaultValue]已删除\");\n    }\n}\n```\n\n### 5.Cookie有效路径Path的设置\n\nCookie的path属性可以有效的过滤哪些Cookie可以发送 个服务器。\npath属性是通过请求的地址来进行有效的过滤。\n\n```java\nprotected void testPath(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    Cookie cookie = new Cookie(\"key2\",\"value2\");\n    cookie.setPath(req.getContextPath()+\"/a\");  // 设置Path值为  /工程路径/a\n    resp.addCookie(cookie);\n}\n```\n\n### 6.免输入用户名登录\n\n![](javaweb-06/3.png)\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>login</title>\n</head>\n<body>\n    <form action=\"http://localhost:8080/08_cookie/loginServlet\" method=\"post\">\n        用户名：<input type=\"text\" name=\"username\" value=\"${cookie.username.value}\"/><br/>\n        密码：<input type=\"password\" name=\"password\"/><br/>\n        <input type=\"submit\" value=\"登录\"/>\n    </form>\n</body>\n</html>\n```\n\n```java\npublic class LoginServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        req.setCharacterEncoding(\"UTF-8\");\n        resp.setContentType(\"text/html;charset=UTF-8\");\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        if(\"zyz\".equals(username)&&\"123456\".equals(password)){\n            Cookie cookie = new Cookie(\"username\",username);\n            cookie.setMaxAge(60*60*24*7);// cookie一周内有效\n            resp.addCookie(cookie);\n            System.out.println(\"登录成功！\");\n        }else{\n            System.out.println(\"登录失败！\");\n        }\n    }\n}\n```\n\n## Session\n\n1、Session 是一个接口（HttpSession）。\n2、Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术。\n3、每个客户端都有自己的一个Session 会话。\n4、Session 会话中，我们经常用来保存用户登录之后的信息。\n\n### 1.创建和获取session\n\nrequest.getSeesion()：\n第一次调用：创建Session会话。\n之后的调用：获取前面创建好的Session会话对象。\nisNew()：判断Session是否是刚创建的\n&nbsp;&nbsp;&nbsp;&nbsp;true：表示刚创建\n&nbsp;&nbsp;&nbsp;&nbsp;false：表示获取之前创建\ngetId()：得到Session的会话id值\n\n```java\nprotected void createOrGetSession(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    // 创建或获取Session会话对象\n    HttpSession session = req.getSession();\n    // 判断Session是否是刚刚创建的\n    boolean isNew = session.isNew();\n    // 获取Session会话的唯一标识id\n    String id = session.getId();\n\n    resp.getWriter().write(\"得到Session,id为：\"+id+\"<br/>\");\n    resp.getWriter().write(\"是否是刚刚创建的：\"+isNew+\"<br/>\");\n}\n```\n\n### 2.Session域数据的存取\n\n```java\n/**\n * 往Session域中保存数据\n * @param req\n * @param resp\n * @throws ServletException\n * @throws IOException\n */\nprotected void setAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    req.getSession().setAttribute(\"key1\",\"value1\");\n\n}\n\n/**\n * 获取Session中的数据\n * @param req\n * @param resp\n * @throws ServletException\n * @throws IOException\n */\nprotected void getAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    Object key1 = req.getSession().getAttribute(\"key1\");\n    resp.getWriter().write(\"从Session中获取的key1的数据为：\"+ key1);\n}\n```\n\n### 3.Session生命周期控制\n\nsetMaxInactiveInterval(int  interval)：设置Session超时时间，超过指定的时长就会被销毁。\n负数表示永不超时。\ngetMaxInactiveInterval()：获取Session超时时长。\ninvalidate()：使当前会话马上超时。\n\n获取默认超时时长：\n\n```java\nprotected void defaultLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    int maxInactiveInterval = req.getSession().getMaxInactiveInterval();\n    resp.getWriter().write(\"Session的默认超时时长为：\"+maxInactiveInterval);// 1800\n}\n```\n\n 设置web工程下所有的 Session 默认超时时长：\n\n```xml\n<session-config>\n\t<session-timeout>20</session-timeout>\n</session-config>\n```\n\n设置个别Session的超时时长：                                                                                                                                                                                                                                                                                                                                                                                                                                            \n\n```java\nprotected void setLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    req.getSession().setMaxInactiveInterval(3);\n    resp.getWriter().write(\"设置Session 3秒后失效~\");\n}\n```\n\n使Session马上失效：\n\n```java\n protected void deleteNow(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        req.getSession().invalidate();\n        resp.getWriter().write(\"设置Session 马上失效~\");\n    }\n```\n\n","tags":["JavaWeb"],"categories":["JavaWeb"]},{"title":"文件的上传和下载","url":"/2020/04/13/javaweb-05/","content":"\n## 文件上传\n\n文件上传的要求：\n1、要有一个form标签，method=post\n2、form标签的encType属性值必须为multipart/form-data(表示提交的数据以多段进行拼接(每个表单项分为一段)，然后以二进制流的形式提交给服务器)\n3、在form标签中使用 input type=file 添加上传的文件\n4、编写服务器代码接收，处理上传的数据<!--more-->\n![](javaweb-05/1.png)\n\n导入两个第三方的jar包：\n![](javaweb-05/2.png)\n\n处理文件上传的servlet程序：\n\n```java\npackage servlet;\n\npublic class UploadServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // System.out.println(\"文件上传过来了\");\n        // 1.先判断上传的数据是否为多段数据(文件上传)\n        if (ServletFileUpload.isMultipartContent(req)){\n            // 2.创建FileItemFactory工厂实现类\n            FileItemFactory fileItemFactory = new DiskFileItemFactory();\n            // 3.创建用于解析上传数据的工具类ServletFileUpload类\n            ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);\n            try {\n                // 4.解析上传数据，得到每一个表单项FileItem\n                List<FileItem> list = servletFileUpload.parseRequest(req);\n                // 5.循环判断每一个表单项是普通类型，还是文件类型\n                for(FileItem fileItem : list){\n                    if(fileItem.isFormField()){\n                        // 普通表单项\n                        System.out.println(\"表单项的name属性值：\"+fileItem.getFieldName());\n                        System.out.println(\"表单项的value属性值\"+fileItem.getString(\"UTF-8\"));\n                    }else{\n                        // 文件表单项\n                        System.out.println(\"表单项的name属性值：\"+fileItem.getFieldName());\n                        System.out.println(\"上传的文件名：\"+fileItem.getName());\n                        fileItem.write(new File(\"d://\"+fileItem.getName()));\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n    <form action=\"http://localhost:8080/07_jsp/uploadServlet\" method=\"post\" enctype=\"multipart/form-data\">\n        用户名：<input type=\"text\" name=\"username\" /> <br/>\n        头像：<input type=\"file\" name=\"photo\" /> <br/>\n        <input type=\"submit\" value=\"上传\">\n    </form>\n</body>\n</html>\n```\n\n## 文件下载\n\n```java\npackage servlet;\n\npublic class DownloadServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 1.获取要下载的文件名\n        String downloadFileName = \"cat.jpg\";\n        // 2.通过servletContext对象 读取要下载的文件内容\n        ServletContext servletContext = getServletContext();\n        InputStream resourceAsStream = servletContext.getResourceAsStream(\"/file/\" + downloadFileName);\n        // 获取响应输出流\n        OutputStream outputStream = resp.getOutputStream();\n        // 3.在回传前通过响应头告诉客户端返回的数据类型\n        String mimeType = servletContext.getMimeType(\"/file/\" + downloadFileName);\n        System.out.println(\"下载的文件类型：\" + mimeType);\n        // 4.以及告诉客户端收到的数据是用于下载使用的\n        // 判断浏览器类型\n        String ua = req.getHeader(\"User-Agent\");\n        String str=\"\";\n        // 判断是否是火狐浏览器\n        if (ua.contains(\"Firefox\")) {\n        // 使用下面的格式进行BASE64 编码后\n            str = \"=?utf-8?B?\" + new BASE64Encoder().encode(\"中文.jpg\".getBytes(\"utf-8\")) + \"?=\";\n        } else {\n        // 把中文名进行UTF-8 编码操作\n            str = URLEncoder.encode(\"中文.jpg\", \"UTF-8\");\n        }\n        // Content-Disposition响应头，表示收到的数据该怎么处理\n        // attachment 附件，表示下载使用\n        // filename 表示指定下载的文件名\n        resp.setHeader(\"Content-Disposition\", \"attachment;fileName=\" + str);\n        // 5.把要下载的文件内容回传给客户端\n        //  读取输入流中的全部数据，复制给输出流，输出给客户端\n        IOUtils.copy(resourceAsStream, outputStream);\n    }\n}\n```","tags":["JavaWeb"],"categories":["JavaWeb"]},{"title":"EL表达式，JSTL标签库","url":"/2020/04/12/javaweb-04/","content":"\n## EL表达式\n\nExpress Language：表达式语言。\n作用：代替jsp页面中的表达式脚本在jsp页面中进行数据的输出。<!--more-->\n\n```html\n<body>\n    <%\n        request.setAttribute(\"key\",\"value\");\n    %>\n    jsp表达式输出key的值：<%=\n    request.getAttribute(\"key\")==null?\"\":request.getAttribute(\"key\")\n    %><br/>\n    EL表达式输出key的值：${key}\n</body>\n```\n\n格式：```${表达式}```\nEL表达式在输出空值的时候，输出的是空串，而jsp表达式输出的是null字符串。\n\n## 运算\n\n关系运算\n\n逻辑运算\n\n算数运算\nempty运算：判断一个数据是否为空，为空输出truem，否则输出false\n三元运算\n“.”点运算和[] 中括号运算符\n\n## EL表达式中的11个隐含对象\n\n![](javaweb-04/1.png)\n\npageContext对象的使用：\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<%-- jsp表达式\nrequest.getScheme() 它可以获取请求的协议\nrequest.getServerName() 获取请求的服务器ip 或域名\nrequest.getServerPort() 获取请求的服务器端口号\nrequest.getContextPath() 获取当前工程路径\nrequest.getMethod() 获取请求的方式（GET 或POST）\nrequest.getRemoteHost() 获取客户端的ip 地址\nsession.getId() 获取会话的唯一标识\n--%>\n\n\n<%-- EL表达式--%>\n<%\n    pageContext.setAttribute(\"req\", request);\n%>\n\n1. 协议：${req.scheme}<br/>\n2. 服务器ip：${pageContext.request.serverName}<br/>\n3. 服务器端口：${pageContext.request.serverPort}<br/>\n4. 获取工程路径：${pageContext.request.contextPath}<br/>\n5. 获取请求方法：${pageContext.request.method}<br/>\n6. 获取客户端ip 地址：${pageContext.request.remoteHost}<br/>\n7. 获取会话的id 编号：${pageContext.session.id}\n</body>\n</html>\n```\n\n## JSTL标签库\n\nEL表达式是为了替换jsp中的表达式，而标签库是为了替换jsp中的代码脚本。\n![](javaweb-04/2.png)\n\n在jsp 标签库中使用taglib 指令引入标签库\n\n```html\nCORE 标签库\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\nFMT 标签库\n<%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %>\nFUNCTIONS 标签库\n<%@ taglib prefix=\"fn\" uri=\"http://java.sun.com/jsp/jstl/functions\" %>\n```\n\n### core核心库使用\n\n```html\n<%@ page import=\"java.util.HashMap\" %>\n<%@ page import=\"java.util.Map\" %>\n<%@ page import=\"bean.Student\" %>\n<%@ page import=\"java.util.List\" %>\n<%@ page import=\"java.lang.reflect.Array\" %>\n<%@ page import=\"java.util.ArrayList\" %>\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<%-- if判断 --%>\n<c:if test=\"${1==1}\">\n    <h1>1==1</h1>\n</c:if>\n\n<%-- 多路判断--%>\n<c:choose>\n    <c:when test=\"\"></c:when>\n    <c:when test=\"\"></c:when>\n    <c:otherwise></c:otherwise>\n</c:choose>\n\n<%-- foreach遍历输出--%>\n<c:forEach begin=\"1\" end=\"10\" var=\"i\">\n    ${i}<br/>\n</c:forEach>\n\n<%--遍历数组--%>\n<%\n    request.setAttribute(\"arr\",new String[]{\"Tom\",\"Taylor\",\"Troye\"});\n%>\n<c:forEach items=\"${requestScope.arr}\" var=\"item\">\n    ${item}<br/>\n</c:forEach>\n\n<%-- 遍历Map--%>\n<%\n    Map<String,String> map = new HashMap<String,String>();\n    map.put(\"key1\",\"value1\");\n    map.put(\"key2\",\"value2\");\n    map.put(\"key3\",\"value3\");\n//    for(Map.Entry<String,String> entry:map.entrySet()){\n//\n//    }\n    request.setAttribute(\"map\",map);\n%>\n<c:forEach items=\"${requestScope.map}\" var=\"entry\">\n    键：${entry.key}\n    值：${entry.value}\n    <br/>\n</c:forEach>\n\n<%-- 遍历List--%>\n<%\n    List<Student> stuList = new ArrayList<Student>();\n    for (int i = 0; i < 5; i++) {\n        stuList.add(new Student(i,\"username\"+i,\"password\"+i, 18+i));\n    }\n    request.setAttribute(\"students\",stuList);\n%>\n<table width=\"500px\" border=\"1px solid black\" cellspacing=\"0\">\n    <tr>\n        <th>编号</th>\n        <th>用户名</th>\n        <th>密码</th>\n        <th>年龄</th>\n        <th>状态信息</th>\n    </tr>\n<c:forEach items=\"${requestScope.students}\" var=\"stu\" varStatus=\"status\">\n    <tr>\n        <td>${stu.id}</td>\n        <td>${stu.username}</td>\n        <td>${stu.password}</td>\n        <td>${stu.age}</td>\n        <td>${status.count}</td>\n    </tr>\n</c:forEach>\n</table>\n</body>\n</html>\n```\n\n\n\n\n\n\n\n","tags":["JavaWeb"],"categories":["JavaWeb"]},{"title":"jsp,Listener监听器","url":"/2020/04/11/javaweb-03/","content":"\n## jsp定义\n\njsp全称为 java server page，用来代替servlet程序回传html页面的数据。<!--more-->\n\n**jsp页面的本质就是一个Servlet程序**，在第一次访问jsp页面时，Tomcat服务器就会把jsp页面翻译成一个java源程序，并对它进行编译成.class字节码文件。\n\n## jsp语法\n\n### jsp头部的page指令\njsp 的page 指令可以修改jsp 页面中一些重要的属性，或者行为。\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n```\n\ni. language 属性表示jsp 翻译后是什么语言文件。暂时只支持java。\nii. contentType 属性表示jsp 返回的数据类型是什么。也是源码中response.setContentType()参数值\niii. pageEncoding 属性表示当前jsp 页面文件本身的字符集。\niv. import 属性跟java 源代码中一样。用于导包，导类。\nv. autoFlush 属性设置当out 输出流缓冲区满了之后，是否自动刷新冲级区。默认值是true。\nvi. buffer 属性设置out 缓冲区的大小。默认是8kb\nvii. errorPage 属性设置当jsp 页面运行时出错，自动跳转去的错误页面路径。\n\n### jsp中的常用脚本\n\n1、声明脚本\n作用：可以给jsp 翻译出来的java 类定义属性和方法甚至是静态代码块，内部类等。\n格式：```<%!  java代码%>```\n\n2、表达式脚本\n作用：在jsp页面上输出数据\n格式：```<%= 表达式 %>```\n\n3、代码脚本\n作用：可以在jsp页面中，编写我们需要的功能(java代码)\n格式：```<% java代码 %>```\n\n## jsp九大内置对象\n\njsp在翻译成servlet代码后内部提供的九个对象。\nrequest&nbsp;&nbsp;&nbsp;请求对象\nresponse&nbsp;&nbsp;&nbsp;响应对象\npageContext&nbsp;&nbsp;&nbsp;jsp上下文对象\nsession&nbsp;&nbsp;&nbsp;会话对象\napplication&nbsp;&nbsp;&nbsp;ServletContext对象\nconfig&nbsp;&nbsp;&nbsp;ServletConfig对象\npage&nbsp;&nbsp;&nbsp;当前的jsp对象\nexception&nbsp;&nbsp;&nbsp;异常对象\nout 向客户端输出内容常用的对象\n\n**四个域对象：**\npage&nbsp;&nbsp;&nbsp;&nbsp;(PageContextImpl类)&nbsp;&nbsp;&nbsp;&nbsp;当前的jsp页面有效\nrequest&nbsp;&nbsp;&nbsp;&nbsp;(HttpServletRequest类)&nbsp;&nbsp;&nbsp;&nbsp;一次请求有效\nsession&nbsp;&nbsp;&nbsp;&nbsp;(HttpSession类)&nbsp;&nbsp;&nbsp;&nbsp;一次会话范围内有效(打开浏览器访问服务器，直到关闭浏览器)\napplication&nbsp;&nbsp;&nbsp;&nbsp;(ServletContext类)&nbsp;&nbsp;&nbsp;&nbsp;整个web工程范围内都有效(只要web工程不停止，数据一直都在)\n域对象是可以像Map一样存取数据的对象。四个域对象的功能一样，不同的是它们对数据的存取范围。\n\n**jsp中的out输出与response.getWriter()输出的区别：**\n![](javaweb-03/1.png)\n\n<font color=\"red\">统一使用out.print()输出</font>\n\n## jsp常用标签\n\n### 静态包含\n\n格式：```<%@ include file=\"/\"%>```\nfile属性指定要包含的页面路径\n静态包含的特点：\n1、静态包含不会翻译被包含的jsp 页面。\n2、静态包含其实是把被包含的jsp 页面的代码拷贝到包含的位置执行输出。\n\n### 动态包含\n\n格式：```<jsp:include page=\"/\"></jsp:include>```\n动态包含特点：\n1、动态包含会把包含的jsp页面也翻译成java代码。\n2、通过调用被包含的jsp页面进行输出。\n3、动态包含可以传递参数。\n\n### 转发\n\n格式：``` <jsp:forward page=\"/\"></jsp:forward>```\n\n## Listener监听器\n\n1、Listener 监听器是javaweb三大组件之一(Servlet程序，Filter过滤器，Listener监听器)。\n2、Listener是javaEE接口规范，就是接口。\n3、监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。ServletContextListener 它可以监听ServletContext 对象的创建和销毁。\nServletContext 对象在web 工程启动的时候创建，在web 工程停止的时候销毁。\n监听到创建和销毁之后都会分别调用ServletContextListener 监听器的方法反馈。\n\n使用ServletContextListener 监听器监听ServletContext 对象步骤如下：\n1、编写一个类去实现ServletContextListener\n2、实现其两个回调方法\n3、到web.xml 中去配置监听器\n\n```java\npackage listener;\n\npublic class ServletContextListenerImpl implements ServletContextListener {\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println(\"创建ServletContext\");\n    }\n\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n        System.out.println(\"销毁ServletContext\");\n    }\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <listener>\n        <listener-class>listener.ServletContextListenerImpl</listener-class>\n    </listener>\n</web-app>\n```\n\n","tags":["JavaWeb"],"categories":["JavaWeb"]},{"title":"书城项目","url":"/2020/04/08/javaweb-02/","content":"\n## 一、创建项目所需要的包\n\n各个层所对应的包名：<!--more-->\nweb层：\ncom.bookmall.web/servlet/controller\nservice层：\ncom.bookmall.service&nbsp;&nbsp;&nbsp;Service接口包\ncom.bookmall.service.impl&nbsp;&nbsp;&nbsp;Service接口实现类\ndao层：\ncom.bookmall.dao&nbsp;&nbsp;&nbsp;Dao接口包\ncom.bookmall.dao.impl&nbsp;&nbsp;&nbsp;Dao接口实现类\n实体bean对象：\ncom.bookmall.pojo/entity/domain/bean&nbsp;&nbsp;&nbsp;JavaBean类\n测试包：\ncom.bookmall.test/junit\n工具包：\ncom.bookmall.utils\n![](javaweb-02/1.png)\n\n## 二、创建需要的数据库和表\n\n```sql\nCREATE DATABASE bookmall;\n\nUSE bookmall;\n\nCREATE TABLE userinfo(\n\t `id` INT PRIMARY KEY auto_increment,\n\t `username` VARCHAR(20) NOT NULL,\n\t `password` VARCHAR(32) NOT NULL,\n\t`email` VARCHAR(40)\n);\n\nINSERT  INTO userinfo(`username`,`password`,`email`)\n\nVALUES('admin','123456','admin@qq.com');\n\nSELECT * FROM userinfo;\n```\n\n## 三、编写数据库表对应的 JavaBean 对象\n\n在com.bookmall.bean包下创建User类\n\n```java\npackage com.bookmall.bean;\n\npublic class User {\n    private Integer id;\n    private String username;\n    private String password;\n    private String email;\n\n    public User() {\n    }\n\n    public User(Integer id, String username, String password, String email) {\n        this.id = id;\n        this.username = username;\n        this.password = password;\n        this.email = email;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n    \n     @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                \", password='\" + password + '\\'' +\n                \", email='\" + email + '\\'' +\n                '}';\n    }\n}\n```\n\n## 四、编写工具类JdbcUtils并测试\n\n1.首先导入所需要的jar包：\n![](javaweb-02/2.png)\n\n2.在src目录下创建jdbc.properties 配置文件：\n\n```properties\nusername=root\npassword=2824199842\nurl=jdbc:mysql://localhost:3306/bookmall?serverTimezone=Asia/Shanghai\ndriverClassName=com.mysql.cj.jdbc.Driver\ninitialSize=10\nmaxActive=10\n```\n\n3.在com.bookmall.utils下创建 JdbcUtils 类：\n\n```java\npackage com.bookmall.utils;\n\npublic class JdbcUtils {\n    private static DruidDataSource dataSource;\n    static{\n        Properties properties = null;\n        try {\n            properties = new Properties();\n            // 创建输入流 读取jdbc.properties属性配置文件\n            InputStream inputStream = JdbcUtils.class.getClassLoader().getResourceAsStream(\"jdbc.properties\");\n            // 从流中加载数据\n            properties.load(inputStream);\n            // 创建数据库连接池\n            dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 获取数据库连接池中的连接\n     * @return 返回连接  否则返回null\n     */\n    public static Connection getConnection(){\n        Connection conn = null;\n        try {\n            conn = dataSource.getConnection();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return conn;\n    }\n\n    /**\n     * 关闭连接，放回数据库连接池\n     * @param conn\n     */\n    public static void close(Connection conn){\n        if(conn!=null){\n            try {\n                conn.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n4.在com.bookmall.test包下创建JdbcUtilsTest类，测试是否连接成功：\n\n```java\npackage com.bookmall.test;\n\npublic class JdbcUtilsTest {\n    @Test\n    public void testJdbcUtils() {\n        Connection conn = JdbcUtils.getConnection();\n        System.out.println(conn);\n        JdbcUtils.close(conn);\n    }\n}\n```\n\n## 五、编写BaseDao\n\n1.导入DBUtils 的jar包：\n![](javaweb-02/4.png)\n\n2.在com.bookmall.dao.impl包下创建BaseDao抽象类：\n\n```java\npackage com.bookmall.dao.impl;\n\npublic abstract class BaseDao {\n    // 使用dbutils操作数据库\n    private QueryRunner queryRunner = new QueryRunner();\n\n    /**\n     * 执行增删改方法\n     * @param sql 要执行的sql语句\n     * @param args 要填充的占位符\n     * @return 执行成功，返回受影响的行数，否则执行失败，返回-1\n     */\n    public int update(String sql,Object ... args){\n        Connection conn = JdbcUtils.getConnection();\n        try {\n            return queryRunner.update(conn,sql,args);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }finally {\n            JdbcUtils.close(conn);\n        }\n        return -1;\n    }\n\n    /**\n     * 执行返回一条结果的查询语句\n     * @param type 返回的对象类型\n     * @param sql 要执行的sql语句\n     * @param args 要填充的占位符\n     * @param <T> 返回的类型的泛型\n     * @return 执行成功，返回一个指定类型的对象，否则执行失败，返回null\n     */\n    public <T> T queryForOne(Class<T> type,String sql,Object ... args){\n        Connection conn = JdbcUtils.getConnection();\n        // BeanHandler是ResultSetHandler接口的一个实现类，用于封装表中的一条记录\n        try {\n            return queryRunner.query(conn,sql,new BeanHandler<T>(type),args);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }finally {\n            JdbcUtils.close(conn);\n        }\n        return null;\n    }\n\n    /**\n     * 执行返回多条结果的查询语句\n     * @param type 返回的对象类型\n     * @param sql 要执行的sql语句\n     * @param args 要填充的占位符\n     * @param <T> 返回的类型的泛型\n     * @return 执行成功，返回一个指定类型的对象的列表，否则执行失败，返回null\n     */\n    public <T> List<T> queryForList(Class<T> type, String sql, Object ... args){\n        Connection conn = JdbcUtils.getConnection();\n        try {\n            return queryRunner.query(conn,sql,new BeanListHandler<T>(type),args);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }finally {\n            JdbcUtils.close(conn);\n        }\n        return null;\n    }\n\n    /**\n     * 执行返回特殊值（一行一列）的查询\n     * @param sql 要执行的sql语句\n     * @param args 要填充的占位符\n     * @return 执行成功，返回一个值，否则执行失败，返回null\n     */\n    public Object queryForSingleValue(String sql, Object ... args){\n        Connection conn = JdbcUtils.getConnection();\n        // ScalarHandler将单个值封装\n        try {\n            return queryRunner.query(conn,sql,new ScalarHandler(),args);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }finally{\n            JdbcUtils.close(conn);\n        }\n        return null;\n    }\n}\n```\n\n## 六、编写UserDao接口并测试\n\n1.在com.bookmall.dao包下编写UserDao 接口\n\n```java\npackage com.bookmall.dao;\n\npublic interface UserDao {\n    /**\n     * 根据用户名查询用户信息\n     * @param username 用户名\n     * @return 执行成功，返回User对象，否则返回null\n     */\n    public User queryUserByUsername(String username);\n\n    /**\n     * 保存用户信息\n     * @param user User对象\n     * @return 执行成功，返回受影响的行数，否则返回-1\n     */\n    public int saveUser(User user);\n\n    /**\n     *根据用户名和密码查询用户信息\n     * @param username\n     * @param password\n     * @return 执行成功返回User对象，否则返回null说明用户名或密码错误\n     */\n    public User queryUserByUsernameAndPassword(String username,String password);\n}\n```\n\n2.在com.bookmall.dao包下编写UserDao接口实现类UserDaoImpl\n\n```java\npackage com.book.dao.impl;\n\npublic class UserDaoImpl extends BaseDao implements UserDao {\n    @Override\n    public User queryUserByUsername(String username) {\n        String sql = \"select `id`,`username`,`password`,`email` from userinfo where username = ?\";\n        return queryForOne(User.class, sql, username);\n    }\n\n    @Override\n    public int saveUser(User user) {\n        String sql = \"insert into userinfo(`username`,`password`,`email`)value(?,?,?)\";\n        return update(sql, user.getUsername(), user.getPassword(), user.getEmail());\n    }\n\n    @Override\n    public User queryUserByUsernameAndPassword(String username, String password) {\n        String sql = \"select `id`,`username`,`password`,`email` from userInfo where username = ? and password = ?\";\n        return queryForOne(User.class, sql, username, password);\n    }\n}\n```\n\n3.在com.bookmall.test包下创建UserDaoImplTest测试类(UserDaoImpl类下按ctrl+shift+t快速创建测试类)，测试UserDaoImpl类中的方法。\n\n```java\npackage com.bookmall.test;\n\npublic class UserDaoImplTest {\n    UserDao userDao = new UserDaoImpl();\n    @Test\n    public void queryUserByUsername() {\n        if(userDao.queryUserByUsername(\"admin\")!=null){\n            System.out.println(\"用户名可用\");\n        }else{\n        System.out.println(\"用户名已存在\");\n        }\n    }\n\n    @Test\n    public void saveUser() {\n        System.out.println(userDao.saveUser(new User(null,\"大司马\",\"123456\",\"dsm@qq.com\")));\n    }\n\n    @Test\n    public void queryUserByUsernameAndPassword() {\n        if(userDao.queryUserByUsernameAndPassword(\"admin\",\"123456\") == null){\n            System.out.println(\"用户名或密码错误，登录失败！\");\n        }else{\n        System.out.println(\"登录成功！\");\n        }\n    }\n}\n```\n\n## 七、编写UserService并测试\n\n1.在com.bookmall.service包下创建UserService接口\n\n```java\npackage com.bookmall.service;\n\npublic interface UserService {\n    /**\n     * 用户注册\n     * @param user\n     */\n    public void registUser(User user);\n\n    /**\n     * 用户登录\n     * @param user\n     * @return\n     */\n    public User login(User user);\n\n    /**\n     * 检查用户名是否可用\n     * @param username\n     * @return 返回true，表示用户已存在，否则返回false\n     */\n    public boolean existUsername(String username);\n}\n```\n\n2.在com.bookmall.service.impl创建UserService接口实现类UserServiceImpl\n\n```java\npackage com.bookmall.service.impl;\n\npublic class UserServiceImpl implements UserService {\n    private UserDao userDao = new UserDaoImpl();\n    @Override\n    public void registUser(User user) {\n        userDao.saveUser(user);\n    }\n\n    @Override\n    public User login(User user) {\n        return userDao.queryUserByUsernameAndPassword(user.getUsername(),user.getPassword());\n    }\n\n\n    @Override\n    public boolean existUsername(String username) {\n        if(userDao.queryUserByUsername(username)==null){\n            // 为null表示不存在，表示可以使用\n            return false;\n        }\n        return true;\n    }\n}\n```\n\n3.在com.bookmall.test包下创建测试类UserServiceImplTest，测试UserServiceImpl中的方法\n\n```java\npackage com.bookmall.test;\n\npublic class UserServiceImplTest {\n    UserService userService = new UserServiceImpl();\n    @Test\n    public void registUser() {\n        userService.registUser(new User(null,\"张伟\",\"123456\",\"zw@126.com\"));\n    }\n\n    @Test\n    public void login() {\n        System.out.println(userService.login(new User(null,\"zyz\",\"123456\",null)));\n    }\n\n    @Test\n    public void existUsername() {\n        System.out.println(userService.existUsername(\"zyz\"));// ture\n\n    }\n}\n```\n\n## 八、编写Web层\n\n### 1.实现注册功能\n\n在com.bookmall.web中创建RegistServlet类\n在web.xml文件中配置文件路径\n\n```xml\n <servlet>\n        <servlet-name>RegistServlet</servlet-name>\n        <servlet-class>com.bookmall.web.RegistServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>RegistServlet</servlet-name>\n        <url-pattern>/registServlet</url-pattern>\n    </servlet-mapping>\n```\n\n```java\npackage com.bookmall.web;\n\npublic class RegistServlet extends HttpServlet {\n    private UserService userService = new UserServiceImpl();\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 1.获取请求参数\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        String email = req.getParameter(\"email\");\n        String code = req.getParameter(\"code\");\n        // 2.检查验证码是否正确====先写死为qwer\n        if(\"qwer\".equalsIgnoreCase(code)){\n            // 验证码正确\n            // 3.检查用户名是否可用\n            if(userService.existUsername(username)){\n                // true 用户名已存在\n                System.out.println(\"用户名[\"+username+\"]已存在！\");\n                // 跳转到首页\n                req.getRequestDispatcher(\"/pages/user/regist.html\").forward(req,resp);\n            } else{\n                // false 用户名不存在  可以注册\n                userService.registUser(new User(null,username,password,email));\n                // 跳转到注册成功页面\n                req.getRequestDispatcher(\"/pages/user/regist_success.html\").forward(req,resp);\n            }\n        }else{// 验证码错误\n            System.out.println(\"验证码[\"+code+\"]错误！\");\n            // 跳转到首页\n            req.getRequestDispatcher(\"/pages/user/regist.html\").forward(req,resp);\n        }\n    }\n}\n```\n\n### 2.实现登录功能\n\n在com.bookmall.web中创建LogintServlet类\n在web.xml文件中配置文件路径\n\n```xml\n<servlet>\n        <servlet-name>LoginServlet</servlet-name>\n        <servlet-class>com.bookmall.web.LoginServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>LoginServlet</servlet-name>\n        <url-pattern>/loginServlet</url-pattern>\n    </servlet-mapping>\n```\n\n```java\npackage com.bookmall.web;\n\npublic class LoginServlet extends HttpServlet {\n    private UserService userService = new UserServiceImpl();\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 1.获取请求参数\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        User loginUser = userService.login(new User(null,username, password, null));\n        if(loginUser==null){\n                System.out.println(\"登录失败！\");\n                // 跳转到首页\n                req.getRequestDispatcher(\"/pages/user/login.html\").forward(req,resp);\n        }else{\n            System.out.println(\"登录成功！\");\n                // 跳转到登录成功页面\n                req.getRequestDispatcher(\"/pages/user/login_success.html\").forward(req,resp);\n        }\n    }\n}\n```\n\n## 九、优化代码\n\n### 1.将多个页面中重复的代码抽取出来：\n\n**写入单独的jsp文件中**\n![](javaweb-02/5.png)\n\nfooter.jsp\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<div id=\"bottom\">\n      <span>\n         尚硅谷书城.Copyright &copy;2015\n      </span>\n</div>\n```\n\nheader.jsp\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<% String basePath = request.getContextPath()+\"/\";%>\n<!-- base标签永远固定相对路径跳转  -->\n<base href=\"<%=basePath%>\">\n<link type=\"text/css\" rel=\"stylesheet\" href=\"static/css/style.css\">\n<script type=\"text/javascript\" src=\"static/script/jquery-3.4.1.js\"></script>\n```\n\nlogin_success_menu.jsp\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<div>\n    <span>欢迎<span class=\"um_span\">张总</span>光临尚硅谷书城</span>\n    <a href=\"pages/order/order.jsp\">我的订单</a>\n    <a href=\"index.jsp\">注销</a>&nbsp;&nbsp;\n    <a href=\"index.jsp\">返回</a>\n</div>\n```\n\nmanage_menu.jsp\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<div>\n    <a href=\"book_manager\">图书管理</a>\n    <a href=\"order_manager\">订单管理</a>\n    <a href=\"index.jsp\">返回商城</a>\n</div>\n```\n\n**采用静态包含的方式替换重复的代码：**\n\n```html\n <%-- 静态包含 页脚内容--%>\n<%@include file=\"/pages/common/footer.jsp\"%>\n```\n\n```html\n <%-- 静态包含 base标签、css样式、jquery文件--%>\n    <%@include file=\"/pages/common/head.jsp\"%>\n```\n\n```html\n <%-- 静态包含 成功之后的菜单--%>\n<%@include file=\"/pages/common/login_sucess_menu.jsp\"%\n```\n\n```html\n <%-- 静态包含 管理菜单--%>\n<%@include file=\"/pages/common/manage_menu.jsp\"%>\n```\n\n### 2.登录、注册错误提示以及表单回显\n\nLoginServlet.java\n\n```java\npublic class LoginServlet extends HttpServlet {\n    private UserService userService = new UserServiceImpl();\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 1.获取请求参数\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        User loginUser = userService.login(new User(null, username, password, null));\n        if (loginUser == null) {\n            // System.out.println(\"登录失败！\");\n            // 将要回显的错误信息保存到request域中\n            req.setAttribute(\"msg\",\"用户名或密码错误！\");\n            req.setAttribute(\"username\",username);\n            // 跳转到首页\n            req.getRequestDispatcher(\"/pages/user/login.jsp\").forward(req, resp);\n        } else {\n            System.out.println(\"登录成功！\");\n            // 跳转到登录成功页面\n            req.getRequestDispatcher(\"/pages/user/login_success.jsp\").forward(req, resp);\n        }\n    }\n}\n```\n\nlogin.jsp\n\n```html\n<div class=\"msg_cont\">\n   <b></b>\n   <span class=\"errorMsg\">\n      <%=\n         request.getAttribute(\"msg\")==null?\"请输入用户名和密码\":request.getAttribute(\"msg\")\n      %>\n   </span>\n</div>\n```\n\n```html\n<input class=\"itxt\" type=\"text\" placeholder=\"请输入用户名\"\n      autocomplete=\"off\" tabindex=\"1\" name=\"username\"\n      value=\"<%=request.getAttribute(\"username\")==null?\"\":request.getAttribute(\"username\")%>\"/>\n```\n\nRegistServlet.java\n\n```java\npublic class RegistServlet extends HttpServlet {\n    private UserService userService = new UserServiceImpl();\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 1.获取请求参数\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        String email = req.getParameter(\"email\");\n        String code = req.getParameter(\"code\");\n        // 2.检查验证码是否正确====先写死为qwer\n        if(\"qwer\".equalsIgnoreCase(code)){\n            // 验证码正确\n            // 3.检查用户名是否可用\n            if(userService.existUsername(username)){\n                // true 用户名已存在\n                // System.out.println(\"用户名[\"+username+\"]已存在！\");\n                // 把回显信息保存到request域中\n                req.setAttribute(\"msg\",\"用户名已存在！\");\n                req.setAttribute(\"username\",username);\n                req.setAttribute(\"email\",email);\n                // 跳转到首页\n                req.getRequestDispatcher(\"/pages/user/regist.jsp\").forward(req,resp);\n            } else{\n                // false 用户名不存在  可以注册\n                userService.registUser(new User(null,username,password,email));\n                // 跳转到注册成功页面\n                req.getRequestDispatcher(\"/pages/user/regist_success.jsp\").forward(req,resp);\n            }\n        }else{// 验证码错误\n            // System.out.println(\"验证码[\"+code+\"]错误！\");\n            // 把错误信息和回显信息保存到request域中\n            req.setAttribute(\"msg\",\"验证码错误！\");\n            req.setAttribute(\"username\",username);\n            req.setAttribute(\"email\",email);\n            // 跳转到首页\n            req.getRequestDispatcher(\"/pages/user/regist.jsp\").forward(req,resp);\n        }\n    }\n}\n```\n\nregist.jsp\n\n```html\n<span class=\"errorMsg\">\n    <%=request.getAttribute(\"msg\")==null?\"\":request.getAttribute(\"msg\")%>\n</span>\n```\n\n```html\n<input class=\"itxt\" type=\"text\" placeholder=\"请输入用户名\"\n       autocomplete=\"off\" tabindex=\"1\"\n       name=\"username\" id=\"username\"\n       value=\"<%=request.getAttribute(\"username\")==null?\"\":request.getAttribute(\"username\")%>\"/>\n```\n\n```html\n<input class=\"itxt\" type=\"text\" placeholder=\"请输入邮箱地址\" autocomplete=\"off\" tabindex=\"1\"\n       name=\"email\" id=\"email\"\n       value=\"<%=request.getAttribute(\"email\")==null?\"\":request.getAttribute(\"email\")%>\"/>\n```\n\n### 3.将LoginServlet和RegistServlet合并为UserServlet\n\n![](javaweb-02/6.png)\n\n```java\npublic class UserServlet extends HttpServlet {\n    private UserService userService = new UserServiceImpl();\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 获取请求类型\n        String action = req.getParameter(\"action\");\n        if (\"login\".equals(action)) {\n            login(req, resp);\n        } else if (\"regist\".equals(action)) {\n            regist(req, resp);\n        }\n    }\n\n    /**\n     * 处理登录的功能\n     *\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 1.获取请求参数\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        User loginUser = userService.login(new User(null, username, password, null));\n        if (loginUser == null) {\n            // System.out.println(\"登录失败！\");\n            // 将要回显的错误信息保存到request域中\n            req.setAttribute(\"msg\", \"用户名或密码错误！\");\n            req.setAttribute(\"username\", username);\n            // 跳转到首页\n            req.getRequestDispatcher(\"/pages/user/login.jsp\").forward(req, resp);\n        } else {\n            // System.out.println(\"登录成功！\");\n            // 跳转到登录成功页面\n            req.getRequestDispatcher(\"/pages/user/login_success.jsp\").forward(req, resp);\n        }\n    }\n\n    /**\n     * 处理注册的功能\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 1.获取请求参数\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        String email = req.getParameter(\"email\");\n        String code = req.getParameter(\"code\");\n        // 2.检查验证码是否正确====先写死为qwer\n        if (\"qwer\".equalsIgnoreCase(code)) {\n            // 验证码正确\n            // 3.检查用户名是否可用\n            if (userService.existUsername(username)) {\n                // true 用户名已存在\n                // System.out.println(\"用户名[\"+username+\"]已存在！\");\n                // 把回显信息保存到request域中\n                req.setAttribute(\"msg\", \"用户名已存在！\");\n                req.setAttribute(\"username\", username);\n                req.setAttribute(\"email\", email);\n                // 跳转到首页\n                req.getRequestDispatcher(\"/pages/user/regist.jsp\").forward(req, resp);\n            } else {\n                // false 用户名不存在  可以注册\n                userService.registUser(new User(null, username, password, email));\n                // 跳转到注册成功页面\n                req.getRequestDispatcher(\"/pages/user/regist_success.jsp\").forward(req, resp);\n            }\n        } else {// 验证码错误\n            // System.out.println(\"验证码[\"+code+\"]错误！\");\n            // 把错误信息和回显信息保存到request域中\n            req.setAttribute(\"msg\", \"验证码错误！\");\n            req.setAttribute(\"username\", username);\n            req.setAttribute(\"email\", email);\n            // 跳转到首页\n            req.getRequestDispatcher(\"/pages/user/regist.jsp\").forward(req, resp);\n        }\n    }\n}\n```\n\nlogin.jsp\n![](javaweb-02/7.png)\n\nregist.jsp\n![](javaweb-02/8.png)\n\n### 4.使用反射优化大量else if 代码\n\n```java\n@Override\nprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    // 通过反射根据action属性值调用相应的方法\n    String action = req.getParameter(\"action\");\n    try {\n        Method method = UserServlet.class.getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class);\n        method.invoke(this,req, resp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n### 5.抽取BaseServlet\n\n![](javaweb-02/10.png)\n\n```java\npackage com.bookmall.web;\n\npublic abstract class BaseServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        req.setCharacterEncoding(\"utf-8\");\n        doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        req.setCharacterEncoding(\"utf-8\");\n        // 获取请求类型\n        String action = req.getParameter(\"action\");\n        // System.out.println(action);\n        try {// 通过反射根据action属性值调用相应的方法\n            Method method = this.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class);\n            method.invoke(this, req, resp);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```java\npackage com.bookmall.web;\n\npublic class UserServlet extends BaseServlet {\n    private UserService userService = new UserServiceImpl();\n    protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // ......\n    }\n\n    protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    \t// ......\n    }\n}\n```\n\n### 6.数据的封装和抽取 BeanUtils的使用\n\nBeanUtils工具类，可以一次性的把所有请求的参数注入导JavaBean中\n1、导入需要的jar 包：\ncommons-beanutils-1.8.0.jar\ncommons-logging-1.1.1jar\n2、使用BeanUtils类方法实现注入\n\n```java\npackage com.bookmall.utils;\n\npublic class WebUtils {\n    public static <T> T copyParamToBean(Map map, T bean){\n        // 将所有请求的参数封装到bean中\n        try {\n            BeanUtils.populate(bean,map);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return bean;\n    }\n}\n```\n\nUserServlet.java\n\n```java\n// 将请求参数一次性封装到user对象中\nUser user = WebUtils.copyParamToBean(req.getParameterMap(),new User());\n```\n\n### 7.使用EL表达式修改表单回显\n\nlogin.jsp\n\n```html\n<%--\n    <%= request.getAttribute(\"msg\")==null?\"请输入用户名和密码\":request.getAttribute(\"msg\")%>\n--%>\n${empty requestScope.msg ? \"请输入用户名和密码\":requestScope.msg}\n```\n\n```html\n<%--\n    value=\"<%=request.getAttribute(\"username\")==null?\"\":request.getAttribute(\"username\")%>\"\n--%>\nvalue=\"${requestScope.username}\"\n```\n\nregist.jsp\n\n```html\n<%--\n    <%=request.getAttribute(\"msg\")==null?\"\":request.getAttribute(\"msg\")%>\n--%>\n${requestScope.msg}\n```\n\n```html\n<%--\n    value=\"<%=request.getAttribute(\"username\")==null?\"\":request.getAttribute(\"username\")%>\"\n--%>\n${requestScope.username}\n```\n\n```html\n<%--\n    value=\"<%=request.getAttribute(\"email\")==null?\"\":request.getAttribute(\"email\")%>\"\n--%>\n${requestScope.email}\n```\n\n## 十、图书模块\n\n### 1.创建图书模块的数据库表\n\n```sql\nUSE bookmall;\nCREATE TABLE book(\n\t`id` INT PRIMARY KEY auto_increment,\n\t`name` VARCHAR(50) NOT NULL,\n\t`price` DECIMAL(8,2) NOT NULL,\n\t`author` VARCHAR(50) NOT NULL,\n\t`sales` INT NOT NULL,\n\t`stock` INT NOT NULL,\n\t`img_path` VARCHAR(100) NOT NULL\n);\n# drop table book;\n\n## 插入初始化测试数据\ninsert into book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) \nvalues(null , 'java从入门到放弃' , '国哥' , 80 , 9999 , 9 , 'static/img/default.jpg');\n\ninsert into book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) \nvalues(null , '数据结构与算法' , '严敏君' , 78.5 , 6 , 13 , 'static/img/default.jpg');\n\ninsert into book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) \nvalues(null , '编程珠玑' , 'Tom' , 68, 99999 , 52 , 'static/img/default.jpg');\n\ninsert into book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) \nvalues(null , '从你的全世界路过' , '张嘉加' , 16, 1000 , 50 , 'static/img/cover.jpg');\n\ninsert into book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) \nvalues(null , 'C语言程序设计' , '谭浩强' , 28 , 52 , 74 , 'static/img/default.jpg');\n```\n\n### 2.编写图书模块的JavaBean对象\n\n```java\npackage com.bookmall.bean;\n\npublic class Book {\n    private Integer id;\n    private String name;\n    private String author;\n    private BigDecimal price;\n    private Integer sales;\n    private Integer stock;\n    private String imgPath;\n\n    public Book() {\n    }\n\n    public Book(Integer id, String name, String author, BigDecimal price, Integer sales, Integer stock, String imgPath) {\n        this.id = id;\n        this.name = name;\n        this.author = author;\n        this.price = price;\n        this.sales = sales;\n        this.stock = stock;\n        if (imgPath != null && \"\".equals(imgPath)) {\n            this.imgPath = imgPath;\n        }\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAuthor() {\n        return author;\n    }\n\n    public void setAuthor(String author) {\n        this.author = author;\n    }\n\n    public BigDecimal getPrice() {\n        return price;\n    }\n\n    public void setPrice(BigDecimal price) {\n        this.price = price;\n    }\n\n    public Integer getSales() {\n        return sales;\n    }\n\n    public void setSales(Integer sales) {\n        this.sales = sales;\n    }\n\n    public Integer getStock() {\n        return stock;\n    }\n\n    public void setStock(Integer stock) {\n        this.stock = stock;\n    }\n\n    public String getImgPath() {\n        return imgPath;\n    }\n\n    public void setImgPath(String imgPath) {\n        if (imgPath != null && \"\".equals(imgPath)) {\n            this.imgPath = imgPath;\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"Book{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", author='\" + author + '\\'' +\n                \", price=\" + price +\n                \", sales=\" + sales +\n                \", stock=\" + stock +\n                \", imgPath='\" + imgPath + '\\'' +\n                '}';\n    }\n}\n```\n\n### 3.编写图书模块的DAO并测试\n\n```java\npackage com.bookmall.dao.impl;\n\npublic class BookDaoImpl extends BaseDao implements BookDao {\n    @Override\n    public int addBook(Book book) {\n        String sql = \"insert into book(`name`,`author`,`price`,`sales`,`stock`,`img_path`) values(?,?,?,?,?,?)\";\n        return update(sql, book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImgPath());\n    }\n\n    @Override\n    public int deleteBook(Integer id) {\n        String sql = \"delete from book where id = ?\";\n        return update(sql,id);\n    }\n\n    @Override\n    public int updateBook(Book book) {\n        String sql = \"update book set `name`=?,`author`=?,`price`=?,`sales`=?,`stock`=?,`img_path`= ? where id = ?\";\n        return update(sql,book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImgPath(),book.getId());\n    }\n\n    @Override\n    public Book queryBookById(Integer id) {\n        String sql = \"select `id`,`name`,`author`,`price`,`sales`,`stock`,`img_path` imgPath from book where id = ?\";\n        return queryForOne(Book.class,sql,id);\n    }\n\n    @Override\n    public List<Book> queryBooks() {\n        String sql = \"select `id`,`name`,`author`,`price`,`sales`,`stock`,`img_path` imgPath from book\";\n        return queryForList(Book.class,sql);\n    }\n}\n```\n\n```java\npackage com.bookmall.test;\n\npublic class BookDaoImplTest {\n    private BookDao bookDao = new BookDaoImpl();\n\n    @Test\n    public void addBook() {\n        bookDao.addBook(new Book(null,\"算法与数据结构(java版)\",\"张三三\",new BigDecimal(58.80),20,100,\"static/img/default.jpg\"));\n    }\n\n    @Test\n    public void deleteBook() {\n        bookDao.deleteBook(1);\n    }\n\n    @Test\n    public void updateBook() {\n        bookDao.updateBook(new Book(21,\"算法与数据结构(C++版)\",\"张三三\",new BigDecimal(58.80),20,100,\"static/img/default.jpg\"));\n    }\n\n    @Test\n    public void queryBookById() {\n        System.out.println(bookDao.queryBookById(21));\n    }\n\n    @Test\n    public void queryBooks() {\n        for(Book book:bookDao.queryBooks()){\n            System.out.println(book);\n        }\n    }\n}\n```\n\n### 4.编写图书模块的Service并测试\n\n```java\npackage com.bookmall.service.impl;\n\npublic class BookServiceImpl implements BookService {\n    private BookDao bookDao = new BookDaoImpl();\n\n    @Override\n    public void addBook(Book book) {\n        bookDao.addBook(book);\n    }\n\n    @Override\n    public void deleteBook(Integer id) {\n        bookDao.deleteBook(id);\n    }\n\n    @Override\n    public void updateBook(Book book) {\n        bookDao.updateBook(book);\n    }\n\n    @Override\n    public Book queryBookById(Integer id) {\n        return bookDao.queryBookById(id);\n    }\n\n    @Override\n    public List<Book> queryBooks() {\n        return bookDao.queryBooks();\n    }\n}\n```\n\n```java\npackage com.bookmall.test;\n\npublic class BookServiceImplTest {\n    private BookService bookService = new BookServiceImpl();\n    @Test\n    public void addBook() {\n        bookService.addBook(new Book(null,\"肉蛋葱鸡\",\"马老师\",new BigDecimal(66.66),666,66,\"static/img/cover.jpg\"));\n    }\n\n    @Test\n    public void deleteBook() {\n        bookService.deleteBook(10);\n    }\n\n    @Test\n    public void updateBook() {\n        bookService.updateBook(new Book(7,\"红皮烤鸭\",\"马老师\",new BigDecimal(99.8),100,2,\"static/img/cover.jpg\"));\n    }\n\n    @Test\n    public void queryBookById() {\n        System.out.println(bookService.queryBookById(7));\n    }\n\n    @Test\n    public void queryBooks() {\n        for(Book book :bookService.queryBooks()){\n            System.out.println(book);\n        }\n    }\n}\n```\n\n### 5.编写图书模块的Web层，和页面联调测试\n\n#### 1、实现展示全部图书\n\n![](javaweb-02/11.png)\n\n**在BookServlet.java中添加list()方法用于展示全部图书信息：**\n\n```java\nprivate BookService bookService = new BookServiceImpl();\nprotected void list(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    // 1.通过BookService查询全部图书\n    List<Book> books = bookService.queryBooks();\n    // 2.将全部的图书信息保存到request域中\n    req.setAttribute(\"books\",books);\n    // 3.请求转发\n    req.getRequestDispatcher(\"/pages/manager/book_manager.jsp\").forward(req,resp);\n}\n```\n\n**修改图书管理页面的跳转地址：**\n![](javaweb-02/12.png)\n\n**利用JSTL标签库遍历图书信息在jsp页面中输出：**\n1、导入JSTL标签库的jar包\ntaglibs-standard-impl-1.2.1.jar\ntaglibs-standard-spec-1.2.1.jar\n2、在book_manager.jsp中编写遍历图书信息的代码\n\n```html\n<c:forEach items=\"${requestScope.books}\" var=\"book\">\n\t<tr>\n\t\t<td>${book.name}</td>\n\t\t<td>${book.price}</td>\n\t\t<td>${book.author}</td>\n\t\t<td>${book.sales}</td>\n\t\t<td>${book.stock}</td>\n\t\t<td><a href=\"book_edit\">修改</a></td>\n\t\t<td><a href=\"#\">删除</a></td>\n    </tr>\n</c:forEach>\n```\n\n#### 2、实现添加图书\n\n![](javaweb-02/17.png)\n\n**在BookServlet中添加add()方法用于添加图书：**\n\n```java\nprotected void add(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //  1、获取请求的参数==封装成为Book对象\n        Book book = WebUtils.copyParamToBean(req.getParameterMap(), new Book());\n        //  2、调用BookService.addBook()保存图书\n        bookService.addBook(book);\n        // 3、跳到图书列表页面 /manager/bookServlet?action=list\n        // 请求转发会造成表单的多次提交\n        // req.getRequestDispatcher(\"/manager/bookServlet?action=list\").forward(req, resp);\n\n        // 请求重定向\n        resp.sendRedirect(req.getContextPath()+ \"/manager/bookServlet?action=list\");\n    }\n```\n\n**修改book_edit.jsp：**\n![](javaweb-02/13.png)\n\n\n![](javaweb-02/14.png)\n\n#### 3、实现删除图书\n\n![](javaweb-02/18.png)\n\n**在BookServlet中添加delete()方法：**\n\n```java\n protected void delete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 1、获取图书id\n        int id = WebUtils.parseInt(req.getParameter(\"id\"),0);\n        // 2、调用BookService.deleteById() 删除图书\n        bookService.deleteBook(id);\n        // 3、重定向 /manager/bookServlet?action=list\n        resp.sendRedirect(req.getScheme()+\"://\"+ req.getServerName()+\":\"+\n                req.getServerPort()+req.getContextPath()+ \"/manager/bookServlet?action=list\");\n    }\n```\n\n**修改book_manager.jsp：**\n![](javaweb-02/15.png)\n\n**添加确认删除提示：**\n给a标签添加class属性用于对标签选择\n![](javaweb-02/16.png)给a标签绑定单击事件：\n\n```js\n <%-- 给删除按钮绑定单击事件 用于删除操作的确认\t--%>\n<script type=\"text/javascript\">\n    // 在事件的function函数中，有一个this对象，表示当前正在响应事件的dom对象\n\t$(function () {\n\t\t$(\"a.deleteClass\").click(function(){\n\t\t\t// 确认返回true  取消返回false\n\t\t\treturn confirm(\"你确定删除《\" + $(this).parent().parent().find(\"td:first\").text() +\"》吗？\");\n\t\t\t// return false; 阻止元素的默认行为  不提交\n\t\t});\n\t});\n</script>\n```\n\n#### 4、实现修改图书\n\n![](javaweb-02/19.png)\n\n**在bookServlet中添加getBook()用于获取要修改图书的信息：**\n\n```java\n protected void getBook(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 1.获取id\n        int id = WebUtils.parseInt(req.getParameter(\"id\"),0);\n        // 2.调用BookService.queryBookById() 获取图书信息\n        Book book = bookService.queryBookById(id);\n        // 3.将图书信息保存至request域中\n        req.setAttribute(\"book\",book);\n        // 4.请求转发到 /pages/manager/book_edit.jsp\n        req.getRequestDispatcher(\"/pages/manager/book_edit.jsp\").forward(req,resp);\n    }\n```\n\n**修改book_edit.jsp让数据回显：**\n![](javaweb-02/20.png)\n\n**在BookServlet中添加update()方法：**\n\n```java\nprotected void update(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    // 1.获取从book_edit.jsp提交的表单数据  将数据封装到book对象中\n    Book book = WebUtils.copyParamToBean(req.getParameterMap(),new Book());\n    // 2.调用BookService.update()更新图书\n    bookService.updateBook(book);\n    // 3.重定向 manager/bookServlet?action=list 刷新图书列表\n    resp.sendRedirect(req.getContextPath()+ \"/manager/bookServlet?action=list\");\n}\n```\n\n**在book_edit.jsp中添加隐藏域用于回传修改图书所需要的id值：**\n![](javaweb-02/21.png)\n\n**图书信息并没有发生修改的原因：**\nbook_edit.jsp页面中既要进行添加add操作，又要进行修改update操作，最终进行何种操作是根据一个隐藏域决定的，因此需要动态修改隐藏域：在请求发起时附带上要执行操作的值，并注入隐藏域中。\n传入update参数：<img src=\"javaweb-02/22.png\" style=\"zoom:100%;\" />\n传入add参数：![](javaweb-02/23.png)\n注入隐藏域：![](javaweb-02/24.png)\n\n#### 5、实现图书的分页\n\n![](javaweb-02/25.png)\n**创建Page对象：**\n\n```java\npackage com.bookmall.bean;\n\nimport java.util.List;\n/**\n * Page为分页的模型\n * @param <T> 是具体的模块的 JavaBean 对象\n */\npublic class Page<T> {\n    public static final Integer PAGE_SIZE = 4;\n    // 当前页码\n    private Integer pageNo;\n    // 总页码\n    private Integer pageTotal;\n    // 总记录数\n    private Integer pageTotalCount;\n    // 每页显示的数量\n    private Integer pageSize = PAGE_SIZE;\n    // 当前页的数据\n    private List<T> items;\n\n    public Page() {\n    }\n\n    public Page(Integer pageNo, Integer pageTotal, Integer pageTotalCount, Integer pageSize, List<T> items) {\n        this.pageNo = pageNo;\n        this.pageTotal = pageTotal;\n        this.pageTotalCount = pageTotalCount;\n        this.pageSize = pageSize;\n        this.items = items;\n    }\n\n    public static Integer getPageSize() {\n        return PAGE_SIZE;\n    }\n\n    public void setPageSize(Integer pageSize) {\n        this.pageSize = pageSize;\n    }\n\n    public List<T> getItems() {\n        return items;\n    }\n\n    public void setItems(List<T> items) {\n        this.items = items;\n    }\n\n    public Integer getPageNo() {\n        return pageNo;\n    }\n\n    public void setPageNo(Integer pageNo) {\n        // 对页码进行检查\n        if(pageNo<1){\n            pageNo = 1;\n        }\n        if (pageNo>pageTotal){\n            pageNo = pageTotal;\n        }\n        this.pageNo = pageNo;\n    }\n\n    public Integer getPageTotal() {\n        return pageTotal;\n    }\n\n    public void setPageTotal(Integer pageTotal) {\n        this.pageTotal = pageTotal;\n    }\n\n    public Integer getPageTotalCount() {\n        return pageTotalCount;\n    }\n\n    public void setPageTotalCount(Integer pageTotalCount) {\n        this.pageTotalCount = pageTotalCount;\n    }\n\n    @Override\n    public String toString() {\n        return \"Page{\" +\n                \"pageNo=\" + pageNo +\n                \", pageTotal=\" + pageTotal +\n                \", pageTotalCount=\" + pageTotalCount +\n                \", pageSize=\" + pageSize +\n                \", items=\" + items +\n                '}';\n    }\n}\n```\n\n**在BookServlet中添page()用于处理分页：**\n\n```java\nprotected void page(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 1.获取js页面传来的请求参数 pageNo 和 pageSize\n        int pageNo = WebUtils.parseInt(req.getParameter(\"pageNo\"),1);\n        int pageSize = WebUtils.parseInt(req.getParameter(\"pageSize\"), Page.PAGE_SIZE);\n        // 2.调用BookService.page(pageNo,pageSize) 得到Page对象\n        Page<Book> page = bookService.page(pageNo, pageSize);\n        // 3.将Page对象保存到Request域中\n        req.setAttribute(\"page\",page);\n        // 4.请求转发到 /pages/manager/book_manager.jsp\n        req.getRequestDispatcher(\"/pages/manager/book_manager.jsp\").forward(req,resp);\n    }\n```\n\n**在BookService中添加page(pageNo,pageSize) 获取page对象：**\n\n```java\n/**\n     * 查询分页\n     * @param pageNo\n     * @param pageSize\n     * @return 返回一个Page对象\n     */\n    public Page<Book> page(int pageNo, int pageSize);\n```\n\n**在BookServiceImpl中实现page(pageNo,pageSize)：**\n\n```java\n @Override\n    public Page<Book> page(int pageNo, int pageSize) {\n        Page<Book> bookPage = new Page<>();\n        //设置每页显示的数量\n        bookPage.setPageSize(pageSize);\n        // 设置总记录数\n        Integer pageTotalCount = bookDao.queryForPageTotalCount();\n        bookPage.setPageTotalCount(pageTotalCount);\n        // 设置总页码\n        Integer pageTotal = pageTotalCount/pageSize;\n        if (pageTotalCount % pageSize>0){\n            pageTotal++;\n        }\n        bookPage.setPageTotal(pageTotal);\n        // 设置当前页码\n        bookPage.setPageNo(pageNo);\n        // 设置当页数据\n        int begin = (bookPage.getPageNo()-1)*pageSize;\n        bookPage.setItems(bookDao.queryForItems(begin,pageSize));\n        return bookPage;\n    }\n```\n\n**在BookDao中添加queryForPageTotal()和queryForItems()方法：**\n\n```java\n    /**\n     * 查询图书的总记录数\n     * @return\n     */\n    public Integer queryForPageTotalCount();\n\n    /**\n     * 查询当前页面的图书记录\n     * @param begin\n     * @param pageSize\n     * @return\n     */\n    List<Book> queryForItems(int begin, int pageSize);\n```\n\n**在BookDaoImpl中实现queryForPageTotal()和queryForItems()方法：**\n\n```java\n    @Override\n    public Integer queryForPageTotalCount() {\n        String sql = \"select count(*) from book\";\n        Number count = (Number) queryForSingleValue(sql);\n        return  count.intValue();\n    }\n\n    @Override\n    public List<Book> queryForItems(int begin, int pageSize) {\n        String sql = \" select `id`, `name`,`author`,`price`,`sales`,`stock`,`img_path` imgPath from book limit ?,?\";\n        return queryForList(Book.class,sql,begin,pageSize);\n    }\n```\n\n**修改manage_menu.jsp页面显示分页后的内容：**\n![](javaweb-02/26.png)\n\n**修改book_manage.jsp页面，让下方显示页面跳转的功能按键：**\n\n```js\n <script type=\"text/javascript\">\n        // 在事件的function函数中，有一个this对象，表示当前正在响应事件的dom对象\n        $(function () {\n            <%-- 给删除按钮绑定单击事件 用于删除操作的确认\t--%>\n            $(\"a.deleteClass\").click(function () {\n                // 确认返回true  取消返回false\n                return confirm(\"你确定删除《\" + $(this).parent().parent().find(\"td:first\").text() + \"》吗？\");\n                // return false; 阻止元素的默认行为  不提交\n            });\n\n            $(\"#searchPageBtn\").click(function () {\n                var pageNo = $(\"#pn_input\").val();\n                location.href = \"${pageScope.basePath}manager/bookServlet?action=page&pageNo=\" + pageNo;\n            });\n        });\n    </script>\n```\n\n修改hesd.jsp 将basePath保存至pageContext域中：供指定页面跳转时使用\n![](javaweb-02/27.png)\n\n```html\n<div id=\"page_nav\">\n    <%-- 大于首页才显示--%>\n    <c:if test=\"${requestScope.page.pageNo>1}\">\n        <a href=\"manager/bookServlet?action=page&pageNo=1\">首页</a>\n        <a href=\"manager/bookServlet?action=page&pageNo=${requestScope.page.pageNo-1}\">上一页</a>\n    </c:if>\n\n    <%--  页码输出的开始--%>\n    <c:choose>\n        <%-- 情况1：如果总页码<=5,页码的范围是1~总页码 --%>\n        <c:when test=\"${requestScope.page.pageTotal<=5}\">\n            <c:forEach begin=\"1\" end=\"${requestScope.page.pageTotal}\" var=\"i\">\n                <c:if test=\"${requestScope.page.pageNo==i}\">\n                    【${i}】\n                </c:if>\n                <c:if test=\"${requestScope.page.pageNo!=i}\">\n                    <a href=\"manager/bookServlet?action=page&pageNo=${i}\">${i}</a>\n                </c:if>\n            </c:forEach>\n        </c:when>\n        <%--情况2：总页码>5 --%>\n        <c:when test=\"${requestScope.page.pageTotal>5}\">\n            <c:choose>\n                <%-- 当前页码为前面3个：页码范围是：1~5--%>\n                <c:when test=\"${requestScope.page.pageNo<=3}\">\n                    <c:forEach begin=\"1\" end=\"5\" var=\"i\">\n                        <c:if test=\"${requestScope.page.pageNo==i}\">\n                            【${i}】\n                        </c:if>\n                        <c:if test=\"${requestScope.page.pageNo!=i}\">\n                            <a href=\"manager/bookServlet?action=page&pageNo=${i}\">${i}</a>\n                        </c:if>\n                    </c:forEach>\n                </c:when>\n                <%-- 当前页码为后面3个：页码范围是：当前页码-2~末页--%>\n                <c:when test=\"${requestScope.page.pageNo>=requestScope.page.pageTotal-2}\">\n                    <c:forEach begin=\"${requestScope.page.pageNo-4}\" end=\"${requestScope.page.pageTotal}\" var=\"i\">\n                        <c:if test=\"${requestScope.page.pageNo==i}\">\n                            【${i}】\n                        </c:if>\n                        <c:if test=\"${requestScope.page.pageNo!=i}\">\n                            <a href=\"manager/bookServlet?action=page&pageNo=${i}\">${i}</a>\n                        </c:if>\n                    </c:forEach>\n                </c:when>\n                <%-- 当前页码为中间3个：页码范围是：当前页码-2~当前页码+2--%>\n                <c:otherwise>\n                    <c:forEach begin=\"${requestScope.page.pageNo-2}\" end=\"${requestScope.page.pageNo+2}\" var=\"i\">\n                        <c:if test=\"${requestScope.page.pageNo==i}\">\n                            【${i}】\n                        </c:if>\n                        <c:if test=\"${requestScope.page.pageNo!=i}\">\n                            <a href=\"manager/bookServlet?action=page&pageNo=${i}\">${i}</a>\n                        </c:if>\n                    </c:forEach>\n                </c:otherwise>\n            </c:choose>\n        </c:when>\n    </c:choose>\n    <%--  页码输出的结束--%>\n\n    <%--  小于末页才显示--%>\n    <c:if test=\"${requestScope.page.pageNo<requestScope.page.pageTotal}\">\n        <a href=\"manager/bookServlet?action=page&pageNo=${requestScope.page.pageNo+1}\">下一页</a>\n        <a href=\"manager/bookServlet?action=page&pageNo=${requestScope.page.pageTotal}\">末页</a>\n    </c:if>\n    共${requestScope.page.pageTotal}页，${requestScope.page.pageTotalCount}条记录\n    到第<input value=\"${param.pageNo}\" name=\"pn\" id=\"pn_input\"/>页\n    <input id=\"searchPageBtn\" type=\"button\" value=\"确定\">\n</div>\n```\n\n**修改增删改操作的重定向地址并传入pageNo参数：**\n![](javaweb-02/28.png)\n\n**在book_manager.jsp传入页码pageNo：**\n![](javaweb-02/29.png)\n\n**在book_edit.jsp中添加隐藏域用于传递pageNo给BookServlet：**\n![](javaweb-02/30.png)\n\n**前台图书的分页展示：**|\n![](javaweb-02/31.png)\n\nweb目录下的index.jsp只负责转发：\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n\n<%--只负责请求转发--%>\n<jsp:forward page=\"/client/clientBookServlet?action=page\"></jsp:forward>\n```\n\n创建ClientBookServlet用于处理前台的分页请求：\n\n```java\npackage com.bookmall.web;\n\npublic class ClientBookServlet extends BaseServlet {\n\n    private BookService bookService = new BookServiceImpl();\n    /**\n     * 处理图书分页\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void page(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"经过了前台的ClientBookServlet\");\n        // 1.获取js页面传来的请求参数 pageNo 和 pageSize\n        int pageNo = WebUtils.parseInt(req.getParameter(\"pageNo\"),1);\n        int pageSize = WebUtils.parseInt(req.getParameter(\"pageSize\"), Page.PAGE_SIZE);\n        // 2.调用BookService.page(pageNo,pageSize) 得到Page对象\n        Page<Book> page = bookService.page(pageNo, pageSize);\n        // 3.将Page对象保存到Request域中\n        req.setAttribute(\"page\",page);\n        // 4.请求转发到 /pages/client/index.jsp\n        req.getRequestDispatcher(\"/pages/client/index.jsp\").forward(req,resp);\n    }\n}\n```\n\n在web目录的/page/client/路径下创建index.jsp用于显示前台图书信息：\n\n```html\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>书城首页</title>\n    <%-- 静态包含 base标签、css样式、jquery文件   --%>\n    <%@include file=\"/pages/common/head.jsp\" %>\n    <script type=\"text/javascript\">\n        $(function(){\n            $(\"#searchPageBtn\").click(function(){\n                var pageNo = $(\"#pn_input\").val();\n                location.href = \"${pageScope.basePath}client/clientBookServlet?action=page&pageNo=\"+pageNo;\n            });\n        })\n    </script>\n</head>\n<body>\n\n<div id=\"header\">\n\n    <span class=\"wel_word\">网上书城</span>\n    <div>\n        <a href=\"pages/user/login.jsp\">登录</a> |\n        <a href=\"pages/user/regist.jsp\">注册</a> &nbsp;&nbsp;\n        <a href=\"pages/cart/cart.jsp\">购物车</a>\n        <a href=\"pages/manager/manager.jsp\">后台管理</a>\n    </div>\n</div>\n<div id=\"main\">\n    <div id=\"book\">\n        <div class=\"book_cond\">\n            <form action=\"\" method=\"get\">\n                价格：<input id=\"min\" type=\"text\" name=\"min\" value=\"\"> 元 -\n                <input id=\"max\" type=\"text\" name=\"max\" value=\"\"> 元\n                <input type=\"submit\" value=\"查询\"/>\n            </form>\n        </div>\n        <div style=\"text-align: center\">\n            <span>您的购物车中有3件商品</span>\n            <div>\n                您刚刚将<span style=\"color: red\">时间简史</span>加入到了购物车中\n            </div>\n        </div>\n        <c:forEach items=\"${requestScope.page.items}\" var=\"book\">\n            <div class=\"b_list\">\n                <div class=\"img_div\">\n                    <img class=\"book_img\" alt=\"\" src=\"${book.imgPath}\"/>\n                </div>\n                <div class=\"book_info\">\n                    <div class=\"book_name\">\n                        <span class=\"sp1\">书名:</span>\n                        <span class=\"sp2\">${book.name}</span>\n                    </div>\n                    <div class=\"book_author\">\n                        <span class=\"sp1\">作者:</span>\n                        <span class=\"sp2\">${book.author}</span>\n                    </div>\n                    <div class=\"book_price\">\n                        <span class=\"sp1\">价格:￥</span>\n                        <span class=\"sp2\">${book.price}</span>\n                    </div>\n                    <div class=\"book_sales\">\n                        <span class=\"sp1\">销量:</span>\n                        <span class=\"sp2\">${book.sales}</span>\n                    </div>\n                    <div class=\"book_amount\">\n                        <span class=\"sp1\">库存:</span>\n                        <span class=\"sp2\">${book.stock}</span>\n                    </div>\n                    <div class=\"book_add\">\n                        <button>加入购物车</button>\n                    </div>\n                </div>\n            </div>\n        </c:forEach>\n    </div>\n\n    <div id=\"page_nav\">\n        <%-- 大于首页才显示--%>\n        <c:if test=\"${requestScope.page.pageNo>1}\">\n            <a href=\"client/clientBookServlet?action=page&pageNo=1\">首页</a>\n            <a href=\"client/clientBookServlet?action=page&pageNo=${requestScope.page.pageNo-1}\">上一页</a>\n        </c:if>\n\n        <%--  页码输出的开始--%>\n        <c:choose>\n            <%-- 情况1：如果总页码<=5,页码的范围是1~总页码 --%>\n            <c:when test=\"${requestScope.page.pageTotal<=5}\">\n                <c:forEach begin=\"1\" end=\"${requestScope.page.pageTotal}\" var=\"i\">\n                    <c:if test=\"${requestScope.page.pageNo==i}\">\n                        【${i}】\n                    </c:if>\n                    <c:if test=\"${requestScope.page.pageNo!=i}\">\n                        <a href=\"client/clientBookServlet?action=page&pageNo=${i}\">${i}</a>\n                    </c:if>\n                </c:forEach>\n            </c:when>\n            <%--情况2：总页码>5 --%>\n            <c:when test=\"${requestScope.page.pageTotal>5}\">\n                <c:choose>\n                    <%-- 当前页码为前面3个：页码范围是：1~5--%>\n                    <c:when test=\"${requestScope.page.pageNo<=3}\">\n                        <c:forEach begin=\"1\" end=\"5\" var=\"i\">\n                            <c:if test=\"${requestScope.page.pageNo==i}\">\n                                【${i}】\n                            </c:if>\n                            <c:if test=\"${requestScope.page.pageNo!=i}\">\n                                <a href=\"client/clientBookServlet?action=page&pageNo=${i}\">${i}</a>\n                            </c:if>\n                        </c:forEach>\n                    </c:when>\n                    <%-- 当前页码为后面3个：页码范围是：当前页码-2~末页--%>\n                    <c:when test=\"${requestScope.page.pageNo>=requestScope.page.pageTotal-2}\">\n                        <c:forEach begin=\"${requestScope.page.pageNo-4}\" end=\"${requestScope.page.pageTotal}\" var=\"i\">\n                            <c:if test=\"${requestScope.page.pageNo==i}\">\n                                【${i}】\n                            </c:if>\n                            <c:if test=\"${requestScope.page.pageNo!=i}\">\n                                <a href=\"client/clientBookServlet?action=page&pageNo=${i}\">${i}</a>\n                            </c:if>\n                        </c:forEach>\n                    </c:when>\n                    <%-- 当前页码为中间3个：页码范围是：当前页码-2~当前页码+2--%>\n                    <c:otherwise>\n                        <c:forEach begin=\"${requestScope.page.pageNo-2}\" end=\"${requestScope.page.pageNo+2}\" var=\"i\">\n                            <c:if test=\"${requestScope.page.pageNo==i}\">\n                                【${i}】\n                            </c:if>\n                            <c:if test=\"${requestScope.page.pageNo!=i}\">\n                                <a href=\"client/clientBookServlet?action=page&pageNo=${i}\">${i}</a>\n                            </c:if>\n                        </c:forEach>\n                    </c:otherwise>\n                </c:choose>\n            </c:when>\n        </c:choose>\n        <%--  页码输出的结束--%>\n\n        <%--  小于末页才显示--%>\n        <c:if test=\"${requestScope.page.pageNo<requestScope.page.pageTotal}\">\n            <a href=\"client/clientBookServlet?action=page&pageNo=${requestScope.page.pageNo+1}\">下一页</a>\n            <a href=\"client/clientBookServlet?action=page&pageNo=${requestScope.page.pageTotal}\">末页</a>\n        </c:if>\n        共${requestScope.page.pageTotal}页，${requestScope.page.pageTotalCount}条记录\n        到第<input value=\"${param.pageNo}\" name=\"pn\" id=\"pn_input\"/>页\n        <input id=\"searchPageBtn\"  type=\"button\" value=\"确定\">\n    </div>\n</div>\n\n<%@include file=\"/pages/common/footer.jsp\" %>\n</body>\n</html>\n```\n\n**抽取分页：**\n在Page对象中添加url属性以及相应的get 和set方法：\n![](javaweb-02/32.png)\n分别在BookServlet和ClientBookServlet中设置url属性值：\n![](javaweb-02/33.png)\n\n\n![](javaweb-02/34.png)\n\n分别将index.jsp和book_manager.jsp中出现的相应的地址值替换为```${requestScope.page.url}```\n\n在/pages/common/下创建page_nav.jsp用于提取分页代码：\n\n```html\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<div id=\"page_nav\">\n    <%-- 大于首页才显示--%>\n    <c:if test=\"${requestScope.page.pageNo>1}\">\n        <a href=\"${requestScope.page.url}&pageNo=1\">首页</a>\n        <a href=\"${requestScope.page.url}&pageNo=${requestScope.page.pageNo-1}\">上一页</a>\n    </c:if>\n\n    <%--  页码输出的开始--%>\n    <c:choose>\n        <%-- 情况1：如果总页码<=5,页码的范围是1~总页码 --%>\n        <c:when test=\"${requestScope.page.pageTotal<=5}\">\n            <c:forEach begin=\"1\" end=\"${requestScope.page.pageTotal}\" var=\"i\">\n                <c:if test=\"${requestScope.page.pageNo==i}\">\n                    【${i}】\n                </c:if>\n                <c:if test=\"${requestScope.page.pageNo!=i}\">\n                    <a href=\"${requestScope.page.url}&pageNo=${i}\">${i}</a>\n                </c:if>\n            </c:forEach>\n        </c:when>\n        <%--情况2：总页码>5 --%>\n        <c:when test=\"${requestScope.page.pageTotal>5}\">\n            <c:choose>\n                <%-- 当前页码为前面3个：页码范围是：1~5--%>\n                <c:when test=\"${requestScope.page.pageNo<=3}\">\n                    <c:forEach begin=\"1\" end=\"5\" var=\"i\">\n                        <c:if test=\"${requestScope.page.pageNo==i}\">\n                            【${i}】\n                        </c:if>\n                        <c:if test=\"${requestScope.page.pageNo!=i}\">\n                            <a href=\"${requestScope.page.url}&pageNo=${i}\">${i}</a>\n                        </c:if>\n                    </c:forEach>\n                </c:when>\n                <%-- 当前页码为后面3个：页码范围是：当前页码-2~末页--%>\n                <c:when test=\"${requestScope.page.pageNo>=requestScope.page.pageTotal-2}\">\n                    <c:forEach begin=\"${requestScope.page.pageNo-4}\" end=\"${requestScope.page.pageTotal}\" var=\"i\">\n                        <c:if test=\"${requestScope.page.pageNo==i}\">\n                            【${i}】\n                        </c:if>\n                        <c:if test=\"${requestScope.page.pageNo!=i}\">\n                            <a href=\"${requestScope.page.url}&pageNo=${i}\">${i}</a>\n                        </c:if>\n                    </c:forEach>\n                </c:when>\n                <%-- 当前页码为中间3个：页码范围是：当前页码-2~当前页码+2--%>\n                <c:otherwise>\n                    <c:forEach begin=\"${requestScope.page.pageNo-2}\" end=\"${requestScope.page.pageNo+2}\" var=\"i\">\n                        <c:if test=\"${requestScope.page.pageNo==i}\">\n                            【${i}】\n                        </c:if>\n                        <c:if test=\"${requestScope.page.pageNo!=i}\">\n                            <a href=\"${requestScope.page.url}&pageNo=${i}\">${i}</a>\n                        </c:if>\n                    </c:forEach>\n                </c:otherwise>\n            </c:choose>\n        </c:when>\n    </c:choose>\n    <%--  页码输出的结束--%>\n\n    <%--  小于末页才显示--%>\n    <c:if test=\"${requestScope.page.pageNo<requestScope.page.pageTotal}\">\n        <a href=\"${requestScope.page.url}&pageNo=${requestScope.page.pageNo+1}\">下一页</a>\n        <a href=\"${requestScope.page.url}&pageNo=${requestScope.page.pageTotal}\">末页</a>\n    </c:if>\n    共${requestScope.page.pageTotal}页，${requestScope.page.pageTotalCount}条记录\n    到第<input value=\"${param.pageNo}\" name=\"pn\" id=\"pn_input\"/>页\n    <input id=\"searchPageBtn\" type=\"button\" value=\"确定\">\n</div>\n```\n\n在index.jsp和book_mansger.jsp中的分页代码替换成静态包含代码：\n\n```html\n <%@include file=\"/pages/common/page_nav.jsp\"%>\n```\n\n#### 6、实现价格区间的搜索功能：\n\n![](javaweb-02/35.png)\n\n**在ClientBookClient中添加pageByPrice()方法用于处理搜索请求：**\n\n```java\nprotected void pageByPrice(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    // 1.获取请求参数 pageNo,pageSize,min,max\n    int pageNo = WebUtils.parseInt(req.getParameter(\"pageNo\"),1);\n    int pageSize = WebUtils.parseInt(req.getParameter(\"pageSize\"),Page.PAGE_SIZE);\n    int min = WebUtils.parseInt(req.getParameter(\"min\"),0);\n    int max = WebUtils.parseInt(req.getParameter(\"max\"),Integer.MAX_VALUE);\n    // 2.调用bookService.pageByPrice(pageNo,pageSize,min,max) 返回page对象\n    Page<Book> page = bookService.pageByPrice(pageNo,pageSize,min,max);\n    //设置请求地址 分页时需要传递价格区间\n    StringBuilder stringBuilder = new StringBuilder(\"client/clientBookServlet?action=pageByPrice\");\n    // 对价格区间进行检查\n    if(req.getParameter(\"min\")!=null){\n        stringBuilder.append(\"&min=\").append(req.getParameter(\"min\"));\n    }\n    if(req.getParameter(\"max\")!=null){\n        stringBuilder.append(\"&max=\").append(req.getParameter(\"max\"));\n    }\n    page.setUrl(stringBuilder.toString());\n\n    // 3.将Page对象保存到Request域中\n    req.setAttribute(\"page\",page);\n    // 4.请求转发到\n    req.getRequestDispatcher(\"/pages/client/index.jsp\").forward(req,resp);\n}\n```\n\n**在BookService中添加pageByPrice(pageNo,pageSize,min,max)方法：**\n\n```java\n/**\n * 根据价格区间获取page对象\n * @param pageNo\n * @param pageSize\n * @param min\n * @param max\n * @return\n */\nPage<Book> pageByPrice(int pageNo, int pageSize, int min, int max);\n```\n\n**在BookServiceImpl中实现pageByPrice(pageNo,pageSize,min,max)方法：**\n\n```java\n@Override\npublic Page<Book> pageByPrice(int pageNo, int pageSize, int min, int max) {\n    Page<Book> bookPage = new Page<>();\n\n    //设置每页显示的数量\n    bookPage.setPageSize(pageSize);\n    // 设置总记录数\n    Integer pageTotalCount = bookDao.queryForPageTotalCountByPrice(min,max);\n    bookPage.setPageTotalCount(pageTotalCount);\n    // 设置总页码\n    Integer pageTotal = pageTotalCount/pageSize;\n    if (pageTotalCount % pageSize>0){\n        pageTotal++;\n    }\n    bookPage.setPageTotal(pageTotal);\n    // 设置当前页码\n    bookPage.setPageNo(pageNo);\n    // 设置当页数据\n    int begin = (bookPage.getPageNo()-1)*pageSize;\n    bookPage.setItems(bookDao.queryForItemsByPrice(begin,pageSize,min,max));\n    return bookPage;\n}\n```\n\n**在BookDao中添加queryForPageTotalCountByPrice(int min, int max)和queryForItemsByPrice(int begin, int pageSize, int min, int max)方法：**\n\n```java\n /**\n     * 根据价格区间查询总记录数\n     * @param min\n     * @param max\n     * @return\n     */\n    Integer queryForPageTotalCountByPrice(int min, int max);\n\n    /**\n     * 根据价格区间查询所有记录\n     * @param begin\n     * @param pageSize\n     * @param min\n     * @param max\n     * @return\n     */\n    List<Book> queryForItemsByPrice(int begin, int pageSize, int min, int max);\n}\n```\n\n**在BookDaoImpl中实现这两种方法：**\n\n```java\n@Override\npublic Integer queryForPageTotalCountByPrice(int min, int max) {\n    String sql = \"select count(*) from book where price between ? and ?\";\n    Number count = (Number) queryForSingleValue(sql,min,max);\n    return  count.intValue();\n}\n\n@Override\npublic List<Book> queryForItemsByPrice(int begin, int pageSize, int min, int max) {\n    String sql = \" select `id`, `name`,`author`,`price`,`sales`,`stock`,`img_path` imgPath from book\" +\n            \" where price between ? and ? order by price limit ?,?\";\n    return queryForList(Book.class,sql,min,max,begin,pageSize);\n}\n```\n\n**修改index.jsp向服务器提交搜索请求：**\n\n```html\n<div class=\"book_cond\">\n        <form action=\"client/clientBookServlet\" method=\"get\">\n            <input type=\"hidden\" name=\"action\" value=\"pageByPrice\"/>\n            价格：<input id=\"min\" type=\"text\" name=\"min\" value=\"${param.min}\"> 元 -\n            <input id=\"max\" type=\"text\" name=\"max\" value=\"${param.max}\"> 元\n            <input type=\"submit\" value=\"查询\"/>\n        </form>\n</div>\n```\n\n## 十一、保存用户登录之后的信息\n\n在UserServlet添加保存用户登录信息到Session域中的代码：\n![](javaweb-02/36.png)\n\n在login_success_menu.jsp中 显示用户姓名：\n![](javaweb-02/37.png)\n\n修改index.jsp的菜单显示：\n\n```html\n<div>\n     <%--  如果用户还没有登录，显示登录和注册菜单 --%>\n     <c:if test=\"${empty sessionScope.user}\">\n      \t<a href=\"pages/user/login.jsp\">登录</a>/\n         <a href=\"pages/user/regist.jsp\">注册</a>\n     </c:if>\n\n     <%--  如果用户已经登录，则显示登录成功之后用户的信息 --%>\n     <c:if test=\"${not empty sessionScope.user}\">\n         <span>欢迎<span class=\"um_span\">${sessionScope.user.username}</span>光临书城</span>\n         <a href=\"pages/order/order.jsp\">我的订单</a>\n         <a href=\"pages/cart/cart.jsp\">购物车</a>\n         <a href=\"pages/manager/manager.jsp\">后台管理</a>\n         <a href=\"index.jsp\">注销</a>&nbsp;\n     </c:if>\n</div>\n```\n\n**<font color=\"red\">注意：</font>**\n固定相对路径跳转使用的地址必须是相对路径，否则在进行跳转时Tomcat会创建一个新的Session，造成Session会话信息丢失！\n![](javaweb-02/38.png)\n\n## 十二、注销登录\n\n在userServlet中添加logout()方法用于处理注销请求：\n\n```java\nprotected void logout(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    // 1.销毁 Session\n    req.getSession().invalidate();\n    // 2.重定向到首页\n    resp.sendRedirect(req.getContextPath());\n}\n```\n\n修改jsp页面的跳转地址：\n![](javaweb-02/39.png)\n\n## 十三、使用验证码解决表单的重复提交\n\n表单重复提交有三种常见的情况：\n一：提交完表单。服务器使用请求转来进行页面跳转。这个时候，用户按下功能键F5，就会发起最后一次的请求。造成表单重复提交问题。解决方法：使用重定向来进行跳转。\n二：用户正常提交服务器，但是由于网络延迟等原因，迟迟未收到服务器的响应，这个时候，用户以为提交失败，\n就会着急，然后多点了几次提交操作，也会造成表单重复提交。\n三：用户正常提交服务器。服务器也没有延迟，但是提交完成后，用户回退浏览器。重新提交。也会造成表单重复\n提交。\n![](javaweb-02/40.png)\n\n1.导入谷歌验证码的jar包：kaptcha-2.3.2.jar\n2.在web.xml中配置用于访问生成验证码的Servlet程序的地址\n\n```xml\n<servlet>\n        <servlet-name>KaptchaServlet</servlet-name>\n        <servlet-class>com.google.code.kaptcha.servlet.KaptchaServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n        <servlet-name>KaptchaServlet</servlet-name>\n        <url-pattern>/kaptcha.jpg</url-pattern>\n</servlet-mapping>\n```\n\n3.在表单中使用img标签显示验证码图片\n\n```html\n <label>验证码：</label>\n <input class=\"itxt\" type=\"text\" style=\"width: 150px;\" name=\"code\" id=\"code\"/>\n <img id=\"code_img\" alt=\"\" src=\"kaptcha.jpg\" style=\"float: right; height: 40px; width:120px\">\n <br/>\n <span style=\"float: right;font-size: 80%\">看不清？点击图片刷新</span>\n <br/>\n```\n\n4.在服务端中获取生成的验证码并于与客户端发送过来的验证码比较\n![](javaweb-02/41.png)\n\n5.给验证码图片绑定单击事件用于刷新验证码：\n\n```javascript\n// 给验证码图片绑定单击事件\n$(\"#code_img\").click(function () {\n\t// 添加一个随机数避免请求地址相同，因为浏览器缓存造成不刷新\n\tthis.src = \"${basePath}kaptcha.jpg?n=\"+ Math.random();\n});\n```\n\n## 十四、购物车模块\n\n![](javaweb-02/42.png)\n\n### 1、创建购物车对象\n\n```java\npublic class Cart {\n    // private Integer totalCount;// 商品总数\n    // private BigDecimal totalPrice;// 总商品金额\n    private Map<Integer, CartItem> items = new LinkedHashMap<Integer, CartItem>();\n\n    public Integer getTotalCount() {\n        Integer totalCount = 0;\n        for (Map.Entry<Integer, CartItem> entry : items.entrySet()) {\n            totalCount += entry.getValue().getCount();\n        }\n        return totalCount;\n    }\n\n    public BigDecimal getTotalPrice() {\n        BigDecimal totalPrice = new BigDecimal(0);\n        for (Map.Entry<Integer, CartItem> entry : items.entrySet()) {\n            totalPrice = totalPrice.add(entry.getValue().getTotalPrice());\n        }\n        return totalPrice;\n    }\n\n    public Map<Integer, CartItem> getItems() {\n        return items;\n    }\n\n    public void setItems(Map<Integer, CartItem> items) {\n        this.items = items;\n    }\n\n    @Override\n    public String toString() {\n        return \"Cart{\" +\n                \"totalCount=\" + getTotalCount() +\n                \", totalPrice=\" + getTotalPrice() +\n                \", items=\" + items +\n                '}';\n    }\n\n    // 添加商品项\n    public void addItem(CartItem cartItem) {\n        // 判断商品是否已经添加\n        CartItem item = items.get(cartItem.getId());\n        if (item == null) {\n            items.put(cartItem.getId(), cartItem);\n        } else {\n            item.setCount(item.getCount() + 1);\n            item.setTotalPrice(item.getPrice().multiply(new BigDecimal(item.getCount())));\n        }\n    }\n\n    // 删除商品项\n    public void deleteItem(Integer id) {\n        items.remove(id);\n    }\n\n    // 清空购物车\n    public void clean() {\n        items.clear();\n    }\n\n    // 修改商品数量\n    public void updateCount(Integer id, Integer count) {\n        CartItem item = items.get(id);\n        if (item != null) {\n            item.setCount(count);\n            item.setTotalPrice(item.getPrice().multiply(new BigDecimal(item.getCount())));\n        }\n    }\n}\n```\n\n### 2、创建购物车商品项\n\n```java\npublic class CartItem {\n    private Integer id;\n    private String name;\n    private Integer count; // 数量\n    private BigDecimal price; // 单价\n    private BigDecimal totalPrice;// 商品总价\n\n    public CartItem() {\n    }\n\n    public CartItem(Integer id, String name, Integer count, BigDecimal price, BigDecimal totalPrice) {\n        this.id = id;\n        this.name = name;\n        this.count = count;\n        this.price = price;\n        this.totalPrice = totalPrice;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getCount() {\n        return count;\n    }\n\n    public void setCount(Integer count) {\n        this.count = count;\n    }\n\n    public BigDecimal getPrice() {\n        return price;\n    }\n\n    public void setPrice(BigDecimal price) {\n        this.price = price;\n    }\n\n    public BigDecimal getTotalPrice() {\n        return totalPrice;\n    }\n\n    public void setTotalPrice(BigDecimal totalPrice) {\n        this.totalPrice = totalPrice;\n    }\n\n    @Override\n    public String toString() {\n        return \"CartItem{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", count=\" + count +\n                \", price=\" + price +\n                \", totalPrice=\" + totalPrice +\n                '}';\n    }\n}\n```\n\n### 3、CartServlet用于处理商品的添加、删除、清空和修改数量\n\n```java\npublic class CartServlet extends BaseServlet {\n    private BookService bookService = new BookServiceImpl();\n    \n    protected void addItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // System.out.println(\"加入购物车\");\n        // 获取请求参数  商品编号\n        int id = WebUtils.parseInt(req.getParameter(\"id\"),0);\n        // 调用bookService.queryBookById(id) 得到图书信息\n        Book book = bookService.queryBookById(id);\n        // 将图书信息转换位CartItem商品项\n        CartItem cartItem = new CartItem(book.getId(),book.getName(),1,book.getPrice(),book.getPrice());\n        // 调用cart.add(CartItem)添加至购物车\n        Cart cart = (Cart) req.getSession().getAttribute(\"cart\");\n        if(cart == null){\n            cart = new Cart();\n            req.getSession().setAttribute(\"cart\",cart);\n        }\n        cart.addItem(cartItem);\n        // System.out.println(cart);\n        // 重定向到原来商品所在的页面\n        resp.sendRedirect(req.getHeader(\"Referer\"));\n    }\n\n    protected void deleteItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 获取请求参数 id\n        int id = WebUtils.parseInt(req.getParameter(\"id\"),0);\n        // 调用cart.deleteItem(id)\n        Cart cart = (Cart) req.getSession().getAttribute(\"cart\");\n        if(cart != null){\n            cart.deleteItem(id);\n        }\n       resp.sendRedirect(req.getHeader(\"Referer\"));\n    }\n    \n    protected void clear(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 获取购物车对象\n        Cart cart = (Cart) req.getSession().getAttribute(\"cart\");\n        // 调用cart.clear()\n        if(cart!=null){\n            cart.clear();\n        }\n        resp.sendRedirect(req.getHeader(\"Referer\"));\n    }\n\n    protected void updateCount(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 获取请求的参数  商品编号  商品数量\n        int id = WebUtils.parseInt(req.getParameter(\"id\"),0);\n        int count = WebUtils.parseInt(req.getParameter(\"count\"), 1);\n        // 获取Cart对象\n        Cart cart = (Cart) req.getSession().getAttribute(\"cart\");\n        if(cart!=null){\n            // 调用updateCount方法\n            cart.updateCount(id,count);\n        }\n        resp.sendRedirect(req.getHeader(\"Referer\"));\n    }\n}\n```\n\n### 4、购物车页面的展示\n\n```html\n<script type=\"text/javascript\">\n    $(function () {\n        // 给删除商品绑定单击事件\n        $(\"a.deleteItem\").click(function () {\n            return confirm(\"确定从购物车中删除《\"+$(this).parent().parent().find(\"td:first\").text()+\"》吗？\")\n        });\n        // 给清空购物车绑定单击事件\n        $(\"#clearCart\").click(function(){\n           return  confirm(\"确定清空购物车？\");\n        });\n        // 给修改商品数量绑定失去焦点事件  --- onchange事件判断内容是否改变\n        $(\".updateCount\").change(function(){\n            var id = $(this).attr(\"bookId\");\n            var count = this.value;\n            if(confirm(\"确定修改商品的数量为 \"+count+\" 吗？\")&&count>0){\n                location.href=\"${PageScope.basePath}cartServlet?action=updateCount&count=\"+count+\"&id=\"+id;\n            }else{\n                this.value = this.defaultValue;// 恢复到原来的数据\n            }\n        });\n    })\n</script>\n<body>\n<div id=\"header\">\n    <span class=\"wel_word\">购物车</span>\n        <%--   静态包含，登录成功之后的菜单    --%>\n        <%@include file=\"/pages/common/login_sucess_menu.jsp\" %>\n</div>\n<div id=\"main\">\n    <table>\n        <tr>\n            <td>商品名称</td>\n            <td>数量</td>\n            <td>单价</td>\n            <td>金额</td>\n            <td>操作</td>\n        </tr>\n        <c:if test=\"${empty sessionScope.cart.items}\">\n            <tr>\n                <td colspan=\"5\"><a href=\"index.jsp\">当前购物车为空！点击浏览商品</a></td>\n            </tr>\n        </c:if>\n\n        <c:if test=\"${not empty sessionScope.cart.items}\">\n            <%-- 购物车非空才输出--%>\n            <c:forEach items=\"${sessionScope.cart.items}\" var=\"entry\">\n                <tr>\n                    <td>${entry.value.name}</td>\n                    <td>\n                         <input class=\"updateCount\"\n                                style=\"width: 80px;text-align: center\"\n                                bookId=\"${entry.value.id}\"\n                                type=\"number\" value=\"${entry.value.count}\">\n                    </td>\n                    <td>${entry.value.price}</td>\n                    <td>${entry.value.totalPrice}</td>\n                    <td><a class=\"deleteItem\" href=\"cartServlet?action=deleteItem&id=${entry.value.id}\">删除</a></td>\n                </tr>\n            </c:forEach>\n        </c:if>\n    </table>\n    <c:if test=\"${not empty sessionScope.cart.items}\">\n        <div class=\"cart_info\">\n            <span class=\"cart_span\">购物车中共有<span class=\"b_count\">${sessionScope.cart.totalCount}</span>件商品</span>\n            <span class=\"cart_span\">总金额<span class=\"b_price\">${sessionScope.cart.totalPrice}</span>元</span>\n            <span class=\"cart_span\"><a id=\"clearCart\" href=\"cartServlet?action=clear\">清空购物车</a></span>\n            <span class=\"cart_span\"><a href=\"pages/cart/checkout\">去结账</a></span>\n        </div>\n    </c:if>\n</div>\n```\n\n### 5、修改首页\n\n```javascript\n// 添加到购物车\n$(\"button.addToCart\").click(function(){\n    /**\n     * 在事件响应的function函数中  this表示正在响应的dom对象  $(this)表示经过jquery封装后的dom对象\n     * @type {jQuery}\n     */\n    // 判断用户是否登录\n    if(${sessionScope.user == null}){\n        alert(\"您还没有登录，请先登录或注册！\")\n        location.href =\"${pageScope.basePath}pages/user/login.jsp\";\n    } else{\n        var bookid =$(this).attr(\"bookid\");// 获取选中元素的属性值\n        location.href=\"${pageScope.basePath}cartServlet?action=addItem&id=\"+bookid;\n    }\n   });\n```\n\n```jsp\n<div class=\"book_add\">\n    <button bookid=\"${book.id}\" class=\"addToCart\">加入购物车</button>\n</div>\n```\n\n### 6、首页购物车数据回显\n\n在addItem()中将添加的图书信息保存到session域中：\n![](javaweb-02/43.png)\n\n在首页显示需要的信息：\n\n```html\n<span>您的购物车中有<span style=\"color: blue\">${sessionScope.cart.totalCount}</span>件商品</span>\n<span>\n   <%--  购物车为空--%>\n    <c:if test=\"${empty sessionScope.cart.items}\">\n        <span style=\"color: red\">当前购物车为空~</span>\n    </c:if>\n    <c:if test=\"${not empty sessionScope.cart.items}\">\n           您刚刚将<span style=\"color: red\">${sessionScope.itemName}</span>加入到了购物车中\n     </c:if>\n</span>\n```\n\n## 十五、订单模块\n\n![](javaweb-02/44.png)\n\n### 1、创建Order 与OrderItem对象\n\n```java\npublic class Order {\n    private String orderId;// 订单号\n    private Date createTime;// 下单时间\n    private BigDecimal price;// 订单价格\n    private Integer status = 0;// 0 未发货  1 已发货 2 已签收\n    private Integer userId;\n\n    public Order() {\n    }\n\n    public Order(String orderId, Date createTime, BigDecimal price, Integer status, Integer userId) {\n        this.orderId = orderId;\n        this.createTime = createTime;\n        this.price = price;\n        this.status = status;\n        this.userId = userId;\n    }\n\n    public String getOrderId() {\n        return orderId;\n    }\n\n    public void setOrderId(String orderId) {\n        this.orderId = orderId;\n    }\n\n    public Date getCreateTime() {\n        return createTime;\n    }\n\n    public void setCreateTime(Date createTime) {\n        this.createTime = createTime;\n    }\n\n    public BigDecimal getPrice() {\n        return price;\n    }\n\n    public void setPrice(BigDecimal price) {\n        this.price = price;\n    }\n\n    public Integer getStatus() {\n        return status;\n    }\n\n    public void setStatus(Integer status) {\n        this.status = status;\n    }\n\n    public Integer getUserId() {\n        return userId;\n    }\n\n    public void setUserId(Integer userId) {\n        this.userId = userId;\n    }\n\n    @Override\n    public String toString() {\n        return \"Order{\" +\n                \"orderId=\" + orderId +\n                \", createTime=\" + createTime +\n                \", price=\" + price +\n                \", status=\" + status +\n                \", userId=\" + userId +\n                '}';\n    }\n}\n```\n\n```java\npublic class OrderItem {\n    private Integer id;// 商品编号\n    private String name;// 商品名称\n    private Integer count;// 商品数量\n    private BigDecimal price;// 商品总价格\n    private BigDecimal totalPrice;// 商品总价格\n    private String orderId;// 订单号\n\n    public OrderItem() {\n    }\n\n    public OrderItem(Integer id, String name, Integer count, BigDecimal price, BigDecimal totalPrice, String orderId) {\n        this.id = id;\n        this.name = name;\n        this.count = count;\n        this.price = price;\n        this.totalPrice = totalPrice;\n        this.orderId = orderId;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getCount() {\n        return count;\n    }\n\n    public void setCount(Integer count) {\n        this.count = count;\n    }\n\n    public BigDecimal getTotalPrice() {\n        return totalPrice;\n    }\n\n    public void setTotalPrice(BigDecimal totalPrice) {\n        this.totalPrice = totalPrice;\n    }\n\n    public String getOrderId() {\n        return orderId;\n    }\n\n    public void setOrderId(String orderId) {\n        this.orderId = orderId;\n    }\n\n    public BigDecimal getPrice() {\n        return price;\n    }\n\n    public void setPrice(BigDecimal price) {\n        this.price = price;\n    }\n\n    @Override\n    public String toString() {\n        return \"OrderItem{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", count=\" + count +\n                \", price=\" + price +\n                \", totalPrice=\" + totalPrice +\n                \", orderId=\" + orderId +\n                '}';\n    }\n}\n```\n\n### 2、创建OrderDao接口并实现接口中的方法\n\n```java\npublic interface OrderDao {\n    /**\n     * 保存订单\n     * @param order\n     * @return\n     */\n    public int saveOrder(Order order);\n\n    /**\n     * 查询全部订单\n     * @return\n     */\n    public List<Order> queryOrders();\n\n    /**\n     * 修改订单状态\n     * @param orderId\n     * @param Status\n     * @return\n     */\n    public int changeOrderStatus(String orderId,Integer status);\n\n    /**\n     * 根据用户编号查看订单信息\n     * @param UserId\n     * @return\n     */\n    public List<Order> queryOrderByUserId(Integer userId);\n}\n```\n\n```java\npublic class OrderDaoImpl extends BaseDao implements OrderDao {\n    @Override\n    public int saveOrder(Order order) {\n        String sql = \"insert into bookorder(`order_id`,`create_time`,`price`,`status`,`user_id`)values(?,?,?,?,?)\";\n        return update(sql,order.getOrderId(),order.getCreateTime(),order.getPrice(),order.getStatus(),order.getUserId());\n    }\n\n    @Override\n    public List<Order> queryOrders() {\n        String sql = \"select `order_id` orderId ,`create_time` createTime,`price` ,`status`,`user_id` userId from bookorder\";\n        return queryForList(Order.class,sql);\n    }\n\n    @Override\n    public int changeOrderStatus(String orderId, Integer status) {\n        String sql = \"update bookorder set status = ? where order_id = ?\";\n        return update(sql,status,orderId);\n    }\n\n    @Override\n    public List<Order> queryOrderByUserId(Integer userId) {\n        String sql = \"select `order_id` orderId ,`create_time` createTime,`price` ,`status`,`user_id` userId from bookorder where user_id=?\";\n        return queryForList(Order.class,sql,userId);\n    }\n}\n```\n\n### 3、创建 OrderItemDao接口并实现其方法\n\n```java\npublic interface OrderItemDao {\n    /**\n     * 保存订单项\n     * @param item\n     * @return\n     */\n    public int saveOrderItem(OrderItem item);\n\n    /**\n     * 更具订单号查询订单详情\n     * @param orderId\n     * @return\n     */\n    public OrderItem queryOrderItemsByOrderId(String orderId);\n}\n```\n\n```java\npublic class OrderItemDaoImpl extends BaseDao implements OrderItemDao {\n    @Override\n    public int saveOrderItem(OrderItem item) {\n        String sql = \"insert into bookorder_item(`name`,`count`,`price`,`totalprice`,`order_id`)values(?,?,?,?,?)\";\n        return update(sql,item.getName(),item.getCount(),item.getPrice(),item.getTotalPrice(),item.getOrderId());\n    }\n\n    @Override\n    public OrderItem queryOrderItemsByOrderId(String orderId) {\n        String sql = \"select `name`,`count`,`price`,`totalprice` totalPrice,`order_id` orderId from bookorder_item where order_id = ?\";\n        return queryForOne(OrderItem.class,sql,orderId);\n    }\n}\n```\n\n### 4、创建OrderService并实现其中的方法\n\n```java\npublic interface OrderService {\n    /**\n     * 生成订单\n     * @param cart\n     * @param userId\n     * @return 订单号\n     */\n    public String createOrder(Cart cart,Integer userId);\n\n    /**\n     * 查询全部订单\n     * @return\n     */\n    public List<Order> showAllOrder();\n\n    /**\n     * 发货\n     * @param orderId\n     */\n    public void sendOrder(String orderId);\n\n    /**\n     * 查看订单详情\n     * @param orderId\n     * @return\n     */\n    public OrderItem showOrderDetailById(String orderId);\n\n    /**\n     * 用户查看订单\n     * @param userId\n     * @return\n     */\n    public List<Order> showMyOrder(Integer userId);\n\n    /**\n     * 签收订单\n     * @param orderId\n     */\n    public void receiverOrder(String orderId);\n\n}\n```\n\n```java\npublic class OrderServiceImpl implements OrderService {\n\n    private OrderDao orderDao = new OrderDaoImpl();\n    private OrderItemDao orderItemDao = new OrderItemDaoImpl();\n    private BookDao bookDao = new BookDaoImpl();\n\n    @Override\n    public String createOrder(Cart cart, Integer userId) {\n        // 订单号唯一\n        String orderId = System.currentTimeMillis() + \"\" + userId;\n        // 创建一个订单对象\n        Order order = new Order(orderId, new Date(), cart.getTotalPrice(), 0, userId);\n        // 保存 订单到数据库\n        orderDao.saveOrder(order);\n        // 保存订单项\n        // 创建订单项\n        // 遍历购物车中的每一个商品项转换为订单商品项\n        for (Map.Entry<Integer, CartItem> entry : cart.getItems().entrySet()) {\n            CartItem cartItem = entry.getValue();\n            OrderItem orderItem = new OrderItem(null, cartItem.getName(), cartItem.getCount(), cartItem.getPrice(), cartItem.getTotalPrice(), orderId);\n            orderItemDao.saveOrderItem(orderItem);\n\n            // 修改图书库存和销量\n            // 获取book对象\n            Book book = bookDao.queryBookById(cartItem.getId());\n            book.setSales(book.getSales() + cartItem.getCount());\n            book.setStock(book.getStock() - cartItem.getCount());\n            bookDao.updateBook(book);\n        }\n        // 清空购物车\n        cart.clear();\n        return orderId;\n    }\n\n    @Override\n    public List<Order> showAllOrder() {\n        return orderDao.queryOrders();\n    }\n\n    @Override\n    public void sendOrder(String orderId) {\n        orderDao.changeOrderStatus(orderId,1);\n    }\n\n    @Override\n    public OrderItem showOrderDetailById(String orderId) {\n        return orderItemDao.queryOrderItemsByOrderId(orderId);\n    }\n\n    @Override\n    public List<Order> showMyOrder(Integer userId) {\n        return orderDao.queryOrderByUserId(userId);\n    }\n\n    @Override\n    public void receiverOrder(String orderId) {\n        orderDao.changeOrderStatus(orderId,2);\n    }\n}\n```\n\n### 5、创建OrderServlet并添加相应的功能\n\n```java\npublic class OrderServlet extends BaseServlet {\n\n    private OrderService orderService = new OrderServiceImpl();\n    /**\n     * 生成订单\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void createOrder(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 获取Cart对象\n        Cart cart = (Cart) req.getSession().getAttribute(\"cart\");\n        // 获取userId\n        User user = (User) req.getSession().getAttribute(\"user\");\n        Integer userId = user.getId();\n        // 调用orderService\n        String orderId = orderService.createOrder(cart, userId);\n        req.getSession().setAttribute(\"orderId\",orderId);\n        // 重定向结算成功页面\n        resp.sendRedirect(req.getContextPath()+\"/pages/cart/checkout.jsp\");\n    }\n\n    /**\n     * 查询我的订单\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void showMyOrders(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 获取userId\n        User user = (User) req.getSession().getAttribute(\"user\");\n        Integer userId = user.getId();\n        // 得到order对象\n        List<Order> orders= orderService.showMyOrder(userId);\n        // 保存至request中\n        req.setAttribute(\"orders\",orders);\n        // 请求转发到我的订单页面\n        req.getRequestDispatcher(\"/pages/order/order.jsp\").forward(req,resp);\n    }\n\n    /**\n     * 查看商品详情\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void showOrderDetail(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 获取orderId\n        String orderId = req.getParameter(\"orderId\");\n        // System.out.println(orderId);\n        // 创建OrderItem对象\n        // 调用oderService.showOrderDetailById()\n        OrderItem orderItem = orderService.showOrderDetailById(orderId);\n        req.setAttribute(\"orderItem\",orderItem);\n        req.getRequestDispatcher(\"/pages/order/order_detail.jsp\").forward(req,resp);\n    }\n\n    /**\n     * 显示所有订单\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void showAllOrders(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        List<Order> allOrders =  orderService.showAllOrder();\n        req.setAttribute(\"allOrders\",allOrders);\n        req.getRequestDispatcher(\"/pages/manager/order_manager.jsp\").forward(req,resp);\n    }\n\n    /**\n     * 发货\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void sendOrder(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 获取orderId\n        String orderId = req.getParameter(\"orderId\");\n        orderService.sendOrder(orderId);\n        resp.sendRedirect(req.getContextPath()+\"/orderServlet?action=showAllOrders\");\n    }\n\n    /**\n     * 确认收货\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void receiverOrder(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 获取orderId\n        String orderId = req.getParameter(\"orderId\");\n        orderService.receiverOrder(orderId);\n        resp.sendRedirect(req.getContextPath()+\"/orderServlet?action=showMyOrders\");\n    }\n}\n```\n\n### 5、调整jsp页面\n\n1.修改购物车页面中去结算的跳转地址![](javaweb-02/45.png)\n\n2.在order.jsp中显示当前用户的订单信息\n\n```html\n<table>\n   <tr>\n      <td>日期</td>\n      <td>金额</td>\n      <td>状态</td>\n      <td>详情</td>\n      <td>确认收货</td>\n   </tr>\n   <c:if test=\"${not empty requestScope.orders}\">\n      <c:forEach items=\"${requestScope.orders}\" var=\"order\">\n         <tr>\n            <td>${order.createTime}</td>\n            <td>${order.price}</td>\n            <td>\n               <c:choose>\n                  <c:when test=\"${order.status==0}\">未发货</c:when>\n                  <c:when test=\"${order.status==1}\">已发货</c:when>\n                  <c:otherwise>已签收</c:otherwise>\n               </c:choose>\n            </td>\n            <td><a href=\"orderServlet?action=showOrderDetail&orderId=${order.orderId}\">查看详情</a></td>\n            <td><c:choose>\n               <c:when test=\"${order.status==0}\"><span style=\"color: red\">还没有发货哦~</span></c:when>\n               <c:when test=\"${order.status==1}\"><a href=\"orderServlet?action=receiverOrder&orderId=${order.orderId}\">确认收货</a></c:when>\n               <c:otherwise><span style=\"color: red\">已经签收了~</span></c:otherwise>\n            </c:choose>\n            </td>\n         </tr>\n      </c:forEach>\n   </c:if>\n   <c:if test=\"${empty requestScope.orders}\">\n      <td colspan=\"4\"><a href=\"pages/cart/cart.jsp\">您暂时没有订单，快去购物车下单吧~</a></td>\n   </c:if>\n</table>\n```\n\n4.在order_detail.jsp中显示订单的详细信息\n\n```html\n<table>\n    <tr>\n        <td>商品名称</td>\n        <td>数量</td>\n        <td>单价</td>\n        <td>总价</td>\n        <td>订单号</td>\n    </tr>\n    <tr>\n        <td>${requestScope.orderItem.name}</td>\n        <td>${requestScope.orderItem.count}</td>\n        <td>${requestScope.orderItem.price}</td>\n        <td>${requestScope.orderItem.totalPrice}</td>\n        <td>${requestScope.orderItem.orderId}</td>\n    </tr>\n</table>\n```\n\n5.修改首页的后台管理中订单管理的跳转地址\n![](javaweb-02/46.png)\n\n6.在订单管理中显示所有的订单信息\n\n```html\n<table>\n    <tr>\n        <td>日期</td>\n        <td>金额</td>\n        <td>详情</td>\n        <td>状态</td>\n        <td>发货</td>\n    </tr>\n    <c:if test=\"${not empty requestScope.allOrders}\">\n        <c:forEach items=\"${requestScope.allOrders}\" var=\"order\">\n            <tr>\n                <td>${order.createTime}</td>\n                <td>${order.price}</td>\n                <td><a href=\"orderServlet?action=showOrderDetail&orderId=${order.orderId}\">查看详情</a></td>\n                <td>\n                    <c:choose>\n                        <c:when test=\"${order.status==0}\">未发货</c:when>\n                        <c:when test=\"${order.status==1}\">已发货</c:when>\n                        <c:otherwise>已签收</c:otherwise>\n                    </c:choose>\n                </td>\n                <td>\n                    <c:choose>\n                        <c:when test=\"${order.status==0}\">\n                            <a href=\"orderServlet?action=sendOrder&orderId=${order.orderId}\">发货</a>\n                        </c:when>\n                        <c:when test=\"${order.status==1}\"><span style=\"color: red\">已经发货了~</span></c:when>\n                        <c:otherwise><span style=\"color: red\">已经签收了~</span></c:otherwise>\n                    </c:choose>\n                </td>\n            </tr>\n        </c:forEach>\n    </c:if>\n    <c:if test=\"${empty requestScope.allOrders}\">\n        <td colspan=\"5\">暂时没有订单</td>\n    </c:if>\n</table>\n```\n\n## 十六、使用Filter实现权限检查\n\n```java\npackage com.bookmall.filter;\n\npublic class ManagerFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest httpServletRequest = (HttpServletRequest) request;\n        User user = (User) httpServletRequest.getSession().getAttribute(\"user\");\n        if(user.getStatus()!=1){\n            httpServletRequest.getRequestDispatcher(\"/pages/user/login.jsp\").forward(request,response);\n        }else{\n            chain.doFilter(request,response);\n        }\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n```\n\n```xml\n<filter>\n    <filter-name>ManagerFilter</filter-name>\n    <filter-class>com.bookmall.filter.ManagerFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>ManagerFilter</filter-name>\n    <url-pattern>/pages/manager/*</url-pattern>\n    <url-pattern>/manager/bookServlet</url-pattern>\n</filter-mapping>\n```\n\n## 十七、使用Filter和TheadLocal组合管理事务\n\n![](javaweb-02/49.png)\n\n**修改JdbcUtils：**\n创建一个ThreadLocal对象，用于将获取的连接与当前线程关联：\n![](javaweb-02/47.png)\n修改getConnection()：\n\n```java\npublic static Connection getConnection() {\n    Connection conn = conns.get();\n    if (conn == null) {\n        try {\n            conn = dataSource.getConnection();// 从数据库连接池中获取连接\n            conns.set(conn);// 将连接保存到ThreadLocal对象中，供后面的jdbc操作使用，保证执行事务时是同一个连接\n            conn.setAutoCommit(false);// 设置为不自动提交事务\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    return conn;\n}\n```\n\n添加提交并关闭连接的方法以及回滚并关闭连接的方法：\n\n```java\n /**\n * 提交事务并关闭连接\n */\npublic static void commitAndClose(){\n    Connection conn = conns.get();\n    if(conn!=null){\n        try {\n            conn.commit();// 提交事务\n        } catch (SQLException throwables) {\n            throwables.printStackTrace();\n        } finally {\n            try {\n                conn.close();// 关闭连接\n            } catch (SQLException throwables) {\n                throwables.printStackTrace();\n            }\n        }\n    }\n    // 移除线程\n    conns.remove(); \n}\n\n/**\n * 回滚事务并关闭连接\n */\npublic static void rollbackAndClose(){\n    Connection conn = conns.get();\n    if(conn !=null){\n        try {\n            conn.rollback();\n        } catch (SQLException throwables) {\n            throwables.printStackTrace();\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException throwables) {\n                throwables.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n**修改BaseDao,BaseServlet：**\n1、将所有方法中的关闭连接操作删除，用于保证所用操作都使用同一个连接；\n2、在每个方法中都添加抛出异常的语句，提供给执行相应操作的Servlet程序捕获，用于回滚。\n **使用Filter过滤器为所用的Service方法添加try-catch:**\n![](javaweb-02/48.png)\n\n```java\npackage com.bookmall.filter;\n\npublic class TransactionFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        try {\n            chain.doFilter(request,response);\n            // 提交事务\n            JdbcUtils.commitAndClose();\n        } catch (Exception e) {\n            // 回滚事务\n            JdbcUtils.rollbackAndClose();\n            // 将异常抛给服务器\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n```\n\n```xml\n<filter>\n    <filter-name>TransactionFilter</filter-name>\n    <filter-class>com.bookmall.filter.TransactionFilter</filter-class>\n</filter>\n<filter-mapping>\n   <filter-name>TransactionFilter</filter-name>\n    <!--  当前工程下的所有请求 -->\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n**将所有异常同一交给Tomcat，让Tomcat展示友好的错误信息页面：**\n配置web.xml\n\n```xml\n<!-- 配置服务器出错后，自动跳转的页面-->\n<error-page>\n    <!--   错误类型-->\n    <error-code>404</error-code>\n    <!--  要跳转去的页面路径-->\n    <location>/pages/error/error404.jsp</location>\n</error-page>\n<error-page>\n    <error-code>500</error-code>\n    <location>/pages/error/error500.jsp</location>\n</error-page>\n```\n\n## 十八、使用Ajax判断用户名是否可用\n\n![](javaweb-02/50.jpg)\n\n```javaScript\n// 给用户名输入框绑定失去焦点事件\n$(\"#username\").blur(function () {\n    // 获取用户名\n    var username = this.value;\n    $.getJSON(\n        \"${pageScope.basePath}userServlet\",\n        \"action=ajaxExistUsername&username=\" + username,\n        function (data) {\n            if (data.existUsername) {\n                $(\"span.errorMsg\").css({color:\"#dd0000\"});\n                $(\"span.errorMsg\").text(\"用户名已存在！\");\n            } else {\n                $(\"span.errorMsg\").css({color:\"#00dd00\"});\n                $(\"span.errorMsg\").text(\"用户名可用~\");\n            }\n        });\n});\n```\n\n在UserServlet中添加ajaxExisUsername()\n\n```java\n/**\n * 验证用户名是否已经注册\n * @param req\n * @param resp\n * @throws ServletException\n * @throws IOException\n */\nprotected void ajaxExistUsername(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException{\n    // 获取请求参数\n    String username = req.getParameter(\"username\");\n    // 调用userService\n    boolean existUsername = userService.existUsername(username);\n    // 把返回的结果封装成Map对象\n    Map<String,Object> resultMap = new HashMap<String, Object>();\n    resultMap.put(\"existUsername\",existUsername);\n    // 将Map对象转换为json字符串\n    Gson gson = new Gson();\n    String json = gson.toJson(resultMap);\n    resp.getWriter().write(json);\n}\n```\n\n## 十九、使用Ajax修改把商品添加到购物车\n\n```java\n/**\n * 使用Ajax添加图书到购物车\n * @param req\n * @param resp\n * @throws ServletException\n * @throws IOException\n */\nprotected void ajaxAddItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    // System.out.println(\"加入购物车\");\n    // 获取请求参数  商品编号\n    int id = WebUtils.parseInt(req.getParameter(\"id\"),0);\n    // 调用bookService.queryBookById(id) 得到图书信息\n    Book book = bookService.queryBookById(id);\n    // 将图书信息转换为CartItem商品项\n    CartItem cartItem = new CartItem(book.getId(),book.getName(),1,book.getPrice(),book.getPrice());\n    // 调用cart.add(CartItem)添加至购物车\n    Cart cart = (Cart) req.getSession().getAttribute(\"cart\");\n    if(cart == null){\n        cart = new Cart();\n        req.getSession().setAttribute(\"cart\",cart);\n    }\n    cart.addItem(cartItem);\n    // 将添加的商品添加到session域中\n    req.getSession().setAttribute(\"itemName\",cartItem.getName());\n    // 将需要在页面刷新的信息封装到Map中\n    Map<String,Object> resultMap = new HashMap<String, Object>();\n    // 购物车中总的商品数量\n    resultMap.put(\"totalCount\",cart.getTotalCount());\n    // 最后一个添加到购物车的商品名称\n    resultMap.put(\"lastName\",cartItem.getName());\n    // 将Map转换为json字符串\n    Gson gson = new Gson();\n    String json = gson.toJson(resultMap);\n    // 回传给客户端\n    resp.getWriter().write(json);\n}\n```\n\n```javaScript\nvar bookid = $(this).attr(\"bookid\");// 获取选中元素的属性值\n// location.href=\"${pageScope.basePath}cartServlet?action=addItem&id=\"+bookid;\n// 使用ajax发送请求\n$.getJSON(\n    \"${pageScope.basePath}cartServlet\",\n    \"action=ajaxAddItem&id=\" + bookid,\n    function (data) {\n        $(\"#cartTotalCount\").text(data.totalCount);\n        $(\"#cartlastName\").text(data.lastName);\n    })\n```\n\n```html\n<span>您的购物车中有<span id=\"cartTotalCount\" style=\"color:red\">${sessionScope.cart.totalCount}</span>件商品</span>\n<span>\n    您刚刚将<span id=\"cartlastName\"style=\"color:red\">${sessionScope.itemName}</span>加入到了购物车中\n</span>\n```\n\n","tags":["JavaWeb"],"categories":["小项目"]},{"title":"Servlet","url":"/2020/04/05/javaweb-01/","content":"\n## JavaWeb概念\n\n**javaweb：**所有由java编写的可以通过浏览器访问的程序的总称。\njavaweb是基于请求和响应来开发的。<!--more-->\n\n**请求：**Request，是指客户端(浏览器)给服务器(Tomcat)发送数据。\n**响应：**Response，服务器给客户端回传数据。\n\n**请求与响应的关系：**请求和响应是成对出现的，有请求就有响应。\n\n## Web资源的分类\n\nweb资源按实现的技术和呈现的效果的不同，分为静态资源和动态资源。\n静态资源：html、css、js、txt文本、mp4视频、jpg图片等等\n动态资源：jsp页面、Servlet程序\n\n## Tomcat端口号\n\ntomcat默认端口号：8080\napache-tomcat-8.0.50\\conf\\server.xml文件可修改默认端口号\n\nhttp默认端口号：80\nhttps默认端口号：443(浏览器会自动补全)\n\nweb容器是一种服务程序，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，如JAVA中的Tomcat容器，ASP的IIS或PWS都是这样的容器。一个服务器可以多个容器。Web容器负责将HTTP请求转换为HttpServletRequest对象。\n\n## Servlet\n\n1、Servlet是JavaEE规范之一，规范就是接口。\n2、Servlet是JavaWeb三大组件之一，三大组件为：Servlet程序、Filter过滤器、Listener监听器。\n3、Servlet是运行在服务器上的一个java小程序，可以接受客户端发送过来的请求并发送响应数据给客户端。\n**手动实现Servlet程序:**\n1、编写一个类去实现Servlet 接口\n2、实现service 方法，处理请求，并响应数据\n3、到web.xml 中去配置servlet 程序的访问地址\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <!-- servlet标签给Tomcat服务器配置Servlet程序 -->\n    <servlet>\n        <!-- servlet-name标签用于给 Servlet程序起一个别名(一般是类名)-->\n        <servlet-name>HelloServlet</servlet-name>\n        <!-- servlet-class 是Servlet程序的全类名-->\n        <servlet-class>servlet.HelloServlet</servlet-class>\n    </servlet>\n    <!-- servlet-mapping标签用于给servlet程序配置访问地址-->\n    <servlet-mapping>\n        <!-- servlet-name告诉服务器当前的配置地址是给哪一个servlet程序使用的-->\n        <servlet-name>HelloServlet</servlet-name>\n        <!-- url-pattern标签配置访问地址\n             / 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径\n        -->\n        <url-pattern>/test</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n\n**Servlet的生命周期：**\n\n1、加载：容器通过类加载器使用Servlet类对应的文件来加载Servlet\n\n2、创建：通过**调用Servlet的构造函数来创建一个Servlet实例**\n\n3、初始化：通过调用Servlet的init()方法来完成初始化工作，ServletConfig对象读取web.xml获取初始化参数，对Servlet进行初始化\n\n4、处理客户请求：Servlet创建后就可以处理请求，当有新的客户端请求时，Web容器都会**创建一个新的线程**来处理该请求。接着调用Servlet的Service()方法来响应客户端请求（Service方法根据请求的method属性来调用doGet()和doPost()）\n\n5、卸载：**容器在卸载Servlet之前**需要调用destroy()方法，让Servlet释放其占用的资源。\n\n**通过继承HttpServlet实现Servlet程序：**一般在实际开发中使用此方式\n1、编写一个类去继承HttpServlet类\n2、根据业务需求重写doGet 或 doPost 方法\n3、在web.xml中配置servlet程序的访问地址\n![](javaweb-01/1.png)\n\nServletConfig类的作用：\n1、获取 Servlet 程序的别名 servlet-name的值；\n2、获取初始化参数 init-param；\n3、获取ServletContext 对象；\n\nServletContext：\n1、ServletContext 是一个接口，它表示Servlet 上下文对象\n2、一个web 工程，只有一个ServletContext 对象实例。\n3、ServletContext 对象是一个域对象。\n4、ServletContext 是在web 工程部署启动的时候创建。在web 工程停止的时候销毁。\n\n> 什么是域对象?\n> 域对象，是可以像Map 一样存取数据的对象，叫域对象。\n> 这里的域指的是存取数据的操作范围，整个web 工程。\n> &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;存数据&nbsp;  &nbsp; &nbsp; &nbsp; 取数据&nbsp;  &nbsp; &nbsp;&nbsp;删除数据\n> Map &nbsp; &nbsp; &nbsp;put() &nbsp; &nbsp; &nbsp;&nbsp;get()  &nbsp; &nbsp; &nbsp;&nbsp;remove()\n> 域对象 &nbsp; setAttribute() &nbsp;getAttribute()&nbsp; removeAttribute()\n\nServletContext 类的四个作用\n1、获取web.xml 中配置的上下文参数context-param\n2、获取当前的工程路径，格式: /工程路径\n3、获取工程部署后在服务器硬盘上的绝对路径\n4、像Map 一样存取数据\n\n## 请求的HTTP协议格式\n\n### GET请求\n\n1、请求行\n(1) 请求的方式GET\n(2) 请求的资源路径[+?+请求参数]\n(3) 请求的协议的版本号HTTP/1.1\n2、请求头\nkey : value 组成不同的键值对，表示不同的含义。\n![](javaweb-01/2.png)\n\n### POST请求\n\n1、请求行\n(1) 请求的方式POST\n(2) 请求的资源路径[+?+请求参数]\n(3) 请求的协议的版本号HTTP/1.1\n2、请求头\n1) key : value 不同的请求头，有不同的含义\n空行\n3、请求体===>>> 就是发送给服务器的数据\n![](javaweb-01/3.png)\nGET 请求有哪些：\n1、form 标签method=get\n2、a 标签\n3、link 标签引入css\n4、Script 标签引入js 文件\n5、img 标签引入图片\n6、iframe 引入html 页面\n7、在浏览器地址栏中输入地址后敲回车\nPOST 请求有哪些：\n8、form 标签method=post\n\n## 响应的HTTP协议格式\n\n1、响应行\n(1) 响应的协议和版本号\n(2) 响应状态码\n(3) 响应状态描述符\n2、响应头\n(1) key : value 不同的响应头，有其不同含义\n空行\n3、响应体---->>> 就是回传给客户端的数据\n![](javaweb-01/4.png)\n\n常见的响应码：\n200&nbsp;&nbsp;&nbsp;&nbsp;请求成功\n302&nbsp;&nbsp;&nbsp;&nbsp;表示请求重定向\n404&nbsp;&nbsp;&nbsp;&nbsp;表示服务器已经收到，但是请求的数据不存在\n500&nbsp;&nbsp;&nbsp;&nbsp;表示服务器已经收到，但是服务器内部错误\n\n## MMIE类型说明\n\nMIME是HTTP协议中的数据类型\n![](javaweb-01/5.png)\n\n## HttpServletRequest类\n\n每次只要有请求进入Tomcat 服务器，Tomcat 服务器就会把请求过来的HTTP 协议信息解析好封装到Request 对象中。然后传递到service 方法（doGet 和doPost）中给我们使用。我们可以通过HttpServletRequest 对象，获取到有请求的信息。\n\n**HttpServletRequest常用方法：**\ni. getRequestURI() 获取请求的资源路径\nii. getRequestURL() 获取请求的统一资源定位符（绝对路径）\niii. getRemoteHost() 获取客户端的ip 地址\niv. getHeader() 获取请求头\nv. getParameter() 获取请求的参数\nvi. getParameterValues() 获取请求的参数（多个值的时候使用）\nvii. getMethod() 获取请求的方式GET 或POST\nviii. setAttribute(key, value); 设置域数据\nix. getAttribute(key); 获取域数据\nx. getRequestDispatcher() 获取请求转发对象\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <form action=\"http://localhost:8080/06.servlet/test3\" method=\"post\">\n        用户名：<input type=\"text\" name=\"username\"><br/>\n        密码：<input type=\"password\" name=\"pwd\"><br/>\n        兴趣爱好：\n        <input type=\"checkbox\" name=\"hobby\" value=\"cpp\">C++\n        <input type=\"checkbox\" name=\"hobby\" value=\"java\">Java\n        <input type=\"checkbox\" name=\"hobby\" value=\"js\">JavaScript\n        <br/>\n        <input type=\"submit\"/>\n    </form>\n</body>\n</html>\n```\n\n```java\npublic class HelloServlet3 extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println(\"post请求\");\n        // 设置请求体的字符集为UTF-8，从而解决post 请求的中文乱码问题\n        request.setCharacterEncoding(\"UTF-8\");\n        // 获取请求参数\n        String username = request.getParameter(\"username\");\n        String pwd = request.getParameter(\"pwd\");\n        String[] hobbies = request.getParameterValues(\"hobby\");\n        System.out.println(username);\n        System.out.println(pwd);\n        System.out.println(Arrays.asList(hobbies));\n    }\n}\n```\n\n## 请求的转发\n\n服务器收到请求后，从一个资源跳转到另一个资源的操作。\n特点：1、浏览器地址栏没有变化\n\t\t\t2、是一次请求\n            3、共享Request域中的数据\n\t\t\t4、可以转发到WEB-INF目录下\n\t\t\t5、不可以访问工程外的资源\n可能会造成表单的多次提交。\n\n```java\npublic class Servlet1 extends HttpServlet {\n@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,IOException {\n\t// 获取请求的参数（办事的材料）查看\n\tString username = req.getParameter(\"username\");\n\tSystem.out.println(\"在Servlet1（柜台1）中查看参数（材料）：\" + username);\n\t// 给材料盖一个章，并传递到Servlet2（柜台2）去查看\n\treq.setAttribute(\"key1\",\"柜台1 的章\");\n\t// 问路：Servlet2（柜台2）怎么走\n\t/**\n\t* 请求转发必须要以斜杠打头，斜杠表示地址为：http://ip:port/工程名/ , 映射到IDEA 代码的web目录\n    */\n\tRequestDispatcher requestDispatcher = req.getRequestDispatcher(\"/servlet2\");\n\t// RequestDispatcher requestDispatcher = req.getRequestDispatcher(\"http://www.baidu.com\");\n\t// 走向Sevlet2（柜台2）\n\trequestDispatcher.forward(req,resp);\n\t}\n}\n```\n\n## base标签\n\n设置页面相对路径工作时参照的路径\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>c.html</title>\n    <!--base 标签设置页面相对路径工作时参照的地址\n        href 属性就是参数的地址值\n     -->\n    <base href=\"http://localhost:8080/06.servlet/a/b/\">\n</head>\n<body>\n    这是a/b/c.html\n    <a href=\"../../index.html\">返回首页</a>\n</body>\n</html>\n```\n\n## HttpServletResponse类\n\nHttpServletResponse 类和HttpServletRequest 类一样。\n每次请求进来，Tomcat 服务器都会创建一个Response 对象传递给Servlet 程序去使用。\nHttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息。\n**两个输出流：(同时只能使用一个)**\n字节流：getOutputStream();  &nbsp;&nbsp;&nbsp;常用于下载，传递二进制数据\n字符流：getWriter();&nbsp;&nbsp;&nbsp;常用于回传字符串\n\n```java\npublic class ResponseIOServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n//        // 设置服务器字符集\n//        response.setCharacterEncoding(\"utf-8\");\n//        // 通过响应头，设置客户端（浏览器）字符集\n//        response.setHeader(\"Content-Type\",\"text/html;charset=UTF-8\");\n\n        // 同时设置服务端和客户端的编码集\n        response.setContentType(\"text/html;charset=UTF-8\");// 必须在获取流对象之前使用\n        // 向客户端回传字符串数据\n        PrintWriter writer = response.getWriter();\n        writer.write(\"哈哈\");\n    }\n}\n```\n\n## 请求的重定向\n\n请求重定向，是指客户端给服务器发请求，然后服务器通过响应头告诉客户端，并提供一个新的地址，然后客户端去新地址访问，叫请求重定向（因为之前的地址可能已经被废弃）。可以解决表单的多次提交问题。\n![](javaweb-01/6.png)\n\n```java\npublic class ResponseIOServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n//        // 方式一：\n//        // 设置响应码\n//        response.setStatus(302);\n//        // 设置响应头，指明新的地址\n//        response.setHeader(\"Location\",\"http://localhost:8080/06.servlet/ResponseServlet2\");\n           \n        // 方式二：\n        response.sendRedirect(\"http://localhost:8080/06.servlet/ResponseServlet2\");\n    }\n}\n\npublic class ResponseServlet2 extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        PrintWriter writer = response.getWriter();\n        writer.write(\"哈哈哈\");\n    }\n}\n```\n\n## JavaEE项目的三层架构\n\n![](javaweb-01/7.png)\n\n分层的目的是为了解耦。解耦是为了降低代码的耦合度，方便项目后期的维护和升级。\n\n### 1、MVC 概念\nMVC 全称：Model 模型、View 视图、Controller 控制器。\nMVC 最早出现在JavaEE 三层中的Web 层，它可以有效的指导Web 层的代码如何有效分离，单独工作。\nModel 模型：将与业务逻辑相关的数据封装为具体的JavaBean 类，其中不掺杂任何与数据处理相关的代码——JavaBean/domain/entity/pojo。\nView 视图：只负责数据和界面的显示，不接受任何与显示数据无关的代码，便于程序员和美工的分工合作——JSP/HTML。\nController 控制器：只负责接收请求，调用业务层的代码处理请求，然后派发页面，是一个“调度者”的角色——Servlet。转到某个页面。或者是重定向到某个页面。\nMVC 是一种思想，MVC 的理念是将软件代码拆分成为组件，单独开发，组合使用（目的还是为了降低耦合度）。\n<img src=\"javaweb-01/8.png\" />","tags":["JavaWeb"],"categories":["JavaWeb"]},{"title":"JDK8新特性","url":"/2020/03/24/java-11/","content":"\n## Lambda表达式\n\nLambda是一个匿名函数，可以理解为一段可传递的代码，将代码将数据一样进行传递。<!--more-->\n\n```java\n/**\n * @author zyz\n * @description lambda表达式的写法\n * 格式：lambda参数列表(接口中的抽象方法的形参列表)->lambda体(重写的抽象方法的方法体)\n * lambda表达式的本质：作为函数式接口的一个实例\n * 函数式接口：@FunctionalInterface 只声明了一个抽象方法的接口\n * @create 2020-03-24 11:09\n */\npublic class LambdaTest1 {\n    @Test // 方式一：无参，无返回值，一条执行语句 (可以省略return)\n    public void test1(){\n        Runnable r1 = ()-> System.out.println(\"歪比巴卜\");\n        r1.run();\n    }\n\n    @Test // 方式二：一个参数，无返回值   参数数据类型可以省略(编译器类型推断)\n    public void test2(){\n        Consumer<String> c1 = (String s)-> {\n            System.out.println(s);\n        };\n        c1.accept(\"茉莉~\");\n    }\n\n    @Test // 方式三：一个参数，参数的小括号可以省略\n    public void test3(){\n        Consumer<String> c1 = s -> {\n            System.out.println(s);\n        };\n        //方法引用   使用操作符“::” 将类(或对象) 与方法名分隔开来。\n        // Consumer<String> c1 = System.out::println;\n        c1.accept(\"起   飞\");\n    }\n\n    @Test // 方式四：两个或以上的参数，多条执行语句\n    public void test4(){\n        Comparator<Integer> com1 = (o1,o2)->{\n            System.out.println(o1);\n            System.out.println(o2);\n            return o1.compareTo(o2);\n        };\n        System.out.println(com1.compare(1,2));\n    }\n}\n```\n\n## Lambda表达式的应用\n\n### forEach 遍历Map\n\n```java\nMap<String,Object> map = new HashMap<String,Object>();\nmap.put(\"key1\", 1);\nmap.put(\"key2\", 2);\nmap.put(\"key3\", 3);\nmap.put(\"key4\", 4);\nmap.forEach((key,value) -> {\n    System.out.println(\"key:\" + key + \",value:\" + value);\n})\n```\n\n### forEach 遍历List\n\n```java\nList<Integer> list = new ArrayList<Integer>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\nlist.forEach(value -> {\n    System.out.println(\"value:\" + value);\n})\n```\n\n### 创建并开启线程\n\n```java\nnew Thread(()->System.out.println(\"new Thread start\")).start(); \n```\n\n## Stream 流\n\n以集合为例，一个流式处理的操作我们首先需要调用`stream()`函数将其**转换成流**，然后再调用相应的**中间操作**达到我们需要对集合进行的操作，比如筛选、转换等，最后通过**终端操作**对前面的结果进行封装，返回我们需要的形式。\n<img src=\"java-11/1.jpg\" style=\"zoom:80%;\" />\n\n### 常用api的使用\n\n创建实体类\n\n```java\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\nclass User{\nprivate Long id;       \nprivate String name;   \nprivate Integer age;   \nprivate String school; \n```\n\n初始化\n\n```java\nList<User> list = new ArrayList<User>(){\n    {\n        add(new User(1L,\"张三\",10, \"清华大学\"));\n        add(new User(2L,\"李四\",12, \"清华大学\"));\n        add(new User(3L,\"王五\",15, \"清华大学\"));\n        add(new User(4L,\"赵六\",12, \"清华大学\"));\n        add(new User(5L,\"田七\",25, \"北京大学\"));\n        add(new User(6L,\"小明\",16, \"北京大学\"));\n        add(new User(7L,\"小红\",14, \"北京大学\"));\n        add(new User(8L,\"小华\",14, \"浙江大学\"));\n        add(new User(9L,\"小丽\",17, \"浙江大学\"));\n        add(new User(10L,\"小何\",10, \"浙江大学\"));\n    }\n};\n```\n\n> filter 过滤\n\n```java\n// 筛选出学校是清华大学的所有用户并打印输出他们的姓名\nList<User> userList = list.stream()\n    .filter(user -> \"清华大学\".equals(user.getSchool()))\n    .collect(Collectors.toList());\nuserList.forEach(user -> {\n    System.out.print(user.getName() + \" \");\n});\n```\n\n输出结果：\n\n```shell\n张三 李四 王五 赵六\n```\n\n> distinct\n\n```java\n// distinct 获取所有user的年龄（年龄不重复）\n// map 方法用于映射每个元素到对应的结果\n// List<Integer> userAgeList = list.stream().map(User::getAge)\nList<Integer> userAgeList = list.stream()\n        .map(user -> user.getAge())\n        .distinct()\n        .collect(Collectors.toList());\nuserAgeList.forEach(age -> {\n    System.out.print(age + \" \");\n});\n```\n\n输出结果：\n\n```shell\n18 20 16 19 25 22 21 \n```\n\n> limit  返回前n个元素的流，当集合长度小于n时，则返回所有集合\n\n```java\n// 获取年龄是偶数的前2名user\nList<User> userList2 = list.stream()\n        .filter(user -> user.getAge() % 2 == 0)\n        .limit(2)\n        .collect(Collectors.toList());\nuserList2.forEach(user -> {\n    System.out.print(user.getName() + \" \");\n});\n```\n\n```shell\n张三 李四\n```\n\n> sorted\n\n```java\n// 将所有user按年龄从大到小排序\nList<User> userList3 = list.stream()\n        .sorted((user1, user2) -> user2.getAge() - user1.getAge())\n        .collect(Collectors.toList());\nSystem.out.println(userList3);\n```\n\n输出结果：\n\n```shell\n[User{id=5, name='田七', age=25, school='北京大学'}, User{id=8, name='小华', age=22, school='浙江大学'}, User{id=9, name='小丽', age=21, school='浙江大学'}, User{id=2, name='李四', age=20, school='清华大学'}, User{id=7, name='小红', age=20, school='北京大学'}, User{id=4, name='赵六', age=19, school='清华大学'}, User{id=1, name='张三', age=18, school='清华大学'}, User{id=10, name='小何', age=18, school='浙江大学'}, User{id=3, name='王五', age=16, school='清华大学'}, User{id=6, name='小明', age=16, school='北京大学'}]\n```\n\n> skip  跳过几个元素再输出\n\n```java\n// 跳过前两个user,输出之后的user\nList<User> userList4 = list\n    .stream()\n    .skip(2)\n    .collect(Collectors.toList());\nSystem.out.println(userList4);\n```\n\n输出结果：\n\n```shell\n[User{id=3, name='王五', age=16, school='清华大学'}, User{id=4, name='赵六', age=19, school='清华大学'}, User{id=5, name='田七', age=25, school='北京大学'}, User{id=6, name='小明', age=16, school='北京大学'}, User{id=7, name='小红', age=20, school='北京大学'}, User{id=8, name='小华', age=22, school='浙江大学'}, User{id=9, name='小丽', age=21, school='浙江大学'}, User{id=10, name='小何', age=18, school='浙江大学'}]\n```\n\n> map 映射元素结果\n\n```java\n// 筛选出学校是清华大学的所有学生\nList<String> nameList = list.stream()\n        .filter(user -> \"清华大学\".equals(user.getSchool()))\n        .map(user -> user.getName())\n        .collect(Collectors.toList());\nSystem.out.println(nameList);\n\n/**\n * 除了上面这类基础的map，java8还提供了mapToDouble(ToDoubleFunction<? super T> mapper)，\n * mapToInt(ToIntFunction<? super T> mapper)，\n * mapToLong(ToLongFunction<? super T> mapper)，\n * java8为这些流设定了一些特殊的操作\n */\n// 统计学校为北京大学的所有用户的人数\nlong count = list.stream()\n        .filter(user -> \"北京大学\".equals(user.getSchool()))\n        .mapToInt(user -> user.getAge()).count();\nSystem.out.println(\"北京大学用户的人数：\" + count);\n```\n\n输出结果：\n\n```shell\n[张三, 李四, 王五, 赵六]\n北京大学用户的人数：3\n```\n\n> 匹配\n\n```java\n// allMatch\n// 用于检测是否全部都满足指定的参数行为，如果全部满足则返回true\n// 判断所有用户的年龄是否都大于18岁\nboolean isAllAdult = list.stream().allMatch(user -> user.getAge() > 18);\nSystem.out.println(isAllAdult);\n\n// anyMatch\n// 检测是否存在一个或多个满足指定的参数行为，如果满足则返回true\n// 判断是否有大于18岁的用户\nboolean isAnyAdult = list.stream().anyMatch(user -> user.getAge() > 18);\nSystem.out.println(isAnyAdult);\n\n// noneMatch　　\n// 检测是否不存在满足指定行为的元素，如果不存在则返回true\n```\n\n输出结果：\n\n```shell\nfalse\ntrue\n```\n\n> findFirst  用于返回满足条件的第一个元素\n\n```java\nOptional<User> first = list.stream()\n        .filter(user -> user.getAge() == 18)\n        .findFirst();\nUser user = first.get();\nSystem.out.println(user);\n```\n\n输出结果：\n\n```shell\nUser{id=1, name='张三', age=18, school='清华大学'}\n```\n\n> counting  计算个数\n\n```java\n// Long counting = list.stream().collect(Collectors.counting());\nlong counting = list.stream().count();\nSystem.out.println(\"总人数：\"+counting);\n```\n\n输出结果：\n\n```shell\n总人数：10\n```\n\n> maxBy  minBy  计算最大值 最小值\n\n```java\nInteger maxAge = list.stream()\n        .collect(Collectors.maxBy((user1, user2) -> user1.getAge() - user2.getAge()))\n        .get().getAge();\nInteger minAge = list.stream()\n        .collect(Collectors.minBy((user1, user2) -> user1.getAge() - user2.getAge()))\n        .get().getAge();\nSystem.out.println(\"最大年龄：\" + maxAge);\nSystem.out.println(\"最小年龄：\" + minAge);\n// 方式二： 使用比较器\nInteger maxAge2 = list.stream()\n        .collect(Collectors.maxBy(Comparator.comparing(User::getAge)))\n        .get()\n        .getAge();\nInteger minAge2 = list.stream()\n        .collect(Collectors.minBy(Comparator.comparing(User::getAge)))\n        .get()\n        .getAge();\nSystem.out.println(\"最大年龄：\" + maxAge2);\nSystem.out.println(\"最小年龄：\" + minAge2);\n```\n\n输出结果：\n\n```shell\n最大年龄：25\n最小年龄：16\n最大年龄：25\n最小年龄：16\n```\n\n> summingInt、summingLong、summingDouble 计算总和\n\n```java\nInteger ageSum = list.stream().collect(Collectors.summingInt(User::getAge));\nSystem.out.println(\"年龄总合为：\" + ageSum);\n```\n\n输出结果：\n\n```shell\n年龄总合为：195\n```\n\n> averageInt、averageLong、averageDouble 计算平均值\n\n```java\nDouble ageAverage = list.stream().collect(Collectors.averagingInt(User::getAge));\nSystem.out.println(\"年龄平均值：\" + ageAverage);\n```\n\n输出结果：\n\n```shell\n年龄平均值：19.5\n```\n\n> summarizingInt、summarizingLong、summarizingDouble  \n>\n> 一次性查询元素个数、总和、最大值、最小值和平均值\n\n```java\nIntSummaryStatistics collect = list.stream()\n    .collect(Collectors.summarizingInt(User::getAge));\nSystem.out.println(collect);\n```\n\n输出结果：\n\n```shell\nIntSummaryStatistics{count=10, sum=195, min=16, average=19.500000, max=25}\n```\n\n> joining 字符串拼接\n\n```java\nString names = list.stream()\n    .map(User::getName)\n    .collect(Collectors.joining(\",\"));\nSystem.out.println(names);\n```\n\n输出结果：\n\n```shell\n张三,李四,王五,赵六,田七,小明,小红,小华,小丽,小何\n```\n\n> groupingBy 分组\n\n```java\n// 根据大学划分用户\nMap<String, List<User>> userBySchool = list.stream()\n    .collect(Collectors.groupingBy(User::getSchool));\nSystem.out.println(userBySchool);\n```\n\n输出结果：\n\n```shell\n{浙江大学=[User{id=8, name='小华', age=22, school='浙江大学'}, User{id=9, name='小丽', age=21, school='浙江大学'}, User{id=10, name='小何', age=18, school='浙江大学'}], 北京大学=[User{id=5, name='田七', age=25, school='北京大学'}, User{id=6, name='小明', age=16, school='北京大学'}, User{id=7, name='小红', age=20, school='北京大学'}], 清华大学=[User{id=1, name='张三', age=18, school='清华大学'}, User{id=2, name='李四', age=20, school=\n```\n\n> partitioningBy  分区\n\n```java\n// 按照是否是清华大学的user将所有user分为两个部分\nMap<Boolean, List<User>> userByQinghua = list.stream()\n    .collect(Collectors.partitioningBy(user1 -> \"清华大学\".equals(user1.getSchool())));\nSystem.out.println(userByQinghua);\n```\n\n输出结果：\n\n```shell\n{false=[User{id=5, name='田七', age=25, school='北京大学'}, User{id=6, name='小明', age=16, school='北京大学'}, User{id=7, name='小红', age=20, school='北京大学'}, User{id=8, name='小华', age=22, school='浙江大学'}, User{id=9, name='小丽', age=21, school='浙江大学'}, User{id=10, name='小何', age=18, school='浙江大学'}], true=[User{id=1, name='张三', age=18, school='清华大学'}, User{id=2, name='李四', age=20, school='清华大学'}, User{id=3, name='王五', age=16, school='清华大学'}, User{id=4, name='赵六', age=19, school='清华大学'}]}\n```\n\n","tags":["JavaSE"],"categories":["JavaSE"]},{"title":"Jdbc核心技术","url":"/2020/03/23/jdbc/","content":"\n## 一、JDBC概述\n\nJDBC(Java Database Connectivity)是一个**独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口**(一组API)。<!--more-->\n                  ![](jdbc/1.png)\n\n**JDBC接口(API)包括两个层次：**\n*面向应用的API*：Java API，抽象接口，供程序开发人员使用(连接数据库，执行SQL语句，获得结果)。\n*面向数据库的API：*Java Driver API，供开发商数据库驱动程序用。\n> JDBC是sun公司提供的一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。\n>\n> 不同的数据库厂商，需要针对这套接口。提供不同实现。不同的实现的集合，即为不同数据库的驱动。\n>\n> ​                                                                                                                                          ------面向接口编程\n\n**JDBC程序编写步骤：**\n\n![](jdbc/2.png)\n\n## 二、获取数据库连接\n\n**条件1、Driver接口**\njava.sql.Driver 接口是所有JDBC驱动程序需要实现的接口 。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。\n在程序中不需要直接取访问实现了Driver 接口的类，而是由程序驱动管理器类(java.sql.DriverManager)去调用这些Driver实现。\nmysql的驱动：com.mysql.jdbc.Driver(mysql6.0及以前)\n**mysql6.0之后改用：com.mysql.cj.jdbc.Driver**\n\n**条件2、URL**\njdbc URL用于标识一个被注册的驱动程序，驱动程序管理器通过这个URL选择正确的驱动程序，从而建立到数据库的连接。\n\n格式(mysql6.0及以前)：![](jdbc/3.png)\n\n**mysql6.0以后需要在后面加上时区：**\n**”jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai“**\n\n**条件3、用户名和密码**\n\n```java\npublic class ConnectionTest {\n\t@Test\n\tpublic void connectionTest1() throws SQLException {\n\t\t\t// 获取Driver实现类对象\n\t\t\tDriver driver = new com.mysql.cj.jdbc.Driver();\n\t\t\tString url = \"jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai\";\n\t\t\t// 将用户名密码封装在Properties中\n\t\t\tProperties info = new Properties();\n\t\t\tinfo.setProperty(\"user\", \"root\");\n\t\t\tinfo.setProperty(\"password\", \"2824199842\");\n\t\t\tConnection conn = driver.connect(url, info);\n\t\t\tSystem.out.println(conn);\n\t}\n\t\n\t@Test  // 没有使用第三方的API,使得程序具有更好的移植性\n\tpublic void connectionTest2() throws Exception{\n\t\t// 1.使用反射获取Driver实现类对象\n\t\tClass<?> class1 = Class.forName(\"com.mysql.cj.jdbc.Driver\");\n\t\tDriver driver = (Driver) class1.newInstance();\n\t\t// 2.提供要连接的数据库\n\t\tString url = \"jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai\";\n\t\t// 3.提供要连接的用户名、密码\n\t\tProperties info = new Properties();\n\t\tinfo.setProperty(\"user\", \"root\");\n\t\tinfo.setProperty(\"password\", \"2824199842\");\n\t\t// 4.建立连接\n\t\tConnection conn = driver.connect(url, info);\n\t\tSystem.out.println(conn);\n\t}\n\t\n\t@Test // 使用DriverManager替换Driver\n\tpublic void connectionTest3() throws Exception {\n\t\t// 1.获取Driver实现类对象\n\t\tClass<?> class1 = Class.forName(\"com.mysql.cj.jdbc.Driver\");\n\t\tDriver driver = (Driver) class1.newInstance();\n\t\t// 2.提供URL，用户名及密码\n\t\tString url = \"jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai\";\n\t\tString user = \"root\";\n\t\tString pwd = \"2824199842\";\n\t\t// 3.注册驱动\n\t\tDriverManager.registerDriver(driver);\n\t\t// 4.获取连接\n\t\tConnection conn = DriverManager.getConnection(url,user,pwd);\n\t\tSystem.out.println(conn);\n\t}\n\t\n\t@Test // 省略显式加载驱动\n\tpublic void connectionTest4() throws Exception {\n\t\t// 提供URL，用户名及密码\n\t\tString url = \"jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai\";\n\t\tString user = \"root\";\n\t\tString pwd = \"2824199842\";\n\t\t\n\t\t// 加载Driver  mysql的Driver中静态代码块中已经注册了driver\n\t\tClass<?> class1 = Class.forName(\"com.mysql.cj.jdbc.Driver\");\n\t\tDriver driver = (Driver) class1.newInstance();\n//\t\t\n//\t\t// 注册驱动\n//\t\tDriverManager.registerDriver(driver);\n\t\t// 获取连接\n\t\tConnection conn = DriverManager.getConnection(url,user,pwd);\n\t\tSystem.out.println(conn);\n\t}\n\t\n\t@Test // 将信息放入配置文件jdbc.properties中,通过读取配置文件获取连接条件(url,user,password,driverclass)\n\tpublic void connectionTest5() throws Exception {\n\t\t// 1.读取配置文件信息\n\t\tInputStream inputStream = ClassLoader.getSystemClassLoader().getResourceAsStream(\"jdbc.properties\");\n\t\tProperties pros = new Properties();\n\t\tpros.load(inputStream);\n\t\tString user = pros.getProperty(\"user\");\n\t\tString pwd = pros.getProperty(\"password\");\n\t\tString url = pros.getProperty(\"url\");\n\t\tString driverClass = pros.getProperty(\"driverclass\");\n\t\t// 2.加载驱动\n\t\tClass.forName(driverClass);\n\t\t// 3.获取连接\n\t\tConnection conn = DriverManager.getConnection(url,user,pwd);\n\t\tSystem.out.println(conn);\n\t}\n}\n```\n\n![](jdbc/7.png)\n\n## 三、使用PreparedStatement实现CRUD\n\n**操作和访问数据库：**\n数据库连接被用于向数据库发送命令和SQL语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。\n在java.sql包中有三个接口分别定义了对数据库的不同调用方式：\n1、Statement：用于执行静态SQL语句并返回它所生成结果的对象。\n2、PreparedStatement：SQL语句被预编译并存储在此对象中，可以用此对象多次高效地执行该语句。\n3、CallableStatement：用于执行SQL存储过程。\n\n**Statement的弊端：**存在拼串操作，并且存在SQL注入问题\n\t\t**PreparedStatement：**是Statement的子接口；能最大可能提高性能；操作Blob类型数据；可以防止sql注入\n\n### 增删改操作\n\n```java\n@Test // 增加记录\npublic void testInsert() throws Exception {\n    Connection conn = null;\n    PreparedStatement ps = null;\n    try {\n        // 1.读取配置文件信息\n        InputStream inputStream = ClassLoader.getSystemClassLoader().getResourceAsStream(\"jdbc.properties\");\n        Properties pros = new Properties();\n        pros.load(inputStream);\n        String user = pros.getProperty(\"user\");\n        String pwd = pros.getProperty(\"password\");\n        String url = pros.getProperty(\"url\");\n        String driverClass = pros.getProperty(\"driverclass\");\n        // 2.加载驱动\n        Class.forName(driverClass);\n        // 3.获取连接\n        conn = DriverManager.getConnection(url, user, pwd);\n        System.out.println(conn);\n        // 4.预编译sql语句，返回PreparedStatement实例\n        String sql = \"insert into customers(name,email,birth)values(?,?,?)\";\n        ps = conn.prepareStatement(sql);\n        // 5.填充占位符\n        ps.setString(1, \"Taylor\");// 索引从1开始\n        ps.setString(2, \"12324@qq.com\");\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        java.util.Date date = sdf.parse(\"1989-2-22\");\n        ps.setDate(3, new Date(date.getTime()));\n        // 6.执行操作\n        ps.execute();\n    } catch (Exception e) {\n        // TODO: handle exception\n    } finally {\n        try {\n            // 7.关闭资源\n            if (ps != null) {\n                ps.close();\n            }\n        } catch (Exception e2) {\n            // TODO: handle exception\n            e.printStackTrace();\n        }\n        try {\n            if (conn != null) {\n                conn.close();\n            }\n        } catch (Exception e2) {\n            // TODO: handle exception\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n1、可将增加、删除、修改、查询中的共同操作（1.获取连接，2.释放资源）封装成一个工具类：\n\n```java\npublic class JDBCUtils {\n\t/**\n\t * \n\t * @Description 获取数据库连接\n\t * @author zyz\n\t * @date 2020年3月25日下午5:38:23\n\t * @return\n\t * @throws Exception\n\t */\n\tpublic static Connection getConnection() throws Exception {\n\t\t// 1.读取配置文件信息\n\t\tInputStream inputStream = ClassLoader.getSystemClassLoader().getResourceAsStream(\"jdbc.properties\");\n\t\tProperties pros = new Properties();\n\t\tpros.load(inputStream);\n\t\tString user = pros.getProperty(\"user\");\n\t\tString pwd = pros.getProperty(\"password\");\n\t\tString url = pros.getProperty(\"url\");\n\t\tString driverClass = pros.getProperty(\"driverclass\");\n\t\t// 2.加载驱动\n\t\tClass.forName(driverClass);\n\t\t// 3.获取连接\n\t\tConnection conn = DriverManager.getConnection(url, user, pwd);\n\t\treturn conn;\n\t}\n\n\t/**\n\t * \n\t * @Description // 关闭资源\n\t * @author zyz\n\t * @date 2020年3月25日下午5:40:43\n\t * @param conn\n\t * @param ps\n\t */\n\tpublic static void closeResource(Connection conn, Statement ps) {\n\t\ttry {\n\t\t\tif (ps != null) {\n\t\t\t\tps.close();\n\t\t\t}\n\t\t} catch (Exception e2) {\n\t\t\t// TODO: handle exception\n\t\t}\n\t\ttry {\n\t\t\tif (conn != null) {\n\t\t\t\tconn.close();\n\t\t\t}\n\t\t} catch (Exception e2) {\n\t\t\t// TODO: handle exception\n            e.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n2、进一步可将增加、删除、修改中的共同操作（1.获取连接，2.预编译sql，3.填充sql，4.执行操作，5.关闭资源）封装到一个方法中。\n\n```java\n// 将增删改操作写成一个通用的方法\n\tpublic void update(String sql, Object ... args) {\n\t\t// 1.建立连接\n\t\tConnection conn = null;\n\t\t// 2.预编译sql\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = JDBCUtils.getConnection();\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\t// 3.填充占位符\n\t\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\t\tps.setObject(i + 1, args[i]);\n\t\t\t}\n\t\t\t// 4.执行操作\n\t\t\tps.execute();\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n            e.printStackTrace();\n\t\t} finally {\n\t\t\t// 5.关闭资源\n\t\t\tJDBCUtils.closeResource(conn, ps);\n\t\t}\n\t}\n\n\t@Test // 测试通用的方法\n\tpublic void testUpdate() {\n\t\tString sql = \"delete from customers where id =?\";\n\t\ttry {\n\t\t\tupdate(sql,3);\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n```\n\n### 查询操作\n\nJava与SQL对应数据类型转换表：\n       ![](jdbc/4.png)\n\n```java\n\tpublic void testQuery1() {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet resultset = null;\n\t\ttry {\n\t\t\t// 连接\n\t\t\tconn = JDBCUtils.getConnection();\n\t\t\t// 预编译sql\n\t\t\tString sql = \"select id,name,email,birth from customers where id = ?\";\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\t// 填充占位符\n\t\t\tps.setInt(1, 1);\n\t\t\t// 执行操作并返回结果集\n\t\t\tresultset = ps.executeQuery();\n\t\t\tif (resultset.next()) {// 判断结果集的下一条是否有数据\n\t\t\t\tint id = resultset.getInt(1);\n\t\t\t\tString name = resultset.getString(2);\n\t\t\t\tString email = resultset.getString(3);\n\t\t\t\tDate birth = resultset.getDate(4);\n\t\t\t\t// 将数据封装到一个对象中\n\t\t\t\tCustomer customer = new Customer(id, name, email, birth);\n\t\t\t\tSystem.out.println(customer);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n          e.printStackTrace();\n\t\t} finally {\n\t\t\tJDBCUtils.closeResource(conn, ps, resultset);\n\t\t}\n\t}\n```\n\n**针对Customer表创建通用的查询方法：**\n\n```java\npublic Customer queryCustomers(String sql, Object... args) throws Exception {\n\tConnection conn = null;\n\tPreparedStatement ps = null;\n\ttry {\n\t\tconn = JDBCUtils.getConnection();\n\t\tps = conn.prepareStatement(sql);\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tps.setObject(i + 1, args[i]);\n\t\t}\n\t\tResultSet resultset = ps.executeQuery();\n\t\t// 获取结果集中的元数据:ResultSetMetaData\n\t\tResultSetMetaData rsmd = resultset.getMetaData();\n\t\t// 通过ResultSetData 获取结果集中的列数\n\t\tint column = rsmd.getColumnCount();\n\t\t// 获取数据并封装到对象中\n\t\tif (resultset.next()) {\n\t\t\tCustomer customer = new Customer();\n\t\t\tfor (int i = 0; i < column; i++) {\n\t\t\t\t// 获取列值\n\t\t\t\tObject columnValue = resultset.getObject(i + 1);\n\t\t\t\t// 获取每个列的列名-----属性\n\t\t\t\tString columnName = rsmd.getColumnName(i + 1);\n\t\t\t\t// 通过反射给属性赋值\n\t\t\t\t// 通过列名获取属性\n\t\t\t\tField field = Customer.class.getDeclaredField(columnName);\n\t\t\t\tfield.setAccessible(true);\n\t\t\t\t// 给属性赋值\n\t\t\t\tfield.set(customer, columnValue);\n\t\t\t}\n\t\t\treturn customer;\n\t\t}\n\t} catch (Exception e) {\n\t\t// TODO: handle exception\n\t\te.printStackTrace();\n\t}finally {\n\t\tJDBCUtils.closeResource(conn, ps);\n\t}\n\treturn null;\n}\n\t\n@Test // 测试通用方法\npublic void testQueryCustomers() {\n\ttry {\n\t\tString sql = \"select id,name,email,birth from Customers where id = ? \";\n\t\tCustomer customer = queryCustomers(sql,12);\n\t\tSystem.out.println(customer);\n\t} catch (Exception e) {\n\t\t// TODO: handle exception\n\t\te.printStackTrace();\n\t}\n}\n```\n\n**针对Order表创建通用的查询方法：**\n\n```java\npublic class OrderQuery {\n\tpublic Order orderQuery(String sql, Object... args) {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\t\ttry {\n\t\t\tconn = JDBCUtils.getConnection();\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\t// 填充占位符\n\t\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\t\tps.setObject(i + 1, args[i]);\n\t\t\t}\n\t\t\t// 返回结果集\n\t\t\trs = ps.executeQuery();\n\t\t\t// 获取结果集元数据(用来修饰结果集的类，提供了结果集的各种属性值)\n\t\t\tResultSetMetaData metaData = rs.getMetaData();\n\t\t\t// 获取列数\n\t\t\tint columnCount = metaData.getColumnCount();\n\t\t\t// 将获取到的结果封装到Order对象中\n\t\t\tif (rs.next()) {\n\t\t\t\tOrder order = new Order();\n\t\t\t\t// 获取每一列的列值 通过结果集\n\t\t\t\tfor (int i = 0; i < columnCount; i++) {\n\t\t\t\t\tObject columnValue = rs.getObject(i + 1);\n\t\t\t\t\t// 获取每一列的列名   通过元数据\n\t\t\t\t\t//String columnName = metaData.getColumnName(i + 1);\n\t\t\t\t\t// 获取别名\n\t\t\t\t\tString columnName = metaData.getColumnLabel(i+1);\n\t\t\t\t\t// 通过反射，将对象指定名columnName的属性赋值为指定的属性columnValue\n\t\t\t\t\tField field = Order.class.getDeclaredField(columnName);\n\t\t\t\t\tfield.setAccessible(true);\n\t\t\t\t\tfield.set(order, columnValue);\n\t\t\t\t}\n\t\t\t\treturn order;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tJDBCUtils.closeResource(conn, ps,rs);\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Test\n\tpublic void testOrderQuery() {\n\t\ttry {\n\t\t\tString sql = \"select order_id orderId,order_name orderName,order_date orderDate from `order` where order_id = ?\";\n\t\t\tSystem.out.println(orderQuery(sql, 1));\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n![](jdbc/5.png)\n\n**通用的查询方法(针对所有的 表)：**\n\n```java\npublic class Query {\n    // 返回一条结果\n\tpublic <T> T query(Class<T> clazz, String sql, Object... args) {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\t\ttry {\n\t\t\tconn = JDBCUtils.getConnection();\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\t// 填充占位符\n\t\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\t\tps.setObject(i + 1, args[i]);\n\t\t\t}\n\t\t\t// 返回结果集\n\t\t\trs = ps.executeQuery();\n\t\t\t// 获取结果集元数据(用来修饰结果集的类，提供了结果集的各种属性值)\n\t\t\tResultSetMetaData metaData = rs.getMetaData();\n\t\t\t// 获取列数\n\t\t\tint columnCount = metaData.getColumnCount();\n\t\t\t// 将获取到的结果封装到Order对象中\n\t\t\tif (rs.next()) {\n\t\t\t\tT t = clazz.newInstance();\n\t\t\t\t// 获取每一列的列值 通过结果集\n\t\t\t\tfor (int i = 0; i < columnCount; i++) {\n\t\t\t\t\tObject columnValue = rs.getObject(i + 1);\n\t\t\t\t\t// 获取每一列的列名 通过元数据(表中的列名与类中的属性名不一致时会报错)\n\t\t\t\t\t// String columnName = metaData.getColumnName(i + 1);\n\t\t\t\t\t// 解决方式：获取别名(没有别名时即为列名)\n\t\t\t\t\tString columnName = metaData.getColumnLabel(i + 1);\n\t\t\t\t\t// 通过反射，将对象指定名columnName的属性赋值为指定的属性columnValue\n\t\t\t\t\tField field = clazz.getDeclaredField(columnName);\n\t\t\t\t\tfield.setAccessible(true);\n\t\t\t\t\tfield.set(t, columnValue);\n\t\t\t\t}\n\t\t\t\treturn t;\n\t\t\t}\n\t\t} catch (Exception e) \n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tJDBCUtils.closeResource(conn, ps, rs);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Test\n\tpublic void testQuery() {\n\t\ttry {\n\t\t\tString sql = \"select id,name,email from customers where id = ?\";\n\t\t\tSystem.out.println(query(Customer.class, sql, 2));\n\t\t\tString sql1 = \"select order_id orderId,order_name orderName,order_date orderDate from `order` where order_id = ?\";\n\t\t\tSystem.out.println(query(Order.class, sql1, 1));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t// 返回多条结果\n\tpublic <T> List<T> queries(Class<T> clazz, String sql, Object... args) {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\t\ttry {\n\t\t\tconn = JDBCUtils.getConnection();\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\t\tps.setObject(i + 1, args[i]);\n\t\t\t}\n\t\t\tint columnCount = metaData.getColumnCount();\n\t\t\t// 将获取到的结果封装到列表中\n\t\t\tList<T> list = new ArrayList<T>();\n\t\t\twhile (rs.next()) {\n\t\t\t\tT t = clazz.newInstance();\n\t\t\t\t// 获取每一列的列值 通过结果集\n\t\t\t\tfor (int i = 0; i < columnCount; i++) {\n\t\t\t\t\tObject columnValue = rs.getObject(i + 1);\n                    // 获取每一列的别名  通过元数据\n\t\t\t\t\tString columnName = metaData.getColumnLabel(i + 1);\n\t\t\t\t\t// 通过反射，将对象指定名columnName的属性赋值为指定的属性columnValue\n\t\t\t\t\tField field = clazz.getDeclaredField(columnName);\n\t\t\t\t\tfield.setAccessible(true);\n\t\t\t\t\tfield.set(t, columnValue);\n\t\t\t\t}\n\t\t\t\tlist.add(t);\n\t\t\t} \n\t\t\treturn list;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tJDBCUtils.closeResource(conn, ps, rs);\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t@Test\n\tpublic void testOrderQuery() {\n\t\ttry {\n\t\t\tString sql = \"select order_id orderId,order_name orderName,order_date orderDate from `order` where order_id < ?\";\n\t\t\tList<Order> orders = queries(Order.class,sql, 4);\n\t\t\torders.forEach(System.out::println);\n\t\t\tString sql1 = \"select id,name,email from customers where id < ?\";\n\t\t\tList<Customer> customers = queries(Customer.class, sql1, 10);\n\t\t\tcustomers.forEach(System.out::println);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n## 四、操作BLOB类型字段\n\nTinyBlob：255字节\n\t\tBlob：65K\n\t\tMediumBlob：16M\n\t\tLongBlob：4G\n\n```java\n@Test // 向Customers表中添加一条Blob类型数据\n\tpublic void testInsert() throws Exception {\n\t\tConnection conn = JDBCUtils.getConnection();\n\t\tString sql = \"insert into customers(name,email,birth,photo) value(?,?,?,?)\";\n\t\tPreparedStatement ps = conn.prepareStatement(sql);\n\t\tps.setObject(1, \"wd\");\n\t\tps.setObject(2, \"wd@qq.com\");\n\t\tps.setObject(3, \"1999-7-20\");\n\t\tFileInputStream in = new FileInputStream(new File(\"./src/wd1.jpg\"));\n\t\tps.setBlob(4, in);\n\t\tps.execute();\n\t\tJDBCUtils.closeResource(conn, ps);\n\t}\n\n\t@Test // 查询customers表中的Blob类型的数据\n\tpublic void testQuery() {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\t\tInputStream in = null;\n\t\tFileOutputStream out = null;\n\t\ttry {\n\t\t\tconn = JDBCUtils.getConnection();\n\t\t\tString sql = \"select id,name,email,birth,photo from Customers where id=? \";\n\t\t\tps = conn.prepareStatement(sql);\n\t\t\tps.setInt(1, 23);\n\t\t\trs = ps.executeQuery();\n\t\t\tif (rs.next()) {\n\t\t\t\tint id = rs.getInt(\"id\");// 既可以写索引，又可以写别名或字段名\n\t\t\t\tString name = rs.getString(\"name\");\n\t\t\t\tString email = rs.getString(\"email\");\n\t\t\t\tDate birth = rs.getDate(\"birth\");\n\t\t\t\tCustomer customer = new Customer(id, name, email, birth);\n\t\t\t\tSystem.out.println(customer);\n\n\t\t\t\tBlob photo = rs.getBlob(\"photo\");\n\t\t\t\tin = photo.getBinaryStream();\n\t\t\t\tout = new FileOutputStream(new File(\"./src/wd.jpg\"));\n\t\t\t\tbyte[] buffer = new byte[1024];\n\t\t\t\tint len;\n\t\t\t\twhile ((len = in.read(buffer)) != -1) {\n\t\t\t\t\tout.write(buffer, 0, len);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tif (in != null) {\n\t\t\t\ttry {\n\t\t\t\t\tin.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (out != null) {\n\t\t\t\ttry {\n\t\t\t\t\tout.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tJDBCUtils.closeResource(conn, ps, rs);\n\t\t}\n\t}\n```\n\n## 五、数据库事务\n\n**事务：**一组逻辑操作单元，使数据由一种状态变换到另一种状态。\n\n**事务处理：**要么所有的事务都被提交(commit)，那么这些修改就被永久的保存下来；要么放弃所作的全部修改，整个事务回滚(rollback)到最初的状态。\n\n**JDBC事务处理：**\n1.数据一旦提交，就不可回滚。\n2.DDL操作一旦执行，都会自动提交。\n    DML默认情况下，一旦执行，就会提交。可通过set autocommit=false 取消DML操作的自动提交。\n3.默认关闭连接的时候，自动提交。\n\n**JDBC程序中为了让多个SQL 语句作为一个事务执行：**\n调用Connection 对象的setAutoCommit(false); 以取消自动提交事务\n在所有的SQL 语句都成功执行后，调用commit(); 方法提交事务\n在出现异常时，调用rollback(); 方法回滚事务\n\n> 若此时Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。\n\n**事务的ACID属性：**\n1.**原子性(Atomicity)：**事务是一个不可分割的工作单位，事务的操作要么都发生，要么都不发生。\n2.**一致性(Consistency)：**事务必须使数据库从一个一致状态变换到另外一致状态。\n3.**隔离性(Isolation)：**一个事务的执行不能被其他事务干扰。\n4.**持久性(Durability)：**一个数据一旦被提交，它对数据库的改变就是永久性的。\n\n**数据库并发问题：**\n**脏读：**对于两个事务T1、T2，T1读取了已经被T2更新但还没被提交的数据。之后，若T2回滚，T1读取的数据就是无效的。\n**不可重复读：**对于两个事务T1、T2，T1读取了一个字段，然后T2更新了该字段。之后，T1再次读取同一个字段，值就不同了。\n**幻读：**对于两个事务T1、T2，T1从一个表中读了一个字段，然后T2再该表中插入了一些新的行。之后，如果如果T1再次读取同一个表，就会多出几行。\n\n**四种隔离级别：**隔离级别越高，一致性越好，并发性越弱。\n![](jdbc/6.png)\n\n## 六、DAO及相关实现类\n\nDAO：Data Access Object访问数据信息的类和接口，包括了对数据CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。\n有时也称作：BaseDAO(封装通用方法)\n作用：为了实现功能的模块化，更有利于代码的维护和升级。\n\n## 七、数据库连接池\n\n**数据库连接池基本思想：**为数据库连接建立一个“缓冲池”，预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕后再放回去。\n\nJDBC的数据库连接池使用javax.sql.DataSource 来表示，DataSource只是一个接口，该接口通常由服务器(Weblogic,WebSphere,Tomcat)提供实现，也有一些开源组织提供实现。\n![](jdbc/9.png)\n\nDruid数据库连接池\n\n```java\n@Test\npublic void getConnection() throws Exception {\n    Properties pros = new Properties();\n    InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"druid.properties\");\n    pros.load(is);\n    DataSource dataSource = DruidDataSourceFactory.createDataSource(pros);\n    Connection conn = dataSource.getConnection();\n    System.out.println(conn);\n}\n```\n\n\n![](jdbc/8.png)\n\n配置属性：\n![](jdbc/10.png)\n\n## 八、Apache-DBUtils实现CRUD操作\n\ncommons-dbutils 是Apache 组织提供的一个开源JDBC工具类库，封装了增删改查操作。\n\n```java\npublic class QueryRunnerTest {\n\t@Test\n\tpublic void testInsert() {\n\t\tConnection conn = null;\n\t\ttry {\n\t\t\tQueryRunner runner = new QueryRunner();\n\t\t\tconn = JDBCUtils.getConnection();\n\t\t\tString sql = \"insert into customers(name,email,birth) value(?,?,?)\";\n\t\t\tint insertCount = runner.update(conn, sql, \"zyz\", \"zyz@qq.com\", \"1999-1-1\");\n\t\t\tSystem.out.println(insertCount);\n\t\t} catch (SQLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tJDBCUtils.closeResource(conn, null);\n\t\t}\n\t}\n\n\t@Test // BeanHandler是ResultSetHandler接口的一个实现类，用于封装表中的一条记录\n\tpublic void testQuery1() {\n\t\tConnection conn = null;\n\t\ttry {\n\t\t\tQueryRunner runner = new QueryRunner();\n\t\t\tconn = JDBCUtils.getConnection();\n\t\t\tString sql = \"select id,name,email,birth from customers where id = ?\";\n\t\t\tBeanHandler<Customer> handler = new BeanHandler<Customer>(Customer.class);\n\t\t\tCustomer customer = runner.query(conn, sql, handler, 2);\n\t\t\tSystem.out.println(customer);\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tJDBCUtils.closeResource(conn, null);\n\t\t}\n\t}\n\n\t@Test // BeanListhandler是ResultSetHandler接口的一个实现类，用于封装表中的多条记录构成的集合\n\tpublic void testQuery2() {\n\t\tConnection conn = null;\n\t\ttry {\n\t\t\tQueryRunner runner = new QueryRunner();\n\t\t\tconn = JDBCUtils.getConnection();\n\t\t\tString sql = \"select id,name,email,birth from customers where id > ?\";\n\t\t\tBeanListHandler<Customer> handler = new BeanListHandler<Customer>(Customer.class);\n\t\t\tList<Customer> customers = runner.query(conn, sql, handler, 2);\n\t\t\tcustomers.forEach(System.out::println);\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tJDBCUtils.closeResource(conn, null);\n\t\t}\n\t}\n\t\n\t@Test // 查询特殊值\n\tpublic void testQuery3() {\n\t\tConnection conn = null;\n\t\ttry {\n\t\t\tQueryRunner runner = new QueryRunner();\n\t\t\tconn = JDBCUtils.getConnection();\n\t\t\tString sql = \"select count(*) from customers\";\n\t\t\tScalarHandler handler = new ScalarHandler();\n\t\t\tLong count = (Long) runner.query(conn, sql, handler);\n\t\t\tSystem.out.println(count);\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tJDBCUtils.closeResource(conn, null);\n\t\t}\n\t}\n}\n```\n\n","tags":["JDBC"],"categories":["JavaSE"]},{"title":"MySQL变量,存储过程,流程结构","url":"/2020/03/22/mysql-06/","content":"\n## 变量\n\n__系统变量：__由系统提供，属于服务层面<!--more-->\n_全局变量：_服务器每次启动将为所有全局变量赋初值。针对所有会话(连接)有效，但不能跨重启。\n_会话变量：_仅仅针对于当前的会话(连接)有效。<!--more-->\n查看所有的系统变量：show global | [ session] variable;\n查看满足条件的系统变量：show global | [session] variable  like '%char%';\n查看指定系统变量：select @@global | [session].系统变量名;\n为某个系统变量赋值：\nset global | [session] 系统变量名=值;\nset @@global \\ [session].系统变量名=值;\n\n__自定义变量：__用户自定义\n_用户变量：_针对于当前会话(连接)有效\n1.声明并初始化\nset @用户变量名=值;\nset @用户变量名:=值;\nselect @用户变量名:=值;\n2.赋值\nset @用户变量名=值;\nset @用户变量名:=值;\nselect @用户变量名:=值;\nselect into select 字段  into 变量名 from 表;\n_局部变量：_仅仅在定义它的begin end中有效\n1.声明\ndeclare 变量 类型 [default 值];\n2.赋值\n与用户变量相同\n\n## 存储过程\n\n事先经过编译并存储在数据库中一组完成特定功能的sql语句的集合。就是数据库 SQL 语言层面的代码封装与重用。\n好处：\n1.提高了代码的重用性；\n2.简化操作；\n3.减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率。\n\n```sql\n/*\n一、创建存储过程\n语法：\ncreate procedure 存储过程名(参数列表)\nbegin\n\t存储过程体\nend\n\n1、参数列表分为：参数模式  参数名 参数类型\n参数模式：\nin：该参数可以作为输入，也就是说该参数需要调用方传入值\nout：该参数可以作为输出，也就是说该参数可以作为返回值\ninout：该参数既可以作为输入也可以作为输入\n\n二、调用存储过程\n语法：\ncall  储存过程名(实参列表);\n*/\n\nCREATE PROCEDURE myp1()\nBEGIN\nINSERT  INTO admin(username,`password`)\nVALUES(\"Taylor\",\"123456\"),(\"Tom\",\"123456\"),(\"Jerry\",\"123456\");\nEND \n\nCALL myp1;\n\n# 创建带in模式参数的储存过程\n# 创建存储过程判断用户是否登录成功\nCREATE PROCEDURE myp2(IN username VARCHAR(10),IN `password` VARCHAR(10))\nBEGIN\n\t\tDECLARE result INT DEFAULT(0);\n\t\tSELECT COUNT(*) INTO result\n\t\tFROM admin WHERE admin.username=username AND admin.`password`=`password`;\n\t\tSELECT IF(result>0,\"成功\",\"失败\");\nEND\n\nCALL myp2(\"Taylor\",\"123456\");\n\n# 创建带out模式参数的储存过程\nCREATE PROCEDURE myp3(IN username VARCHAR(10),IN `password` VARCHAR(10),OUT result char(5))\nBEGIN\n\t\tDECLARE result1 INT DEFAULT(0);\n\t\tSELECT COUNT(*) INTO result1\n\t\tFROM admin WHERE admin.username=username AND admin.`password`=`password`;\n\t\tSET result = IF(result1>0,\"true\",\"false\");\nEND\n\nCALL myp3(\"Taylor\",\"123456\",@result);\nSELECT @result;\n\n# 三、删除储存过程\nDROP PROCEDURE myp3;\n\n# 四、查看储存过程\nSHOW CREATE PROCEDURE myp2;\n```\n\n## 函数\n\n与储存过程的区别：\n储存过程：可以有0个或多个返回值，适合批量插入、批量更新\n函数：有且仅有一个返回值，适合处理数据后返回一个结果。\n\n```sql\n# 创建函数\n/*\n语法：\ncreate function 函数名(参数列表) returns  返回类型\nbegin\n\t函数体  \nend\n*/\n```\n\n## 流程控制结构\n\n__if函数：__\nif(表达式1，表达式2，表达式3)：如果表达式1成立，返回表达式2的值，否则返回表达式3的值。\n\n__case结构：__\ncase 变量|表达式|字段\nwhen条件1或值 then 要返回的值或要执行的语句;\nwhen条件2或值 then 要返回的值或要执行的语句;\nwhen条件3或值 then 要返回的值或要执行的语句;\n......\nelse  要返回的值或要执行的语句;\n end case;\n\n__if结构：__\nif 条件1 then 语句1；\nelif 条件2 then 语句2；\n......\nelse then 语句n；\nend if;\n\n__循环结构：__\n分类：while , loop  , repeat \n循环控制：\niterate  类似于  continue  ,继续，结束本次循环继续下一次\nleavele  类似于 break   ,跳出  ，结束当前所在循环\n1.while\n\n```sql\n[标签:]while 循环条件 do\n\t循环体;\nend while [标签];\n```\n\n2.loop\n\n```sql\n[标签:]loop \n\t循环体;\nend loop [标签]\n```\n\n3.repeat\n\n```sql\n[标签:]repeat\n\t循环体;\nuntil 结束循环的条件\n end repeat [标签];\n```\n\n","tags":["MySQL"],"categories":["数据库"]},{"title":"事务,视图,索引","url":"/2020/03/21/mysql-05/","content":"\n__事务：__一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。<!--more-->\n**事务的属性：**\n原子性：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生；\n一致性：事务必须使数据库从一个一致状态变换到另外一个一致状态；\n隔离性：一个事务的执行不受其他事务的干扰；\n持久性：一个事务一旦被提交，它对数据库的改变就是永久的。\n\n## 事务的创建\n\n隐式事务：事务没有明显的开启和结束。\n显式事务：设置提交功能为禁用，事务具有明显的开启和结束的标记\n步骤1：开启事务\nset autocommit=0;\nstart transaction;# 可以省略\n步骤2：编写事务中的sql语句\n语句1;\n语句2;\n步骤3：结束事务\ncommit;或者rollback;\n\n## 数据库的隔离级别\n\n对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采用必要的隔离机制，就会导致各种并发问题：\n__脏读：__对于两个事务T1、T2，T1读取了已经被T2更新但还没有被提交的字段。之后，若T2回滚，T1读取的内容就是临时且无效的。\n__不可重复读：__对于两个事务T1、T2，T1读取了一个字段，然后T2更新了该字段。之后，T1再次读取同一个字段，值就不同了。\n__幻读：__对于两个事务T1、T2，T1从一个表中读取了一个字段，然后T2在该表中插入了一些新的行。之后，若T1再次读取同一个表，就会多出几行。\n![](mysql-05/1.png)\n\n## 视图\n\n从mysql5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。\n\n__创建视图：__\n\n```sql\n/*\n语法：\ncreate view 视图名\nas\n查询语句;\n*/\n# 查询邮箱中包含a字符的员工名、部门名和工种信息\nCREATE VIEW myview1 \nAS\nSELECT last_name,department_name,job_title FROM employees e\nJOIN departments d ON e.department_id=d.department_id\nJOIN jobs j ON e.job_id=j.job_id;\n\nSELECT * FROM myview1 WHERE last_name LIKE \"%a%\";\n```\n\n__好处：__\n1.重用sql语句\n2.简化复杂的sql操作，不必知道它的查询细节\n3.保护数据，提高安全性\n\n__删除视图：__drop view 视图名1,视图名2,...\n视图与表的区别：\n视图只是保留了sql逻辑，没有保存数据，虽然可以增删改查，但是一般只作查询使用。\n\n##  索引的分类\n\n索引是帮助数据库高效获取数据的数据结构。建立索引时会将数据排序，类似于图书的目录，根据目录中的索引查找到对应的页码。\n分为：\n\n- 主键索引（primary key）\n\t- 唯一的标识，主键不可重复，只能由一个列作为主键\n- 唯一索引（unique key）\n\t- 避免重复列的出现，唯一索引可以重复，多个列都可以标识为唯一索引\n- 常规索引 (key/index)\n\t- 默认的\n- 全文索引(fulltext)\n\t- 特定的数据库引擎才有\n\n> 创建索引的三种方式\n\n方式一：创建表的时候\n\n```sql\nCREATE TABLE user(\n\tid INT,\n    name varchar(20),\n    age TINYINT,\n    PRIMARY KEY (`id`),\n    UNiQUE KEY `UX_name` (`name`)\n)\n```\n\n方式二：使用alter table命令，创建普通索引、UNIQUE索引或PRIMARY KEY索引。\n\n```sql\nALTER TABLE table_name ADD INDEX index_name (column_list);\n```\n\n方式三：使用create index命令，增加普通索引或unique索引\n\n```sql\nCREATE INDEX index_name ON table_name (column_list);\n```\n\n索引在数据小的时候，作用不大，但是在数据大时，区别十分明显\n\n## 索引原则\n\n- 索引不是越多越好\n- 不要对经常变动的数据添加索引\n- 小数据不需要添加索引\n- 索引一般加在常用来查询的字段上","tags":["MySQL"],"categories":["数据库"]},{"title":"MySQL数据类型，约束，标识列","url":"/2020/03/21/mysql-04/","content":"\n## 一、数值型\n\n__整型：__\nTinyint：1个字节，有符号：-128到127 ，无符号(unsigned)：0到255\nSmallint：2个字节，有符号：-32768到32767，无符号数：0到65535\nMediumint：3个字节 \nint/Integer：4个字节\nBigint：8个字节<!--more-->\n__小数：__M：整数位+小数位，D：小数位\n定点数：（精度较高）\ndec(M,D) \ndecimal(M,D)\n浮点数：\nfloat(M,D)：4个字节\ndouble(M,D)：8个字节\n\n## 二、字符型\n\n__较短的文本：__最多的字符数M\nchar(M)：固定长度，M为0到255  可以省略  默认为1，比较耗费空间，效率较高\nvarchar(M)：可变长度，M为0到65535  不可以省略，节省空间，效率低\n\n## 三、日期型\n\ndate：4字节\ndatetime：8字节\ntimestamp：4字节\ntime：3字节\nyear：1字节\n\n## 常见约束\n\nNOT NULL：非空，保证该字段的值不能为空。比如姓名，学号等\nDEFAULT：默认，保证该字段有默认值。比如性别\nPRIMARITY：主键，保证该字段具有唯一性，且不为空。比如学号，员工编号\nUNIQUE：唯一，保证该字段具有唯一性。比如座位号\nCHECK：检查约束（mysql不支持）。比如性别\nFOREIGN KEY：外键，用于限制两个表的关系，保证该字段的值必须来自主表的关联的值。在从表添加外键约束，用于引用主表中某一列的值。比如学生表的专业编号，员工表的部门编号，员工表的工种编号\t\n\n```sql\n# 添加列级约束\nCREATE TABLE stuinfo(\n\t\tid INT PRIMARY KEY,# 主键\n\t\tstuname VARCHAR(10) NOT NULL,# 非空\n\t\tgender char(1) CHECK (gender='男' OR gender='女'),# 检查   不支持\n\t\tseatid INT  UNIQUE,# 唯一\n\t\tage INT DEFAULT 18,# 默认约束\n\t\tmajorid INT REFERENCES major(id)# 外键 不支持\n);\n\nCREATE TABLE major(\n\tid int PRIMARY KEY,\n\tmajorname varchar(20)\n);\n\nSHOW INDEX FROM stuinfo;# 查看所有的索引\n\n# 2.添加表级约束\nDROP TABLE stuinfo;\nCREATE TABLE stuinfo(\nid INT,\nstuname char(10),\ngender char(1),\nage INT,\nseatid INT,\nmajorid INT,\n\nCONSTRAINT pk PRIMARY KEY(id),# 主键\nCONSTRAINT ck CHECK(gender='男'or'女'),# 检查  不支持\nCONSTRAINT uq UNIQUE(seatid),# 唯一\nCONSTRAINT fk_stuinfo_major FOREIGN KEY (majorid) REFERENCES major(id) # 外键\n);\n# 修改表时添加约束\n/*\n1.添加列级约束\nalter table 表名 modify column 字段名 字段类型 新约束;\n2.添加表级约束\nalter table 表名 add [constraint 约束名] 约束类型(字段名) [外键的引用]\n*/\n```\n\n## 标识列\n\n```sql\n/*\n1.标识列必须与key（主键，外键，unique）搭配\n2.一个表至多有一个标识列\n3.标识列的类型只能是数值型\n4.可通过set auto_increment_increment=数字;设置步长\n*/\n# 创建表时设置标识列\nCREATE TABLE stuinfo(\nid INT PRIMARY KEY AUTO_INCREMENT,\nstuname char(10),\ngender char(1),\nage INT,\nseatid INT,\nmajorid INT\n);\n# 修改表时设置标识列\nALTER TABLE stuinfo MODIFY  COLUMN id INT PRIMARY KEY AUTO_INCREMENT;\n```\n\n\n\n","tags":["MySQL"],"categories":["数据库"]},{"title":"DML,DDL","url":"/2020/03/19/mysql-03/","content":"\n# 数据库操作语言DML\n\n## 一、插入语句\n\n\n语法：\n方式一：insert into 表名(列名,...) value(值1,...);\n方式二：insert into 表名 set 列名=值,列名=值,...<!--more-->\n\n```sql\nINSERT INTO beauty(id,name,sex,borndate,phone,photo,boyfriend_id)\n VALUES(13,'Taylor','女','1990-1-1','123456789',NULL,2);\nINSERT INTO beauty SET id =14,name='刘涛',phone='987654321';\n```\n\n## 二、修改语句\n修改单表：\n语法：update 表名 set 列=新值,....where 筛选条件;\n修改多表：\n语法：update 表1 别名,表2 别名 set 列=值,...where 连接条件;\nupdate 表1 别名inner join表2 别名 on 连接条件 set 列=值,...where 筛选条件;\n\n```sql\nUPDATE beauty SET phone='123456' WHERE name LIKE\"周%\";\n```\n\n\n\n## 三、删除语句\n\n删除单表：\n语法：delete from 表名 where 条件;\n删除多表：\n语法：delete 表1的别名,表2的别名 from 表1 别名，表2 别名where 连接条件 and 筛选条件;\n\t\t\tdelete 表1的别名,表2的别名 from 表1 别名 inner join表2 别名 on 连接条件\twhere 筛选条件;\n\n删除整表：truncate table 表名;\n1、如果要删除的表有自增长列，\n用delete删除后再插入数据自增长值从断点开始\n用truncate删除后再插入数据自增长的值从1开始\n2、truncate没有返回值\n3、truncate删除不能回滚，delete删除可以回滚\n\n```sql\nDELETE FROM beauty WHERE phone LIKE \"%9\";\n```\n\n# 数据定义语言DDL\n\n## 库的管理\n\n```sql\n# 1.库的创建\n/*\n语法：create database [if not exists]库名;\n*/\nCREATE DATABASE book;\n# 2.库的修改\n/*\n一般不作修改\n更改字符集：alter database 库名  character set 字符集;\n*/\n# 3.库的删除\n/*\n语法：drop [if exists]database 库名;\n*/\nDROP DATABASE book;\n```\n\n## 表的管理\n\n### 创建：create\n\n```sql\n/*\n语法：\ncreate table 表名(\n\t列名 列的类型[(长度)约束],\n\t列名 列的类型[(长度)约束],\n\t....\n\t列名 列的类型[(长度)约束],\n);\n*/\nUSE book;\nCREATE TABLE book(\n\tid INT,# 编号\n\tbname varchar(20),# 书名\n\tprice DOUBLE,# 价格\n\tauthor INT,# 作者id\n\tpublishDate DATETIME # 出版日期\n\t);\nDESC book; # 查看表\n\nCREATE TABLE author(\n\tid INT,\n\tau_name varchar(20),\n\tnation varchar(10)\n);\nDESC author;\n\n# 表的复制\n# 仅仅复制表的结构\nCREATE TABLE copy LIKE book;\n# 复制表的结构和数据\nCREATE TABLE copy1 select * FROM book;\n```\n\n### 修改：alter\n\n```sql\n# 修改列名\nALTER TABLE\tbook CHANGE COLUMN publishDate pubdate DATETIME;\n# 修改列的类型和约束\nALTER TABLE book MODIFY COLUMN pubDate TIMESTAMP\n# 添加新列\nALTER TABLE author ADD COLUMN annual DOUBLE;\n# 删除列\nALTER TABLE author DROP COLUMN annual;\n# 修改表名\nALTER TABLE author RENAME book_author;\n```\n\n### 删除：drop\n\n```sql\nDROP TABLE IF EXISTS book_author;\n```\n\n","tags":["MySQL"],"categories":["数据库"]},{"title":"反射","url":"/2020/03/15/java-10/","content":"\n## 反射\n\n反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。<!--more-->\n__类的加载过程：__\n程序经过javac.exe命令后，会生成一个或多个字节码文件(.class)，接着使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中，即类的加载。加载到内存中的类，我们就成为运行时类，此运行时类就作为Class的一个实例。\n加载到内存中的运行时类，会缓存一段时间。在此时间内，我们可以通过不同的方式来获取此运行时类。\n\n## 获取Class实例\n\n```java\n@Test // 获取Class实例\npublic void test1() throws ClassNotFoundException {\n    // 方式一:调用运行类属性：.class\n    Class class0 = Person.class;\n    System.out.println(class0);\n    // 方式二：调用运行时类的对象，调用getClass()\n    Person p1 = new Person();\n    Class class1 = p1.getClass();\n    System.out.println(class1);\n    // 方式三：调用Class的静态方法：forName(String classPath)\n    Class class2 = Class.forName(\"reflection.Person\");\n    System.out.println(class2);\n    // 方式四：使用类加载器：Classloader\n    ClassLoader classLoader = ClassTest.class.getClassLoader();\n    Class class3 = classLoader.loadClass(\"reflection.Person\");\n    System.out.println(class3);\n}\n```\n\n## 调用运行时类指定结构\n\n```java\n@Test\npublic void test2() throws Exception {\n    // 通过反射创建对应的运行时类\n    Class<Person> class1 = Person.class;\n    // 创建运行时类的对象\n    Person p1 = class1.newInstance();\n    System.out.println(p1);\n    // 获取运行时类的属性getField(String fieldName),只能获取权限为public的属性\n    Field id = class1.getField(\"id\");\n    // 通常使用getDeclaredField(String FieldName)获取运行时类的属性\n    Field name = class1.getDeclaredField(\"name\");\n    name.setAccessible(true);// 表示当前属性时可访问的\n    // 设置属性值 set(实例对象,属性值)\n    id.set(p1,10001);\n    name.set(p1,\"Tony\");\n\n    // 获取属性值\n    int p1_id = (int) id.get(p1);\n    System.out.println(p1_id);// 10001\n    System.out.println(name.get(p1));// Tony\n    System.out.println(p1);// Person{id=10001, name='Tony', age=0}\n\n    // 获取运行时类方法 getDeclaredMethod(方法名,指定方法的形参列表)\n    Method setAge = class1.getDeclaredMethod(\"setAge\", int.class);\n    setAge.setAccessible(true);// 指明该方法可访问\n    // 执行运行时类方法 invoke(对象实例,实参列表)\n    // invoke()的返回值即为对应类中调用方法的返回值\n    setAge.invoke(p1,24);\n    System.out.println(p1);// Person{id=10001, name='Tony', age=24}\n\n    // 获取指定构造器\n    Constructor con = class1.getDeclaredConstructor(int.class,String.class,int.class);\n    con.setAccessible(true);\n    Person p2 = (Person) con.newInstance(1002,\"Taylor\",18);\n    System.out.println(p2);// Person{id=1002, name='Taylor', age=18}\n}\n```\n\n","tags":["JavaSE"],"categories":["JavaSE"]},{"title":"网络编程","url":"/2020/03/13/java-09/","content":"\n## TCP网络编程\n\n使用TCP连接进行通信的客户端和服务端<!--more-->\n\n```java\n    @Test  // 客户端\n    public void client() {\n        // 1.创建Socket对象，指明服务器端的IP和端口号\n        Socket socket = null;\n        OutputStream os = null;\n        try {\n            InetAddress inet = InetAddress.getByName(\"127.0.0.1\");\n            socket = new Socket(inet, 9999);\n            // 2.创建输出流\n            os = socket.getOutputStream();\n            // 3.向外写数据\n            os.write(\"hello? hello? hello?\".getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (os != null) {\n                    // 4.关闭输入流\n                    os.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            try {\n                if (socket != null) {\n                    // 5.关闭Socket\n                    socket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n```\n\n```java\n@Test  // 服务端\n    public void server() {\n        Socket socket = null;\n        InputStream is = null;\n        ByteOutputStream byteOutputStream = null;\n        ServerSocket serverSocket = null;\n        try {\n            // 1.创建服务器端的ServerSocket，指明端口号\n            serverSocket = new ServerSocket(9999);\n            // 2.接受来自客户端的Socket\n            socket = serverSocket.accept();\n            // 3.创建输入流\n            is = socket.getInputStream();\n            byteOutputStream = new ByteOutputStream();\n            byte[] buffer = new byte[5];\n            int len;\n            // 4.读取数据\n            while ((len = is.read(buffer)) != -1) {\n                // 将buffer数组中的数据写到ByteOutputStream类的一个数组中\n                byteOutputStream.write(buffer, 0, len);\n            }\n            System.out.println(\"收到消息，来自：\"+socket.getInetAddress());\n            System.out.println(byteOutputStream.toString());\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {// 5.关闭流和socket\n            if (byteOutputStream != null) {\n                try {\n                    byteOutputStream.close();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (serverSocket != null) {\n                try {\n                    serverSocket.close();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n```\n\n## 使用TCP实现文件传输\n\n```java\n  @Test\n    public void client() throws IOException {\n        // 创建socket并绑定IP和端口号\n        Socket socket = new Socket(\"127.0.0.1\",9999);\n        // 创建输出流，发送数据\n        OutputStream outputStream = socket.getOutputStream();\n        // 创建文件输入流，外部读取文件内容\n        FileInputStream fi = new FileInputStream(new File(\"../java_08/pic2.png\"));\n        byte[] buffer = new byte[20];\n        int len;\n        while ((len = fi.read(buffer))!=-1) {\n            outputStream.write(buffer,0,len);\n        }\n        // 关闭数据输出\n        socket.shutdownOutput();\n\n        // 客户端接收服务端的反馈信息\n        InputStream inputStream = socket.getInputStream();\n        ByteOutputStream byteOutputStream = new ByteOutputStream();\n        byte[] buffer1 = new byte[20];\n        int len1;\n        while((len=inputStream.read(buffer1))!=-1){\n            byteOutputStream.write(buffer1,0,len);\n        }\n        System.out.println(byteOutputStream.toString());\n        byteOutputStream.close();\n        inputStream.close();\n\n        outputStream.close();\n        fi.close();\n        socket.close();\n    }\n\n    @Test\n    public void server() throws IOException {\n        // 创建服务端ServerSocket并绑定端口\n        ServerSocket serverSocket = new ServerSocket(9999);\n        // 接收客户端socket\n        Socket socket = serverSocket.accept();\n        // 创建输入流，接收数据\n        InputStream inputStream = socket.getInputStream();\n        // 创建文件输出流，用于保存接收到的文件\n        FileOutputStream fo = new FileOutputStream(new File(\"rec1.png\"));\n        byte[] buffer = new byte[20];\n        int len;\n        while((len = inputStream.read(buffer))!=-1){\n            fo.write(buffer,0,len);\n        }\n\n        // 服务器反馈消息给客户端\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(\"图片已接收到！\".getBytes());\n        outputStream.close();\n\n        fo.close();\n        inputStream.close();\n        socket.close();\n        serverSocket.close();\n    }\n}\n```\n\n## UDP网络编程\n\n```java\n@Test\npublic void sender() throws IOException {\n    // 1.创建套接字\n    DatagramSocket socket = new DatagramSocket();\n    InetAddress inet = InetAddress.getByName(\"127.0.0.1\");\n    String str = \"哈哈哈哈哈哈哈~\";\n    byte[] data = str.getBytes();\n    // 2.初始化数据包，绑定IP,和端口号，确定数据的字节长度\n    DatagramPacket packet = new DatagramPacket(data,0,data.length,inet,9999);\n    // 3.发送数据包\n    socket.send(packet);\n    // 4.关闭Socket\n    socket.close();\n}\n\n@Test\npublic void receiver() throws IOException {\n    // 1.创建套接字\n    DatagramSocket socket = new DatagramSocket(9999);\n    // 2.创建用于接收数据的字节数组\n    byte[] buffer = new byte[1024];\n    // 3.创建数据包\n    DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length);\n    // 4.接收数据\n    socket.receive(packet);\n    // 5.将接收的数据打印到控制台\n    System.out.println(new String(packet.getData(),0,packet.getLength()));\n    // 6.关闭socket\n    socket.close();\n}\n```\n\n## URL编程\n\n```java\n@Test\n    public void test() {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        FileOutputStream fo = null;\n        try {\n            // 创建URL对象\n            URL url = new URL(\"http://localhost:8888/index.html\");\n            // 创建连接对象\n            con = (HttpURLConnection) url.openConnection();\n            // 创建连接\n            con.connect();\n            // 创建输入流，用于读取数据\n            is = con.getInputStream();\n            // 创建文件输出流，将读取的数据写到本地\n            fo = new FileOutputStream(new File(\"index.html\"));\n            byte[] buffer = new byte[20];\n            int len;\n            while ((len = is.read(buffer)) != -1) {\n                fo.write(buffer, 0, len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n        }\n        if (fo != null) {\n            try {\n                fo.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (con != null) {\n                try {\n                    con.disconnect();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n\n        }\n    }\n```","tags":["JavaSE"],"categories":["JavaSE"]},{"title":"I/O流","url":"/2020/03/11/java-08/","content":"\n## File类的使用\n\n1、File类的一个对象，代表一个文件或一个文件目录\n2、File类声明在java.io包下<!--more-->\n__File类对象常用方法：__\n\n```java\n@Test\npublic void test1() throws IOException {\n    File file1 = new File(\"src/IO/hello.txt\");\n    // public String getAbsolutePath()：获取绝对路径\n    System.out.println(file1.getAbsoluteFile());\n    // public String getPath() ：获取路径\n    System.out.println(file1.getParent());\n    // public String getName() ：获取名称\n    System.out.println(file1.getName());\n    // public String getParent()：获取上层文件目录路径。若无，返回null\n    System.out.println(file1.getParent());\n    // public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。\n    System.out.println(file1.length());\n    // public long lastModified() ：获取最后一次的修改时间，毫秒值\n    // public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组\n    // public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组\n    //public boolean renameTo(File dest):把文件重命名为指定的文件路径\n    File file2 = new File(\"test.txt\");\n    file1.renameTo(file2);\n    // public boolean isDirectory()：判断是否是文件目录\n    // public boolean isFile() ：判断是否是文件\n    // public boolean exists() ：判断是否存在\n    // public boolean canRead() ：判断是否可读\n    // public boolean canWrite() ：判断是否可写\n    // public boolean isHidden() ：判断是否隐藏\n    System.out.println(file2.exists());// true\n    System.out.println(file1.exists());// false\n\n    // public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false\n    // public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。\n    // public boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建\n    // public boolean delete()：删除文件或者文件夹\n    File file3 = new File(\"test1.txt\");\n    file3.createNewFile();\n    file3.delete();\n\n}\n```\n\n## I/O流原理及流的分类\n\n按操作的数据单位分为：字节流，字符流\n按数据流向分为：输入流，输出流\n四个抽象基类：\n字节流：InputStream，OutputStream\n字符流：Reader，Writer\n\n按流的角色分为：节点流，处理流\n\n节点流：\n操作字节：FileInputStream，FileOutputStream\n操作字符：FileReader，FileWriter\n缓冲流（处理流的一种）：\n操作字节：BufferedInputStream，BufferedOutput\n操作字符：BufferedReader，BufferedWriter\n<img src=\"java-08/2.png\" style=\"zoom:80%;\" />\n\n## 使用FileReader从硬盘中读取字符数据\n\n```java\n@Test\npublic void test1() {\n    FileReader fileReader = null;\n    try {\n        // 1.实例化File类对象\n        File file1 = new File(\"test.txt\");// 相对于当前Modul\n        // 2.提供具体的流\n        fileReader = new FileReader(file1);\n        // 3.读数据\n        // read()返回读入的一个字符的ASCII码，如果到达末尾则返回-1\n        int data;\n        while ((data = fileReader.read()) != -1) {\n            System.out.print((char) data);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {// 防止内存泄漏，必须关闭流\n        // 4.关闭流\n        try {\n            if (fileReader != null) {\n                fileReader.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n@Test // 调用read(char[] cbuf) 返回每次读入cbuf数组中的字符个数，到达文件末尾返回-1\npublic void test2() throws IOException {\n    FileReader fr = null;\n    try {\n        File file1 = new File(\"test.txt\");\n        fr = new FileReader(file1);\n        char[] cbuf = new char[5];\n        int len;\n        while ((len = fr.read(cbuf)) != -1) {\n            //                for (int i = 0; i < cbuf.length; i++) {\n            //                    System.out.print(cbuf[i]);\n            //                }\n\n            /*方式一：\n               for(int i=0;i<len;i++){\n                    System.out.print(cbuf[i]);\n                }*/\n\n            // 方式二：\n            String str = new String(cbuf,0,len);\n            System.out.print(str);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        if (fr != null) {\n            fr.close();\n        }\n    }\n}\n```\n\n## 使用FileWriter向硬盘中写入字符数据\n\n```java\n/*\n * 文件不存在则自动创建；\n * new FileWriter(file1,false); 写入时将原来文件的内容覆盖(默认为false)\n * new FileWriter(file1,true); 写入时追加到原文件内容后面\n*/\n@Test // 利用输入流向硬盘中写入数据\npublic void test3() throws IOException {\n    FileWriter fw = null;\n    try {\n        // 1.提供File类的对象，指明要写入的文件\n        File file1 = new File(\"test.txt\");\n        // 提供FileWriter对象，用于数据写入\n        fw = new FileWriter(file1,true);\n        fw.write(\"哈哈哈哈哈,\");\n        fw.write(\"歪比巴卜\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        if(fw!=null){\n            fw.close();\n        }\n    }\n}\n```\n\n## 使用FileInputStream,FileOutputStream对字节文件的处理\n\n![](java-08/1.png)\n\n```java\n@Test\npublic void test1() throws IOException {\n    FileInputStream fi = null;\n    FileOutputStream fo = null;\n    try {\n        File file1 = new File(\"pic.png\");\n        File file2 = new File(\"pic1.png\");\n        fi = new FileInputStream(file1);\n        fo = new FileOutputStream(file2);\n        byte[] pic = new byte[10];\n        int len;// 获取读取的字符长度\n        while((len = fi.read(pic))!=-1){\n            fo.write(pic,0,len);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            if(fo!=null){\n                fo.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            if(fi!=null){\n                fi.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 缓冲流的使用\n\n```java\n @Test // 内部通过提供一个缓冲区，提高文件的读取，写入速度\npublic void test1(){\n    BufferedInputStream bis = null;\n    BufferedOutputStream bos = null;\n    try {\n        // 1.造文件\n        File file1 = new File(\"pic.png\");\n        File file2 = new File(\"pic2.png\");\n        // 2.造流\n        FileInputStream fis = new FileInputStream(file1);\n        FileOutputStream fos = new FileOutputStream(file2);\n        // 3.造缓冲流\n        bis = new BufferedInputStream(fis);\n        bos = new BufferedOutputStream(fos);\n        // 4.读取和写入\n        byte[] buff = new byte[5];\n        int len;\n        while((len = bis.read(buff))!=-1){\n            bos.write(buff,0,len);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            if(bis!=null){\n                bis.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        try {\n            if(bos!=null){\n                bos.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 转换流\n\nInputStreamReader：将IntputStream转换为Reader\n\nOutputStreamWriter：将Writer转化为OutputStream\n\n## 对象流\n\n序列化：使用ObjectOutputStream类保存基本数据类型数据或对象\n反序列化：使用ObjectInputStream类读取基本数据类型数据或对象\n__对象的序列化：__允许把内存中的java对象转化为与平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或是通过网络节点将这种二进制流传输到另一个网络节点。当程序获取到这种二进制流后，可以恢复成原来的java对象。\n__对象的序列化与反序列化：__\n\n```java\n@Test  //序列化\npublic void test1(){\n    ObjectOutputStream oos = null;\n    try {\n        oos = new ObjectOutputStream(new FileOutputStream(\"test.dat\"));\n        oos.writeObject(new String(\"哈哈哈哈哈哈哈哈哈\"));\n        oos.flush();\n        oos.writeObject(new Person(\"马老师\",40));\n        oos.flush();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            if(oos!=null){\n                oos.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n@Test\npublic void test2(){\n    ObjectInputStream ois = null;\n    try {\n        ois = new ObjectInputStream(new FileInputStream(\"test.dat\"));\n        Object o = ois.readObject();\n        String str = (String) o;\n        System.out.println(str);// 哈哈哈哈哈哈哈哈哈\n        Person p = (Person) ois.readObject();\n        System.out.println(p);// Person{name='马老师', age=40}\n\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    } finally {\n        if(ois!=null){\n            try {\n                ois.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n```java\n/**\n * @author zyz\n * @description 1、序列化对象需要实现Serializable接口\n *              2、需要提供一个静态的全局常量serialVersionUID\n *              3、保证当前类的所有属性是可序列化的\n * @create 2020-03-12 15:47\n */\npublic class Person implements Serializable {\n    private String name;\n    private int age;\n    public static final long serialVersionUID = 42256165416L;\n\n    public Person() {\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n```\n\n\n\n","tags":["JavaSE"],"categories":["JavaSE"]},{"title":"泛型","url":"/2020/03/11/java-07/","content":"\n## 泛型的概念\n\n允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。<!--more-->\n\n- 类型的参数化，就是可以把类型像方法的参数那样传递。\n- 泛型使编译器可以在编译期间对类型进行检查以提高类型安全，减少运行时由于对象类型不匹配引发的异常。\n\n```java\n    @Test\n    public void test1(){\n        ArrayList<Integer> list = new ArrayList<Integer>();\n        list.add(111);\n        list.add(222);\n        list.add(333);\n//        for (Integer num:list){\n//            System.out.println(num);\n//        }\n        Iterator<Integer> iterator = list.iterator();\n        while(iterator.hasNext()){\n            System.out.println(iterator.next());\n        }\n    }\n\n    @Test\n    public void test2(){\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\n        map.put(\"Tony\",18);\n        map.put(\"Troye\",25);\n        map.put(\"Taylor\",20);\n        Set<Map.Entry<String, Integer>> entries = map.entrySet();\n        Iterator<Map.Entry<String, Integer>> iterator = entries.iterator();\n        while(iterator.hasNext()){\n            Map.Entry<String,Integer> entry = iterator.next();\n            System.out.println(entry .getKey()+\"-----\"+entry .getValue());\n        }\n    }\n```\n\n## List<?>、List<? extends T> 与 List<? super T>\n\n```java\npublic class Test3 {\n    public static void main(String[] args) {\n        List list = new ArrayList();\n        list.add(new Object());\n        list.add(new Integer(111));\n        list.add(new String(\"aaa\"));\n        Object o = list.get(0);\n\n        // List<?> 允许get元素，不允许添加元素\n        List<?> list1 = list;\n        list1.remove(0);\n        list1.remove(new Integer(111));\n        // list1.add(new String(\"bbb\"));\n        Object o1 = list1.get(0);\n        list1.stream().forEach(System.out::println);\n\n        ArrayList<Person> persons = new ArrayList<>();\n        persons.add(new Person());\n        persons.add(new Male());\n        persons.add(new Female());\n        // List<? extends Person> 允许get元素，不允许添加元素\n        List<? extends Person> persons1 = persons;\n        // persons1.add(new Person());\n        // persons1.add(new Male());\n        // persons1.add(new Female());\n        Person person = persons1.get(0);\n\n        // List<? super Person> 允许添加元素，不允许get元素\n        List<? super Person> persons2 = new ArrayList<Person>();\n        persons2.add(new Male());\n        persons2.add(new Female());\n        persons2.add(new Person());\n        // Person person = persons2.get(0);\n\n    }\n}\n```","tags":["JavaSE"],"categories":["JavaSE"]},{"title":"集合","url":"/2020/03/02/java-06/","content":"\n# 集合与数组\n\n__数组：__\n1.一旦初始化，长度就不可修改了；\n2.一旦定义后，就只能操作指定类型的数据了；\n3.数组提供的方法非常有限，且效率不高；<!--more-->\n4.获取数组中实际元素的个数，没有现成的属性和方法可调用；\n5.存储特点：有序，可重复。\n__集合：__Java集合分为Collection和Map两种体系\n![](java-06/1.jpg)\n__Collection接口：__单列数据，存储一个一个的对象\n<1> List接口：元素有序，可重复，可以存null，遍历元素使用迭代器以及下标遍历get()\n实现类：\nArrayList，作为List接口的主要实现类；线程不安全，效率高；底层使用Object[] elementData存储\nLinkedList，对于频繁插入，删除效率较高；底层使用双向链表储存\nVector，作为List接口的古老实现类；线程安全，效率低；底层使用Object[] elementData存储\n<2> Set接口：元素无序，不可重复，只能存一个null，便利元素时只能使用迭代器遍历\n实现类：\nHashSet，作为Set接口的主要实现类；线程不安全；可以存储null\nLinkedHashSet，HashSet的子类；遍历时可以按照添加的顺序遍历；对于频繁遍历效率较高\nTreeSet，要求数据是同一个类型，可按照对象的指定属性进行排序\n__Map接口：__双列数据，存储具有映射关系”key - value对“\n实现类：\nHashMap，作为Map的主要实现类；线程不安全，效率高；能存储null的键值对\n\t\t-> LinkedHashMap，保证在遍历元素时，可以按照添加顺序进行遍历；对于频繁遍历效率较高\n        ->原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前、后的元素。\nTreeMap，按照添加的key-value进行排序；底层采用红黑树\nHashtable，作为Map的古老实现类；线程安全，效率低；不能存存储null的键值对\n\t   -> Properties，常用来处理配置文件。key和value都是String类型\n\n## Collection接口中的方法\n\n```java\n@Test\n    public void test1() {\n        Collection coll1 = new ArrayList();\n        // add(Object e) 将元素e添加到集合中\n        coll1.add(\"aaa\");\n        coll1.add(123);//自动装箱\n        coll1.add(new Date());\n        // size() 获取添加元素的个数\n        System.out.println(coll1.size());// 3\n        // addAll(Collection coll) 将coll的所有元素添加到当前集合中\n        Collection coll2 = new ArrayList();\n        coll2.addAll(coll1);\n        System.out.println(coll2);// 自动调用toString() [aaa, 123, Wed Mar 04 15:58:00 CST 2020]\n        // isEmpty() 判断当前集合是否为空\n        System.out.println(coll1.isEmpty());// false\n        // clear() 清空集合元素\n        coll1.clear();\n        System.out.println(coll1.isEmpty());// true\n        // contains(Object e) 是否包含某个元素\n        // 会调用obj类对象的equals()\n        Collection coll3 = new ArrayList();\n        coll3.add(1);\n        coll3.add(\"abc\");\n        coll3.add(new String(\"hello\"));\n        System.out.println(coll3);// [1, abc, hello]\n        System.out.println(coll3.contains(\"hello\"));// true\n        // containAll(Collection coll) 判断形参coll中所有的元素是否在当前集合中\n        Collection coll4 = Arrays.asList(\"abc\", 1);\n        System.out.println(coll3.containsAll(coll4));// true\n    }\n\n    @Test\n    public void test2() {\n        Collection coll1 = new ArrayList();\n        coll1.add(1);\n        coll1.add(2);\n        coll1.add(3);\n        coll1.add(\"abc\");\n        System.out.println(coll1);// [1, 2, 3, abc]\n        // remove(Object e)\n        coll1.remove(\"abc\");\n        System.out.println(coll1);// [1, 2, 3]\n        // removeAll(Collection coll) 从当前集合中移除coll中所有的元素\n        Collection coll2 = Arrays.asList(1, 2);\n        coll1.removeAll(coll2);\n        System.out.println(coll1);// [3]\n        // retainAll(Collection coll) 返回交集\n        Collection coll3 = new ArrayList();\n        coll3.add(1);\n        coll3.add(2);\n        Collection coll4 = Arrays.asList(1, 2, 3);\n        coll3.retainAll(coll4);\n        System.out.println(coll3);// [1, 2]\n        // toArray() 集合->数组\n        // 数组->集合 Arrays.asList()\n    }\n```\n\n### 迭代器Iterator接口\n\n```java\n @Test  //集合元素的遍历，调用迭代器Iterator接口\n    public void test3() {\n        Collection coll1 = new ArrayList();\n        coll1.add(1);\n        coll1.add(2);\n        coll1.add(3);\n        // 实例化迭代器对象\n        Iterator iterator = coll1.iterator();\n//        for (int i = 0; i < coll1.size(); i++) {\n//            System.out.println( iterator.next());\n//        }\n        // 起始指针位于第一个元素之前\n        // hasNext() 判断是否还有下一个元素\n        // next() 指针下移，将下移以后的集合位置上的元素返回\n        while(iterator.hasNext()){\n            Object obj = iterator.next();\n            if(obj.equals(new Integer(1))){\n                iterator.remove();\n            }\n        }\n        iterator = coll1.iterator();\n        while(iterator.hasNext()){\n            System.out.println(iterator.next());\n        }\n    }\n}\n```\n\n### foreach循环\n\n```java\n   @Test\n    public void test1(){\n        Collection coll1 = new ArrayList();\n        coll1.add(1);\n        coll1.add(2);\n        coll1.add(3);\n        coll1.add(4);\n        // 使用foreach进行遍历  for(集合元素类型 局部变量 : 集合对象)\n        for (Object obj:coll1) {//将coll1的元素依次取出并赋给obj\n            System.out.println(obj);\n        }\n    }\n\n    @Test\n    public void test2(){\n        int[] arr1 = new int[]{1,2,3,4,5};\n        for (int a:arr1) {\n            a = 6;\n        }// 对原数组没有影响\n        for (int i = 0; i < arr1.length; i++) {\n            arr1[i] = 6;\n        }// 对原数组的值进行修改\n\n        for (int i = 0; i < arr1.length; i++) {\n            System.out.println(arr1[i]);\n        }\n    }\n```\n\n### List常用方法\n\n```java\n @Test //List常用方法\n    public void test1(){\n    // void add(int index, Object ele):在index位置插入ele元素\n    // boolean addAll(int index, Collection eles):从index位置开始将eles中 的所有元素添加进来\n    // Object get(int index):获取指定index位置的元素\n        ArrayList list1 = new ArrayList();\n        list1.add(1);\n        list1.add(2);\n        list1.add(3);  \n        list1.add(4);\n        list1.add(3);\n        System.out.println(list1.get(1));// 2\n    // int indexOf(Object obj):返回obj在集合中首次出现的位置\n        System.out.println(list1.indexOf(4));// 3\n    // int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置\n        System.out.println(list1.lastIndexOf(3));// 4\n    // Object remove(int index):移除指定index位置的元素，并返回此元素\n        System.out.println(\"删除索引为2的元素:\"+list1.remove(2));// 删除索引为2的元素:3\n        System.out.println(list1);// [1, 2, 4, 3]\n    // Object set(int index, Object ele):设置指定index位置的元素为ele\n        list1.set(1,5);\n        System.out.println(list1);//[1, 5, 4, 3]\n    // List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex 位置的子集合\n        System.out.println(list1.subList(1,4));// [5, 4, 3]\n    }\n```\n\n### LinkedList的可顺序遍历性\n\n```java\n  @Test // LinkedList可按顺序进行遍历  使用foreach遍历\n    // LinkedList对数据进行储存时添加了两个引用，用于记录前一个元素和后一个元素的位置，\n    // 因此可按元素的添加顺序进行遍历，并且对频繁的遍历效率较高\n    public void test2(){\n        LinkedList linkedList1 = new LinkedList();\n        linkedList1.add(1111);\n        linkedList1.add(2222);\n        linkedList1.add(3333);\n        for(Object obj : linkedList1){\n            System.out.println(obj);\n        }// 1111 2222 3333\n    }\n}\n```\n\n### Set常用方法\n\nHashSet并没有添加新的方法，沿用Collection的方法\n\n### HashSet的添加\n\n向Set中添加数据一定要重写hashCode()和equals()方法，相等的对象必须具有相同的散列码\n\n```java\n@Test // HashSet 无序性  使用迭代器遍历\n    public void test1(){\n        // 无序性：不等于随机性，存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值\n        // 不可重复性：保证添加的元素按equals()进行判断时，不能返回true\n        /*\n        添加元素的过程：\n        向HashSet中添加元素a,首先调用元素a所在类的hashCode(),计算元素a的哈希值,\n        此哈希值与数组长度-1做与运算，计算出在HashSet底层数组中的存放位置,判断此位置上是否有其他元素：\n            如果此位置没有其他元素，则元素a添加成功\n            如果此位置上有元素b(或以链表形式存在的多个元素),则比较a,b的哈希值：\n                如果哈希值不相同，则元素a添加成功(以链表形式,元素a指向原来的元素，并取代原来元素的位置;jdk8:采用红黑树（查找速度快）)\n                如果哈希值相同，进而调用元素a所在类的equals()：\n                    equals()返回true,则元素a添加失败\n                    equals()返回false,则添加成功\n         */\n        HashSet set1 = new HashSet();\n        set1.add(111);\n        set1.add(222);\n        set1.add(333);\n        Iterator iterator = set1.iterator();\n        while(iterator.hasNext()){\n            System.out.println(iterator.next());\n        }// 333 222 111\n    }\n```\n\n### TreeSet按指定属性进行排序\n\n```java\n @Test //TreeSet按指定属性遍历\n    public void test3(){\n        TreeSet treeSet1 = new TreeSet();\n        // 按大小排序输出\n        treeSet1.add(1);\n        treeSet1.add(-1);\n        treeSet1.add(0);\n        Iterator iterator = treeSet1.iterator();\n        while(iterator.hasNext()){\n            System.out.println(iterator.next());\n        }// -1 0 1\n\n        TreeSet treeSet2 = new TreeSet();\n        treeSet2.add(new Person(\"Tom\",\"male\",20));\n        treeSet2.add(new Person(\"Taylor\",\"female\",18));\n        treeSet2.add(new Person(\"Troye\",\"male\",22));\n        treeSet2.add(new Person(\"Justin\",\"male\",22));\n\n        Iterator iterator2 = treeSet2.iterator();\n        while(iterator2.hasNext()){\n            System.out.println(iterator2.next());\n        }\n    }\n```\n\nPerson类实现Comparable接口并重写toCompare()方法\n\n```java\n @Override // 按照年龄排序\n    public int compareTo(Object o) {\n        if (o instanceof Person) {\n            Person person = (Person)o;\n            int compare = this.age-person.age;// 从小到大\n            if(compare==0){// 年龄相同则按姓名进行排序\n               return this.name.compareTo(person.name);\n            }\n            else{\n                return compare;\n            }\n        }\n        else{\n            throw new RuntimeException(\"输入类型不匹配\");\n        }\n    }\n```\n\n输出结果：\n                        ![](java-06/result.png)\n\n--------------------------\n\n使用定制排序\n\n```java\n    @Test\n    public void test4(){\n        //定制排序\n        // 实例化Comparator类\n        Comparator comparator = new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                if(o1 instanceof Person && o1 instanceof Person){\n                    return ((Person) o1).getAge()-((Person)o2).getAge();\n                }\n                else{\n                    throw new RuntimeException(\"传入参数错误\");\n                }\n            }\n        };\n        TreeSet treeSet2 = new TreeSet(comparator);// 传入comparator参数\n        treeSet2.add(new Person(\"Tom\",\"male\",20));\n        treeSet2.add(new Person(\"Taylor\",\"female\",18));\n        treeSet2.add(new Person(\"Troye\",\"male\",22));\n        treeSet2.add(new Person(\"Justin\",\"male\",15));\n\n        Iterator iterator2 = treeSet2.iterator();\n        while(iterator2.hasNext()){\n            System.out.println(iterator2.next());\n        }\n    }\n```\n\n## List与数组之间的相互转换和遍历\n\n```java\npublic class Test1 {\n    public static void main(String[] args) {\n        Integer[] arr = {1, 2, 3, 4, 5};\n        // 数组转集合\n        /**\n         * Arrays.asList(arr) 返回的不是真正的 ArrayList 而是 Arrays中的一个内部类\n         */\n        ArrayList<Integer> arrToList = new ArrayList<Integer>(Arrays.asList(arr));\n        System.out.println(arrToList); // [1, 2, 3, 4, 5]\n        /**\n         * 遍历方式\n         */\n        // forEach 遍历\n        for (int num : arrToList) {\n            System.out.println(num);\n        }\n        // java8函数式接口遍历\n        arrToList.stream().forEach(System.out::println);\n        arrToList.stream().forEach(num -> {\n            System.out.println(num);\n        });\n\n        // 集合转数组\n        ArrayList<Integer> list = new ArrayList<>();\n        for (int i = 1; i <=5; i++) {\n            list.add(i);\n        }\n        // 初始化数组，指定类型，防止泛型丢失\n        Integer[] listToArr = new Integer[list.size()];\n        // 使用有参数的toArray(T[] a)\n        arrToList.toArray(listToArr);\n        System.out.println(Arrays.toString(listToArr));// [1, 2, 3, 4, 5]\n        // 遍历\n        Arrays.stream(listToArr).forEach(System.out::println);\n    }\n}\n```\n\n## Map接口\n\n__Map的结构：__\nMap中的key：无序，不可重复，使用Set储存所有的key，key所在的类要重写equals()和 hashCode()\nMap中的value：无序，可重复，使用List存储所有的value，value所在类要重写equals()\n一个键值对构成一个entry对象\nMap中的entry：无序，不可重复，使用Set储存所有的entry\n__HashMap的底层实现原理：__\nHashMap map = new HashMap();\n实例化后，底层创建了一个长度为16的一维数组Entry[] table\nmap.put(key1,value1);\n在jdk7中，首先调用key1所在类的hashCode()计算key的哈希值，此哈希值通过某种算法后，得到在Entry数组中的存放位置；\n如果此位置为空，则添加成功，\n否则将key1的哈希值与此位置上的一个或多个元素(key2,value2)的哈希值比较，\n如果哈希值不同，则添加成功,\n否则调用key1所在类的equals()，如果返回false，则添加成功，否则添加到链表头部（jdk8插入尾部）。\n涉及到扩容时，容量扩大为原来的2倍，原有的数据全部被复制过来。\n\n在jdk8中，没有马上就创建数组，而是在put()时创建Node[]数组\n\n### Map接口中的方法\n\n```java\n  @Test\n    public void test1() {\n//  添加、删除、修改操作：\n// Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中\n        HashMap map1 = new HashMap();\n        map1.put(\"A\",111);\n        map1.put(\"B\",222);\n        map1.put(\"C\",333);\n        System.out.println(map1);// {A=111, B=222, C=333}\n// void putAll(Map m):将m中的所有key-value对存放到当前map中\n        HashMap map2 = new HashMap();\n        map2.putAll(map1);\n        System.out.println(map2);// {A=111, B=222, C=333}\n// Object remove(Object key)：移除指定key的key-value对，并返回value\n        Object a = map2.remove(\"A\");\n        System.out.println(a);// 111\n        System.out.println(map2);// {B=222, C=333}\n// void clear()：清空当前map中的所有数据\n        map2.clear();\n        System.out.println(map2);// {}\n// 元素查询的操作：\n// Object get(Object key)：获取指定key对应的value\n        Object b = map1.get(\"B\");\n        System.out.println(b);// 222\n// boolean containsKey(Object key)：是否包含指定的key\n        System.out.println(map1.containsKey(\"D\"));// false\n// boolean containsValue(Object value)：是否包含指定的value\n        System.out.println(map1.containsValue(222));// true\n// int size()：返回map中key-value对的个数\n        System.out.println(map2.size());// 0\n        System.out.println(map1.size());// 4\n// boolean isEmpty()：判断当前map是否为空\n        System.out.println(map2.isEmpty());// true\n// boolean equals(Object obj)：判断当前map和参数对象obj是否相等\n// 元视图操作的方法：\n// Set keySet()：返回所有key构成的Set集合\n        Set set1 = map1.keySet();\n        Iterator iterator = set1.iterator();\n        while(iterator.hasNext()){\n            System.out.println(iterator.next());\n        }// A B C\n// Collection values()：返回所有value构成的Collection集合\n        Collection coll1 = map1.values();\n        Iterator iterator1 = coll1.iterator();\n        while(iterator1.hasNext()){\n            System.out.println(iterator1.next());\n        }// 111 222 333\n// Set entrySet()：返回所有key-value对构成的Set集合\n        Set set2 = map1.entrySet();\n        System.out.println(set2);// [A=111, B=222, C=333]\n        Iterator iterator2 = set2.iterator();\n        while(iterator2.hasNext()){\n            Object obj = iterator2.next();\n            Map.Entry entry = (Map.Entry) obj;\n            System.out.println(entry.getKey() +\"===\"+entry.getValue());\n        }\n    }\n```\n\n> 集合初始化时，指定集合初始值大小。如果暂时无法确定集合大小，那么指定相应的默认值，这也要求我们记得各种集合的默认值大小， ArrayList 大小为10 HashMap 默认值为 16 。\n>\n> 在HashMap中initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor）默认为 0.75。\n>\n> ​                                                                                                                                         -----来自《阿里java开发手册》\n\n# 集合工具类\n\n```java\n    @Test\n    public void test1(){\n// 排序操作：（均为static方法）\n// reverse(List)：反转List 中元素的顺序\n        List list = new ArrayList();\n        list.add(111);\n        list.add(222);\n        list.add(333);\n        list.add(444);\n        System.out.println(list);// [111, 222, 333, 444]\n        Collections.reverse(list);\n        System.out.println(list);// [444, 333, 222, 111]\n// shuffle(List)：对List 集合元素进行随机排序\n        Collections.shuffle(list);\n        System.out.println(list);\n// sort(List)：根据元素的自然顺序对指定List 集合元素按升序排序\n        Collections.sort(list);\n        System.out.println(list);// [111, 222, 333, 444]\n// sort(List，Comparator)：根据指定的Comparator 产生的顺序对List 集合元素进行排序\n// swap(List，int，int)：将指定list 集合中的i 处元素和j 处元素进行交换\n        \n// 查找、替换\n// Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\n// Object max(Collection，Comparator)：根据Comparator 指定的顺序，返回给定集合中的最大元素\n// Object min(Collection)\n// Object min(Collection，Comparator)\n// int frequency(Collection，Object)：返回指定集合中指定元素的出现次数\n// void copy(List dest,List src)：将src中的内容复制到dest中\n        \n// boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值\n\n    }\n```\n\n","tags":["JavaSE"],"categories":["JavaSE"]},{"title":"Java常用类","url":"/2020/02/26/java-05/","content":"\n## 字符串相关类：String\n\n1.String声明为final，不可被继承。\n2.实现了Serializable接口：表示字符串是支持序列化的;\n   实现了Comparable接口：表示String是可以比较大小的；<!--more-->\n3.String内部定义了final char[]\tvalue[]用于存储字符串数据；\n4.String代表不可变的字符序列。\n\n- 当对字符串重新赋值；\n\n- 对现有字符串进行连接操作；\n\n- 当调用replace()修改指定字符或字符串时；\n\t**都会重新指定内存区域进行赋值。**\n\n5.通过字面量的方式给一个字符串赋值，此时字符串的值声明在字符串常量池中。\n\n在jdk1.6之前，字符串常量池在JVM的方法区中，jdk1.7之后移到了堆中的永久代（jdk1.8改为元空间）\n\n![字面量赋值方式](java-05/String_1.png)\t\t\n\t6.字符串常量池是不会存储相同内容的字符串的。\n\n### String实例化的两种方式：\n\n```java\n// String实例化方式一：字面量赋值 \n// 首先会从字符串常量池中查找，如果该字符串已经存在，在返回引用，否则在字符串常量池中创建\nString st1 = \"abc\";\n// String实例化方式二：new + 构造器 在堆空间中创建\nString st2 = new String(\"abc\");\n```\n\n内存解析：\n![](java-05/String_2.png)\n\n![](java-05/String_3.png)\n\n> intern 方法是一个native方法，intern方法会从字符串常量池中查询当前字符串是否存在，如果存在，就直接返回当前字符串；如果不存在就会将当前字符串放入常量池中，之后再返回。\n\n### String常用方法\n\n ```java\npublic class StringMethodTest {\n    @Test\n    public void test1() {\n        String st1 = \"Taylor Swift\";\n        // int length()：返回字符串的长度：return value.length\n        System.out.println(st1.length());// 12\n        // char charAt(int index)：返回某索引处的字符return value[index]\n        System.out.println(st1.charAt(0));// T\n        // boolean isEmpty()：判断是否是空字符串：return value.length == 0\n        System.out.println(st1.isEmpty());// false\n        // String toLowerCase()：使用默认语言环境，将String 中的所有字符转换为小写\n        System.out.println(st1.toLowerCase());// taylor swift\n        // String toUpperCase()：使用默认语言环境，将String 中的所有字符转换为大写\n        System.out.println(st1.toUpperCase());// TAYLOR SWIFT\n        // String trim()：返回字符串的副本，忽略前导空白和尾部空白\n        String st2 = \" hello world \";\n        String st3 = st2.trim();\n        System.out.println(st3);// \" hello world \"\n        System.out.println(st2.trim());// \"hello world\"\n        // boolean equals(Object obj)：比较字符串的内容是否相同\n        System.out.println(st2.equals(\" hello world \"));// true\n        System.out.println(st2.equals(st3));// false\n        //boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写\n        System.out.println(st2.equalsIgnoreCase(\" HELLO world \"));// true\n        //String concat(String str)：将指定字符串连接到此字符串的结尾。等价于用“+”\n        String st4 = \"Justin \".concat(\"Bieber\");\n        System.out.println(st4);// Justin Bieber\n        //int compareTo(String anotherString)：比较两个字符串的大小\n        String st5 = \"abc\";\n        String st6 = \"abd\";\n        System.out.println(st5.compareTo(st6));// -1  (c-d=>99-100)\n        //String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。\n        String st7 = \"学习JAVA高级语法\";\n        System.out.println(st7.substring(2));// JAVA高级语法\n        //String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。\n        System.out.println(st7.substring(0,6));//学习JAVA\n    }\n\n    @Test\n    public void test2(){\n        // boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束\n        String st1 = \"Jim Smith\";\n        System.out.println(st1.endsWith(\"aaa\"));// false\n        System.out.println(st1.endsWith(\"Smith\"));// true\n        // boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始\n        String st2 = \"张伟\";\n        System.out.println(st2.startsWith(\"张\"));// true\n        // boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始\n        System.out.println(st2.startsWith(\"张\",0 ));// true\n        System.out.println(st2.startsWith(\"张伟dsg\",0 ));// false\n        // boolean contains(CharSequence s)：当且仅当此字符串包含指定的char值序列时，返回true\n        System.out.println(\"hello world\".contains(\"o\"));// true\n        // int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引\n        System.out.println(\"Runnable\".indexOf(\"n\"));// 2\n        // int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始(包含此索引)\n        System.out.println(\"hellohello\".indexOf(\"l\",4));// 7\n        // int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引\n        System.out.println(\"hello\".lastIndexOf(\"l\"));// 3\n        // int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索\n        System.out.println(\"helloworld\".lastIndexOf(\"o\",9));// 6\n        // 注：indexOf和lastIndexOf方法如果未找到都是返回-1\n\n    }\n\n    @Test\n    public void test3(){\n        // String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用newChar 替换此字符串中出现的所有oldChar得到的。\n        String st1 = \"aabbccaa\";\n        String st2 = st1.replace('a','A');\n        System.out.println(st2);\n        // String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。\n        // String replaceAll(String regex, String replacement) ：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。\n        // String replaceFirst(String regex, String replacement) ：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。\n        // boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。\n        // String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。\n        // String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此 字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。\n    }\n}\n ```\n\n### String 与char[]转换\n\n```java\npublic void test1(){\n        // String -> char[]  调用String的toCharArray()\n        String st1 = \"qwerasdf\";\n        char[] charArray1 = st1.toCharArray();\n        for (int i = 0; i < charArray1.length; i++) {\n            System.out.print(charArray1[i]);\n        }\n        // char[] -> String  调用String()构造器\n        String st2 = new String(charArray1);\n        System.out.println(st2);\n    }\n```\n\n### String与byte[] 转换\n\n```java\npublic void test2() throws UnsupportedEncodingException {\n        // String -> byte[]  调用String的getBytes()\n        String st1 = \"abc123哈哈\";\n        byte[] byteArray1 = st1.getBytes();// 使用默认编码\n        System.out.println(Arrays.toString(byteArray1));// [97, 98, 99, 49, 50, 51, -27, -109, -120, -27, -109, -120]\n        byte[] byteArray2 = st1.getBytes(\"gbk\");\n        System.out.println(Arrays.toString(byteArray2));// [97, 98, 99, 49, 50, 51, -71, -2, -71, -2]\n        // byte[] ->String    调用String()构造器\n        String st2 = new String(byteArray1);\n        System.out.println(st2);// abc123哈哈\n        String st3 = new String(byteArray2,\"gbk\");\n        System.out.println(st3);// abc123哈哈\n    }\n}\n```\n\n## StringBuffer 与 StringBuilder\n\nString：不可变的字符序列\nStringBuffer：可变的字符序列；线程安全，效率低\nStringBuilder：可变的字符系列；线程不安全，效率高\n底层都是使用char[]存储\nStringBuffer(StringBuilder)常用方法：\n\n```java\n public void test1(){\n        // StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接\n        StringBuffer st1 = new StringBuffer(\"abc\");\n        st1.append(\"!!!\");// abc!!!\n        System.out.println(st1);\n        // StringBuffer delete(int start,int end)：删除指定位置的内容\n        st1.delete(0,1);// 取头不取尾\n        System.out.println(st1);// bc!!!\n        // StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str\n        st1.replace(2,4,\"de\");\n        System.out.println(st1);// bcde!\n        // StringBuffer insert(int offset, xxx)：在指定位置插入xxx\n        st1.insert(4,\"f\");\n        System.out.println(st1);// bcdef!\n        // StringBuffer reverse() ：把当前字符序列逆转\n        System.out.println(st1.reverse());// !fedcb\n        // public int indexOf(String str) 返回指定字符串的索引位置\n        System.out.println(st1.indexOf(\"b\"));// 5\n        // public String substring(int start,int end) 截取指定起始位置的字符串\n        System.out.println(st1.substring(1,5));// fedc\n        // public int length()\n        // public char charAt(int n )\n        // public void setCharAt(int n ,char ch)\n    }\n}\n```\n\n## 日期时间API\n\nDate类\n\n```java\n@Test // System类中的currentTimeMillis()\npublic void test1(){\n    // 时间戳：返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差\n    long time = System.currentTimeMillis();\n    System.out.println(time);\n}\n\n@Test // util.Date类\npublic void test2(){\n    // 构造器一：Date(),创建一个当前时间的Date对象\n    Date date1 = new Date();\n    System.out.println(date1);// 默认调用重写的toString()\n    System.out.println(date1.getTime());// getTime()获取当前时间对应的毫秒数\n    // 构造器二：Date(long time)\n}\n```\n\nSimpleDateFormat类\n\n```java\n@Test\npublic void test1() throws ParseException {\n    // 实例化SimpleDateFormat,使用默认构造器\n    SimpleDateFormat sdf = new SimpleDateFormat();\n    Date date1 = new Date();\n    // 格式化日期 日期->String\n    String date2 = sdf.format(date1);\n    System.out.println(date1);// Mon Mar 02 14:15:11 CST 2020\n    System.out.println(date2);// 20-3-2 下午2:15\n    // 解析 String->日期\n    String date3 = \"20-3-2 下午2:15\";\n    Date date4 = sdf.parse(date3);\n    System.out.println(date4);// Mon Mar 02 14:15:00 CST 2020\n    // 使用带参构造器\n    SimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd hh-mm-ss\");\n    System.out.println(sdf2.format(new Date()));// 2020-03-02 02-24-05\n}\n```\n\n## 比较器\n\n__自然排序：__java.lang.Comparable\n需要进行比较的类需要实现`Comparable`接口中的`toCompare()`方法，在实现`Comperable`接口时可使用该类作为泛型限定，在编译期间即可发现传入参数是否为需要进行比较的实体对象。\n\n```java\n@Override // 按照年龄排序\npublic int compareTo(Object o) {\n    if (o instanceof Person) {\n        Person person = (Person)o;\n        // return Integer.compare(this.age,preson.age);\n        return this.age-person.age;// 从小到大\n    }\n    else{\n        throw new RuntimeException(\"输入类型不匹配\");\n    }\n}\n```\n\n__定制排序：__java.util.Comparator\n需要重写`Comparator`类中的`compare()`方法\n\n```java\nComparator comparator = new Comparator() {\n    @Override\n    public int compare(Object o1, Object o2) {\n        if(o1 instanceof Person && o2 instanceof Person){\n            return ((Person) o1).getAge()-((Person)o2).getAge();\n        }\n        else{\n            throw new RuntimeException(\"传入参数错误\");\n        }\n    }\n};\n```\n\n## 枚举类\n\n```java\npublic class EnumTest1 {\n    public static void main(String[] args) {\n        StudentGrade stu = StudentGrade.ONE;\n        System.out.println(stu);// 自动调用Enum中的toString()\n\n        // values()返回枚举类型的对象数组\n        StudentGrade[] values = StudentGrade.values();\n        for (int i = 0; i < values.length; i++) {\n            System.out.println(values[i]);\n        }\n        // valueOf()把一个字符串转为对应的枚举类对象\n        StudentGrade stu2 = StudentGrade.valueOf(\"TWO\");\n        System.out.println(stu2);// TWO\n    }\n}\n\nenum StudentGrade{\n    // 提供当前枚举类的对象\n    ONE(\"大一\"),\n    TWO(\"大二\"),\n    THREE(\"大三\"),\n    FOUR(\"大四\");\n    // 声明StudentGrade对象的属性\n    private final String grade;\n    // 私有化构造器\n    private StudentGrade(String grade){\n        this.grade = grade;\n    }\n\n    public String getGrade(){\n        return this.grade;\n    }\n}\n```\n\n","tags":["JavaSE"],"categories":["JavaSE"]},{"title":"Linux 常用命令","url":"/2020/02/25/linux-02/","content":"\n## 关机&重启命令\n\n__shutdown__(默认1分钟后关机)\n\t\tshutdown -h now : 立即关机\n\t\tshutdown -h 1 : 1分钟后关机\n\t\tshutdown -r now : 立即重启<!--more-->\n__halt:__禁用cpu，相当于直接关机\n__reboot:__立即重启\n__sync:__把内存上的数据同步到磁盘上(关机或重启前应该先执行此指令，防止数据丢失)\n\n## 用户登录和注销\n\n__su 用户名：__切换用户\n__logout：__注销用户，在图形运行级别无效\n\n## 用户管理\n\nLinux是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n每个用户至少属于一个组。\n__添加用户：__ useradd -r -m -s /bin/bash 用户名\n-r：建立系统账号\n-m：自动建立用户的登入目录\n-s：指定用户登入后所使用的shell\t\n__指定密码：__passwd 用户名\n__删除用户：__ \nuserdel 用户名(删除用户保留家目录)\nuserdel -r 用户名 (删除用户及用户主目录)\t\n__查询用户：__id 用户名\n__查看当前用户：__whoami  /who am I\n__用户组：__系统对有共性的多个用户进行统一的管理\n添加组：groupadd  组名\n查看组id：grep 组名 /etc/group\n修改组账户：groupmod -g[新id] -n[新组名] 组名\n删除组：groupdel 组名\n增加用户时直接加上组：useradd -g 用户组 用户\n修改用户组：usermod -g 用户组 用户\n相关文件：\n/etc/passwd：用户的配置文件，记录用户的各种信息\n用户名：口令：用户标识号：组标识号：注释性描述：登录shell\n/etc/shadow：口令配置文件\n登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：不活动时间：失效时间：标志\n/etc/group：组配置文件\n组名：口令：组标识符\n\n## 运行级别\n\n0：关机\n\t\t1：单用户（找回丢失密码）\n\t\t2：多用户状态没有网络服务\n\t\t3：多用户状态有网络\n\t\t4：系统未使用保留给用户\n\t\t5：图形界面\n\t\t6：系统重启\n\t\t\t\t/etc/inittab文件查看运行级别（ubuntu没有此文件）\n\t\t\t\t修改默认运行级别：init [012356] (然后按ctrl+alt+F1，Ubuntu进入命令界面 )\n![](linux-02/4.png)\n\n## 帮助指令\n\nman 指令\nhelp 指令\n\n## 文件管理\n\n​\t__pwd：__显示当前目录的绝对路径\n\n​\t__ls [选项] [目录或是文件]：__显示指定目录霞的文件信息\n​\t\t\t常用选项：\n​\t\t\t-a：显示当前目录的所有文件或目录，包括隐藏文件；\n​\t\t\t-l：以列表的方式显示信息。\n​\t\t\t_ls -a -l 等价于 ll_\n\n​\t__cd [目录]：__进入指定目录\n​\t\t\t绝对路径：从根目录出发定位  /home\n​\t\t\t相对路径：从当前路径出发定位 ../home\n​\t\t\tcd ~  进入当前用户的家目录\n​\t\t\tcd ..  进入当前目录的上一级目录\n\n​\t__mkdir [选项] 目录：__创建目录\n​\t\t\t-p：创建多级目录\n​\t\t\trmdir [] 目录：删除目录\n​\t\t\tredir 目录：删除的是空目录；rm -rf 目录：删除非空目录\n\n​\t__touch 文件名：__创建一个空文件（可以一次创建多个文件）\n\n​\t__cp [选项] 原文件 指定目录：__拷贝文件到指定目录\n​\t\t\t-r：递归复制整个文件夹\t\n\n​\t__rm [选项] 要删除的文件夹或目录：__删除指定文件夹\n​\t\t\t-r：递归删除整个文件夹\n​\t\t\t-f：强制删除不提示\t\n\n​\t__mv 原文件名 新文件名：__文件重命名\n​\t\t\t__mv 原文件路径 新文件路径：__移动文件\t\n\n​\t__cat [选项] 文件路径：__查看文件内容\t\n​\t\t\t-n：显示行号\n​\t\t\t管道命令：|，前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）\t\n​\t\t\t|more：分页显示\n​\t\t\t|less：效率比more高\n\n​\t__>输出重定向：__\n​\t\t\t__>>追加：__\n​\t\t\tls -l >文件：将列表的内容写入文件中\n​\t\t\tls -l >>文件：将列表的内容追加到文件的末尾\n\n​\t__echo [选项] [输出内容]：__输出内容到控制台\n\n​\t__head 文件名：__查看文件前10行\n​\t\t\thead -n 行数：查看文件的前任意行\n\n​\t__tail 文件名：__查看文件尾10行\n​\t\t\ttail -n 行数：查看文件尾任意行\n​\t\t\ttail -f 文件名：实时监控文件的更新\n\n​\t__ln -s 原文件或目录 软链接：__给文件创建一个软链接，相当于windows中的快捷方式\n\n​\t__history ：__查看或执行(! 编号)已经执行过的指令\n\n## 时间日期类\n\n__date：__显示当前时间日期\n\t\tdate \"+%Y-%M-%d %H:%m:%S\"：按指定格式显示时间日期\n\t\tdate -s 字符串时间日期：设置时间日期\n\n__cal：__显示当前日历\t\t\n\n## 搜索查找类\n\n__find [搜索范围] [选项] ：__从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。\n选项：-name 文件名：按文件名查找\n\t\t\t-user 用户名：按用户名查找\n\t\t\t-size +/-文件大小：按文件大小查找（+表示大于  -表示小于  默认为等于）\n\n__locate 文件名：__定位文件路径\n\n__grep [选项] 查找内容 源文件：__\n\t选项：-n：匹配行号\n\t\t\t\t-i：忽略大小写\n\n## 压缩和解压类\n\n__gzip 文件名：__压缩文件\n\n__gunzip 文件名：__解压文件\n\n__zip [选项] 文件名.zip 将要压缩的内容：__压缩文件\n\t\t选项：-r：递归压缩，即压缩目录\n\n__unzip [选项] 文件名.zip：__解压缩文件\n\t\t选项：-d：指定解压后文件的存放目录\n\n__tar [选项] 文件名.tar.gz 打包的内容__\t\t\n\t\t选项：\n\t\t-c：产生.tar打包文件\n\t\t-v：显示详细信息\n\t\t-f：指定压缩后的文件\n\t\t-z：打包同时压缩\n\t\t-x：解包.tar文件\n\t\ttar -zcvf xxx.tar.gz 要压缩的文件或目录：压缩文件\n\t\ttar -zxvf xxx.tar.gz -C 路径：解压到指定路径\n\n## 用户组管理\n\n在linux中的每一个用户都必须属于一个组们不能独立于组外。\n\t\t在linux中每个文件有所有者，所在组，其他组。\n        __文件/目录的所有者：__一般为文件的创建者\n\t\t查看文件的所有者：ls -ahl\n\t\tchown 文件名 用户：更改文件所有者\n\t\tchgrp 组名 文件名：修改文件所在组\n\t\tchown 新的所有者:新的所在组 文件名：同时改变文件所有者和所在组  \n\t\t-R：如果是目录则使其下所有子文件或目录递归生效\n\n__创建组：groupadd 组名__\n\t\t在组内添加用户：useradd -g 组名 用户名\n\t\t改变用户所在组：usermod -g 组名 用户名\n\t\t改变用户登录的初始目录：usermod -d 目录名 用户 \n\n__文件/目录权限：__\n![](linux-02/1.png)\t\tr：对于文件代表可以读取，查看\n\t\tw：对于文件代表可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件的目录有写权限。\n\t\tx：对于文件代表可以执行\n\nr：对于目录，可以读取，ls查看目录内容\n\t\tw：对于目录，可以修改，目录内创建，删除，重命名\n\t\tx：对于目录，可以进入该目录\n\n## 文件/目录权限管理\n\nchmod：修改文件/目录权限\n\t\t第一种方式：+、-、= 变更权限\n\t\tu：所有者  g：所有组   o：其他人  a：所有人\n\t\tchmod u=rwc,g=rx,o=x 文件目录名\n\t\tchmod o+w 文件目录名\n\t\tchmod a-x 文件目录名\n\t\t规定：r=4  w=2  x=1\n\n## 任务调度\n\ncrontab [选项]\n\t\t-e   编辑crontab定时任务\n\t\t-l     查看crontab任务\n\t\t-r     删除当前用户所有的crontab任务\n![](linux-02/2.png)\n![](linux-02/3.png)\n\n## 磁盘分区、挂载\n\n分区的方式：\n\n**1) mbr分区:**\n1.最多支持四个主分区\n2.系统只能安装在主分区\n3.扩展分区要占一个主分区\n4.MBR最大只支持2TB，但拥有最好的兼容性\n\n**2) gtp分区:**\n1.支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区）\n2.最大支持18EB的大容量（1EB=1024 PB，1PB=1024 TB ）\n3.windows7 64位以后支持gtp\n\nlinux的磁盘分区作为文件被挂载(mount)到根目录下的文件夹中，同时也可以将其卸载(umount)。\n硬盘说明：\n1.linux硬盘分IDE硬盘和SCSI硬盘，目前使用的基本上是SCSI硬盘。\n2.对于IDE硬盘，驱动器标识符为 ```hdx~```。\n3.对于SCSI硬盘则标识符为```sdx~```。\n\n查看所有设备的挂载情况：lsblk 或lsblk -f\n\n分区命令：fdisk /dev/sdb\n\t\tn 新增分区    w  写入退出\n\t\t格式化磁盘：mkfs -t ext4 /dev/sdb1\n\t\t挂载磁盘：mount  设备名称  挂载目录\n\t\t卸载磁盘：umount   设备名称或挂载目录\n\t\t永久挂载：通过修改  /etc/fstab   ----->   执行mount -a\n4.查询磁盘使用情况：\n查询磁盘整体使用情况：df -lh\n查询指定目录的磁盘使用情况：du -h 目录\n__工作常用指令：__\n1、统计/home文件夹下文件的个数\nls -l /home |grep \"^-\"|wc -l\n2、统计/home文件夹下的目录个数\nls -l /home | grep \"^d\" | wc -l\n3、统计/hom文件夹下文件的个数，包括子文件夹里面的\nls -lR /home |grep \"^-\"|wc -l\n4、统计/home文件夹下目录的个数，包括子文件夹下的\nls -lR /home | grep \"^d\" | wc -l\n5、以树状显示文件结构\ntree 目录\n\n## 进程管理\n\n**查看进程：**\n\nps -aux [| grep 进程名]：显示当前终端所有的进程信息\n\nps  -ef：查看父进程\n\n**终止进程：**\n\nkill -[选项] 进程号\n\nkillall 进程名\n选项：9  强制终止\n\n**service服务管理：**\n\nservice   服务名 [start | stop | restart | reload | status]\n\nls -l /etc/init.d/     列出系统服务\n\n**动态监控进程：**\n\ntop -d 秒数  ：每隔几秒就刷新\n\n**监控网络情况：**\n\nnetstat [选项]\n\n-n 按一定顺序排列输出\n-p 显示哪个进程在调用\n\n","tags":["Linux"],"categories":["Linux"]},{"title":"Linux目录结构,Xshell,Xftp，vim","url":"/2020/02/24/linux-01/","content":"\n## Linux目录结构\n\nlinux的文件系统采用级层式的树状目录结构，最上层是根目录  /  ，然后在此基础上创建其他目录。<!--more-->\n\t              ![层次结构图](linux-01/root.png)\n__/bin：__Binary的缩写，用于存放最经常使用的命令。\n__/sbin：__s就是Super User 的意思，用于存放系统管理员使用的系统管理程序。\n__/home：__存放普通用户的主目录，每一个用户都用自己的一个目录。\n__/root：__系统管理员的主目录，也称为超级权限者的用户主目录。\n__/lib：__系统开机时需要最基本的动态连接共享库，类似于Windows的DLL文件。几乎所有的程序都要用到这些共享库。\n__/etc：__所有的系统管理所需要的配置文件和子目录。my.conf\n__/usr：__用户的很多程序和文件都存放在此目录下。类似于WIndows的Program Files目录。\n__/boot：__启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。\n__/proc：__是一个虚拟的目录，它是系统内存的映射，访问这个目录用来获取系统信息。\n__/srv：__service 的缩写，用于存放一些服务启动之后需要提取的数据。\n__/sys：__安装来了新出现的文件系统sysfs。\n__/tmp：__存放一些临时文件。\n__/dev：__类似于Windows的设备管理器，把所有硬件用文件的形式存储。\n__/media：__linux系统会自动识别一些设备，识别后把设别的设备挂载到这个目录下。\n__/mnt：__让用户临时挂载别的文件系统。\n__/opt：__存放额外的安装程序。\n__/usr/local：__给主机额外安装软件所安装的目录。\n__/var：__将经常被修改的目录放在这个目录下。包括各种日志文件。\n\n## 远程登录Linux-Xshell\n\n1.Linux需要打开sshd服务(_openssh的服务端：sshd_ ; _openssh的客户端：ssh_ )；\n\t\tsudo service ssh start\n\t\t若出现Unit ssh.service not found，则需要安装openssh服务：\n\t\tsudo apt-get install openssh-server\n\t\t2.打开Xshell，并新建会话，填入需要远程登录的主机的ip地址，保存会话；\n\t\t3.双击建立的会话，输入用户名以及密码，建立连接。\n\n## 远程上传/下载-Xftp\n\n1.打开Xftp,新建会话，填入需要远程登录的主机的ip地址以及密码，保存会话；\n\t\t2.双击会话，建立连接。\n\n## vi和vim编辑器\n\n__vi : __所有的linux系统都会内建 vi文本编辑器；\n\t\t__vim : __具有程序编辑功能的文本编辑器。\n\n### vi和vim的三种常见模式\n\n__1.正常模式：__\n\t\t以vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，可以使用『上下左右』按键\t\t来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、贴上』来处理\t\t你的文件数据。\n\t\t__2.插入模式:__\n\t\t按下i, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按i即可。\n\t\t__3.命令行模式:__\n\t\t在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开vim 、显示行号等的动作。\n_vim模式的三种转换：_\n\n![vim模式切换](linux-01/vim.png)\n\nwq : 保存退出\n\t\tq! : 强制退出不保存\n\n","tags":["Linux"],"categories":["Linux"]},{"title":"DQL,常见函数","url":"/2020/02/22/mysql-02/","content":"\n## 基础查询\n\n__语法：__\n\t\tselect 查询列表 from 表名<!--more-->\n__特点：__\n\t\t1.查询列表可以是：表中的字段，常量值，表达式，函数；\n\t\t2.查询的结果是一个虚拟的表格。<!--more-->\n\n```sql\n# 1.查询表中的单个字段\nSELECT first_name FROM employees;\n\n# 2.查询表中的多个字段\nSELECT first_name,last_name FROM employees;\n\n# 3.查询表中的所有字段\nSELECT  * from employees;\n\n# 4.查询常量值\nSELECT 'qwer';\nSELECT 666;\n\n# 5.查询表达式\nSELECT 1+2+3;\nSELECT 100%3;\n\n# 6.查询函数\nSELECT VERSION();\n\n# 7.起别名\n# 方式一：使用AS\nSELECT 9/2 AS 结果;\nSELECT first_name AS 名,last_name AS 姓 FROM employees;\n# 方式二：使用空格\nSELECT salary 薪水 FROM employees;\n\n# 8.去重:使用DISTINCT\nSELECT DISTINCT department_id FROM employees;\n\n# 9.+号的作用：只能作运算符\nSELECT '22'+33; -- 55\nSELECT 'qwer'+333; -- 333\nSELECT null+333; -- NULL\n# 字符串连接函数CONCAT(str1,str2,...)\nSELECT  CONCAT(last_name, first_name) AS 全名 FROM employees;\n\n# 10.使用IFNULL(expr,expr为null时需要返回的值)对结果为null的数据进行处理\nSELECT CONCAT(salary,',',IFNULL(commission_pct,0)) AS '月薪,年奖金率' FROM employees;\n# 11.ISNULL(expr) expr为null 返回0，否则返回1\n```\n\n## 条件查询\n\n__语法：__\n\t\tselect 查询列表 from 表名 where 筛选条件\n\t\t__分类：__\n\t\t1.按条件表达式进行筛选\n\t\t条件运算符：> < != <> >= <=\n\t\t2.按逻辑表达式\n\t\t&& || ! and or not \n\t\t3.模糊查询\n\t\t _like：_\n\t\t\t\t1.一般与通配符搭配使用\n\t\t\t\t2.通配符(使用\\转义)：\n\t\t\t\t\t %：表示0个或任意多个字符;\n\t\t\t\t\t _ ：表示任意单个字符;\n         _(not) between and：_ 包含边界值\n\t\t_in：_ 判断某字段的值是否属于in列表中的某一项\n\t\tin列表中的元素类型要相同或兼容\n\t\t*is null / is not null：*只能判断是否为null;\n\t\t<=> : 安全等于，既能判断是否为null也能判断数字;\n\t\t= 和 <>不能判断null\n\n```sql\n# 1.按条件表达式筛选\nSELECT * FROM employees WHERE salary>15000;\nSELECT last_name,first_name,salary FROM  employees WHERE department_id<>90;\n\n# 2.按逻辑表达式筛选\nSELECT last_name,salary,commission_pct FROM employees WHERE salary>=10000 and salary<=15000;\n# 查询部门编号不是在90到110之间，或者工资高于12000的员工的信息\nSELECT last_name,first_name,salary FROM employees WHERE NOT(department_id>=90 AND department_id<=110) OR salary>12000;\n\n# 3.模糊筛选\n# 查询员工名中包含字符a的员工信息\nSELECT * FROM employees WHERE first_name LIKE '%a%' ;\n# 查询员工名中第三个字符为a,第四个字符为n的员工信息\nSELECT * FROM employees WHERE first_name LIKE '__an%';\n# 查询员工编号在100~200之间的员工信息\nSELECT * FROM employees WHERE employee_id BETWEEN 100 AND 200;\n# 查询员工的工种编号是IT_PROG,IT_VP,AD_PRES中的一个员工的员工名和工种编号\nSELECT first_name,job_id FROM employees where job_id IN ('IT_PROG','IT_VP','AD_PRES');\n# 查询没有奖金的员工信息\nSELECT * FROM employees where commission_pct = NULL; -- 查询不到结果\nSELECT * FROM employees WHERE commission_pct IS NULL;\n```\n\n## 排序查询\n\n语法：select 查询列表 from 表 where 查询条件  order by 排序列表 asc/desc;\n特点：1.asc:升序；desc:降序；如果不写，默认为升序\n\t\t\t2.order by 子句支持单个字段，多个字段，表达式，函数，别名\n\t\t\t3.order by 子句一般放在查询语句的最后面，limit子句除外\n\n```sql\nSELECT * FROM employees ORDER BY salary ASC; -- 升序\nSELECT * FROM employees ORDER BY salary; -- 省略时默认为升序排列\nSELECT * FROM employees ORDER BY salary DESC; -- 降序\n# 查询部门编号>=90的员工信息，按入职时间的先后顺序进行排序\nSELECT *  FROM employees  WHERE department_id>=90 ORDER BY hiredate;\n# 按年薪的高低显示员工的信息和年薪（按表达式排序）\nSELECT * ,salary*12*(1+IFNULL(commission_pct,0)) FROM employees ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;\n# 按别名排序\nSELECT * ,salary*12*(1+IFNULL(commission_pct,0)) AS '年薪' FROM employees ORDER BY '年薪' DESC;\n# 按姓名的长度显示员工的姓名和工资（按函数值进行排序）\nSELECT CONCAT(last_name,first_name) AS '姓名' ,LENGTH(CONCAT(last_name,first_name)),salary AS '工资' FROM employees ORDER BY LENGTH(姓名);\n# 查询员工信息，要求先按工资的升序，再按员工编号的降序（按多个字段排序）\nSELECT * FROM employees ORDER BY salary ASC,employee_id DESC;\n```\n\n## 常见函数\n\n概念：类似于java中的方法，将一组逻辑语句封装在方法体中，对外暴露方法名\n好处：隐藏了实现细节；提高了代码的复用性\n调用：select 函数名() from 表名;\n分类： 1.单行函数：作用于单行数据，返回一个结果\n\t\t\t2.分组函数：作用于一组数据，并对一组数据返回一个值\n\n### 单行函数\n\n#### 一、字符函数\n\n```sql\n# 1.LENGTH(str) 获取参数值的字节个数\nSELECT LENGTH('哈哈hh'); -- 8\n\n# 2.CONCAT(str1,str2,...) 拼接字符串\n\n# 3.UPPER(str),LOWER(str)\nSELECT CONCAT(upper(last_name),' ',lower(first_name)) AS '姓名'FROM employees;\n\n# 4.SUBSTR(str FROM pos FOR len),substring()截取字符串(索引从1开始)\nSELECT SUBSTR(last_name,1,1) FROM employees;\n\n# 5.INSTR(str,substr) 返回子串在母串第一次出现的索引位置，如果找不到就返回0\nSELECT INSTR('helloworld','world'); -- 6\nSELECT INSTR('helloworld','word'); -- 0\n\n# 6.TRIM([remstr FROM] str) 去掉首尾空格或指定字符串\n# 7.LPAD(str,len,padstr) /RPAD(str,len,padstr)用指定的字符实现左/右填充指定长度\n# REPLACE(str,from_str,to_str) 替换\n```\n\n####  二、数学函数\n\n```sql\n# 1.ROUND(X) 四舍五入\nSELECT ROUND(-1.55); -- -2\nSELECT ROUND(-1.566,2); -- -1.57\n# 2.CEIL(X) 向上取整，返回>=该参数的最小整数\n# 3.FLOOR(X) 向下取整，返回<=该参数的最大整数\n# 4.TRUNCATE(X,D) 从小数点后D位截断\nSELECT TRUNCATE(1.29,1); -- 1.2\n# 5.MOD(N,M) 取余:符号与被除数相同\nSELECT MOD(-10,3); -- -1\nSELECT MOD(10,-3); -- 1\n```\n\n####  三、日期函数\n\n```sql\n# NOW() 返回当前系统日期+时间\nSELECT NOW(); -- 2020-02-23 11:27:48\n# CURDATE() 返回当前系统的日期\nSELECT CURDATE(); -- 2020-02-23\n# CURTIME() 返回当前系统的事件\nSELECT CURTIME(); -- 11:30:11\n\n# 获取指定的年，月，日，时，分，秒\nSELECT YEAR(NOW()) AS 年份;\nSELECT YEAR('1999-2-2'); -- 1999\nSELECT MONTH(NOW()) AS 月;\nSELECT MONTHNAME(NOW()); -- February\nSELECT DAY(NOW()) AS  日;\nSELECT HOUR(CURTIME()) AS 时; \nSELECT MIN(CURTIME()) AS 分;\n\n# STR_TO_DATE(str,format) 将字符通过指定的格式转换成日期\nSELECT STR_TO_DATE('1999-2-29','%Y-%c-%d'); -- 1999-02-29\nSELECT STR_TO_DATE('99-02-29','%y-%m-%d');\n\n#  DATE_FORMAT(date,format) 将日期转换成字符\nSELECT DATE_FORMAT(now(),'%Y年%m月%d日');-- 2020年02月23日\nSELECT DATE_FORMAT(now(),'%y年%c月%d日'); -- 20年2月23日\n# 查询有奖金的员工名和入职日期(xx月/xx日 xx年)\nSELECT last_name AS 姓名,DATE_FORMAT(hiredate,'%m月/%d日 %y年') AS 入职日期 FROM employees WHERE commission_pct IS NOT NULL;\n```\n\n#### 四、其他函数\n\n```sql\nSELECT VERSION();\nSELECT DATABASE();\nSELECT USER();\n```\n\n####  五、流程控制函数\n\n```sql\n# IF(expr1,expr2,expr3)\nSELECT IF(2>1,'true','false');\n\n# case 用法一：相当于java中的switch()\n/*\nCASE 要判断的字段或表达式\n\tWHEN 常量1 THEN\n\t\t要显示的值1(或语句1;)\n\tELSE\n\t\t要显示的值n(或语句n;)\n\tEND;\n*/\n/*查询员工工资，要求：\n部门号=30，显示工资为1.1倍；\n部门号=40，显示工资为1.2倍；\n部门号=50，显示工资为1.3倍；\n*/\nSELECT salary\tAS 原始工资,department_id AS 部门号,\nCASE department_id\n\tWHEN 30 THEN\n\t\tsalary *1.1\n\tWHEN 40 THEN\n\t\tsalary*1.2\n\tWHEN 50 THEN\n\t\tsalary*1.3\n\tELSE salary\nEND AS 最终工资 FROM employees;\n# case用法二：相当于java中if()  else if() else \n/*\nCASE \n\tWHEN 条件1 THEN\n\t\t要显示的值1(或语句1;)\n\tWHEN 条件2 THEN\n\t\t要显示的值2(或语句2;)\n\tELSE\n\t\t要显示的值n(或语句n;)\nEND CASE;\n*/\n/*查询员工的工资情况\n如果工资>20000,显示A级别；\n如果工资>15000,显示B级别；\n如果工资>10000,显示C级别；\n其余的显示D级别\n*/\nSELECT salary AS '工资',\nCASE \n\tWHEN salary>20000 THEN 'A'\n\tWHEN salary>15000 THEN 'B'\n\tWHEN salary>10000 THEN 'C'\n\tELSE 'D'\nEND AS '工资等级' FROM employees;\n```\n\n### 分组函数\n\n__作用：__用作统计使用，又称聚合函数，统计函数，组函数\n\t\t__特点：__\n\t\t1.sum，avg一般处理数值型数据；max，min，count可以处理任何类型\n\t\t2.以上分组函数都忽略null值\n\t\t3.可以和discount()搭配使用实现去重\n\t\t4.一般使用count(*)统计行数，没有记录返回0\n\t\t5.和分组函数一起查询的字段必须是group by后面的字段\n\n```sql\n# sum() 求和\nSELECT sum(salary) FROM employees;\n# avg() 求平均值\nSELECT AVG(salary) FROM employees;\n# max() 求最大值;min() 求最小值\nSELECT MAX(salary) FROM employees;\nSELECT MIN(salary) FROM employees;\n# count() 计算个数\nSELECT COUNT(employee_id) FROM employees;\nSELECT COUNT(*) FROM employees;\n\n# 查询员工表中最大入职时间和最小入职时间的相差天数\nSELECT DATEDIFF(MAX(hiredate),MIN(hiredate)) FROM employees;\n# 查询部门编号为60的员工个数\nSELECT COUNT(*) FROM employees WHERE department_id = 60;\n```\n\n## 分组查询\n\n__语法：__\n\t\tselect 分组函数,列(要求出现在group by的后面)\n\t\tfrom 表\n\t\twhere 筛选条件\n\t\tgroup by 分组的列表\n\t\torder by 子句\n\t\t特点：分组查询中的筛选条件分为两类\n\t\t\t分组前筛选：数据源在原始表中，位于group by子句前面，使用where关键字；\n\t\t\t分组后筛选：数据源在分组后的结果集中，位于group by子句后面，使用having关键字\n\t\t\t1.分组函数作条件肯定放在having后\n\t\t\t2.能分组前筛选尽量放在group by前面\n\n```sql\n# 查询每个工种的最高工资\nSELECT MAX(salary),job_id FROM employees GROUP BY job_id;\n# 查询每个位置上的部门个数\nSELECT COUNT(*),location_id FROM departments GROUP BY location_id;\n# 查询邮箱中包含a字符的，每个部门的平均工资\nSELECT AVG(salary),department_id FROM employees WHERE email LIKE \"%a%\" GROUP BY department_id;\n# 查询员工数>2的部门\nSELECT COUNT(*),department_id FROM employees GROUP BY department_id HAVING COUNT(*)>2;\n# 查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资\nSELECT MAX(salary),job_id FROM employees WHERE commission_pct IS NOT NULL HAVING MAX(salary)>12000;\n# 查询领导编号>102的每个领导手下的最低工资>5000的领导编号是哪一个，以及最低工资\nSELECT MIN(salary),manager_id FROM employees WHERE manager_id>102 GROUP BY manager_id HAVING MIN(salary)>5000 \n# 查询每个部门每个工种的员工的平均工资，并按平均工资的高低显示 \nSELECT AVG(salary),job_id,department_id FROM employees GROUP BY job_id,department_id ORDER BY AVG(salary) DESC;\n```\n\n## 连接查询\n\n```sql\n# 一、内连接\n/*\n语法：\nselect 查询列表\nfrom 表1 别名\ninner join 表2 别名\non 连接条件\n*/\n# 1.等值\n# 查询员工名、部门名\nSELECT last_name,department_name FROM departments d INNER JOIN employees e\nON d.department_id = e.department_id;\n# 查询名字中包含e的员工名和工种名\nSELECT last_name,job_title from employees e INNER JOIN jobs j\nON e.job_id= j.job_id where e.last_name LIKE \"%e%\";\n# 查询部门个数>3的城市名和部门个数\nSELECT city,COUNT(*) 部门个数 FROM locations l INNER JOIN departments d \nON l.location_id=d.location_id GROUP BY city HAVING COUNT(*)>3; \n# 查询哪个部门的部门员工个数>3的部门名和员工个数，并按个数降序排序\nSELECT department_name,COUNT(*) 部门员工个数 FROM departments d INNER JOIN employees e\nON d.department_id = e.department_id GROUP BY department_name HAVING COUNT(*)>3 ORDER BY COUNT(*) DESC;\n\n# 2.非等值\n# 查询员工的工资等级\nSELECT salary,grade_level FROM employees e JOIN job_grades j \nON salary BETWEEN j.lowest_sal AND j.highest_sal;\n\n#3.自连接\n# 查询员工名、上级的名字\nSELECT e.last_name,m.last_name FROM employees e JOIN employees m\nON e.manager_id = m.employee_id;\n```\n\n```sql\n# 二、外连接\n/*\n用于查询一个表中有，另一个表中没有的字段\n特点：\n1.外连接的查询结果为主表中的所有记录\n\t\t如果从表中有和它匹配的，则显示匹配的值\n\t\t否则显示null\n\t\t外连接的查询结果=内连接的结果+主表中有 而 从表中没有的记录\n2.左外连接，left [outer] join   左边的是主表\n  右外连接，right [outer] join  右边的是主表\n3.全外连接=内连接的结果+表1中有单表2中没有的+表2中有的而表1中没有的\n*/\n# 查询没有员工的部门信息\nSELECT d.* FROM departments d LEFT OUTER JOIN employees e\nON d.department_id=e.department_id WHERE employee_id IS NOT NULL;\n```\n\n## 子查询\n\n```sql\n# 子查询\n/*\n出现在其他语句内部的select语句，称为子查询\n*/\n# where或having后面\n# 查询工资比 Abel高的员工信息\nSELECT * FROM employees WHERE salary>(SELECT salary FROM employees WHERE last_name=\"Abel\");\n# 查询最低工资大于50号部门最低工资的部门id和其最低工资\nSELECT department_id,MIN(salary) FROM  employees GROUP BY department_id \nHAVING MIN(salary)>(SELECT MIN(salary) FROM employees WHERE department_id=50);\n# 查询location_id在1400或1700的部门中的所有员工的姓名\nSELECT last_name FROM employees WHERE department_id IN (SELECT department_id FROM\tdepartments  WHERE location_id IN (1400,1700));\n\n# select后面\n# 查询每个部门的人数\nSELECT d.*,(SELECT COUNT(*) FROM employees e WHERE e.department_id = d.department_id) 个数\nFROM departments d;\n\n# from后面\n# 查询每个部门的平均工资的等级\nSELECT ag_dep.*,g.grade_level FROM \n(SELECT AVG(salary) ag,department_id FROM employees GROUP BY department_id) ag_dep \nINNER JOIN job_grades g ON  ag_dep.ag BETWEEN lowest_sal AND highest_sal;\n# 子查询\n/*\n出现在其他语句内部的select语句，称为子查询\n*/\n# where或having后面\n# 查询工资比 Abel高的员工信息\nSELECT * FROM employees WHERE salary>(SELECT salary FROM employees WHERE last_name=\"Abel\");\n# 查询最低工资大于50号部门最低工资的部门id和其最低工资\nSELECT department_id,MIN(salary) FROM  employees GROUP BY department_id \nHAVING MIN(salary)>(SELECT MIN(salary) FROM employees WHERE department_id=50);\n# 查询location_id在1400或1700的部门中的所有员工的姓名\nSELECT last_name FROM employees WHERE department_id IN (SELECT department_id FROM\tdepartments  WHERE location_id IN (1400,1700));\n\n# select后面\n# 查询每个部门的人数\nSELECT d.*,(SELECT COUNT(*) FROM employees e WHERE e.department_id = d.department_id) 个数\nFROM departments d;\n\n# from后面\n# 查询每个部门的平均工资的等级\nSELECT ag_dep.*,g.grade_level FROM \n(SELECT AVG(salary) ag,department_id FROM employees GROUP BY department_id) ag_dep \nINNER JOIN job_grades g ON  ag_dep.ag BETWEEN lowest_sal AND highest_sal;\n```\n\n## 分页查询\n\n```sql\n# 分页查询\n/*\n分页提交sql请求\nselect 查询列表 from 表名 limit 起始索引(从0开始)，结果的数目\nlimit语句放在查询语句的最后 \n当前页 pageNum , 每页的条目数pageSize\nselect 查询列表 from 表名 limit (pageNum-1)*pageSize,pageSize;\n*/\n# 查询前5条员工信息\nSELECT * FROM employees LIMIT 0,5;\nSELECT * FROM\temployees\tLIMIT 5;\n# 查询第11条~第25条的信息\nSELECT * FROM employees LIMIT 11,15;\n# 查询有奖金的员工信息，并且工资较高的前10名显示出来\nSELECT * FROM employees WHERE\tcommission_pct IS NOT NULL ORDER BY salary\tDESC LIMIT 0,10;\n```\n\n## 联合查询\n\n将多条查询语句的结果合并在一起\n语法：\nselect 查询列表1 from 表名 union select 查询列表2 from 表名\n特点：\n1、要查询的结果来自多个表，且多个表之间没有联系\n2、要求查询列表1与查询列表2的列数相等\n3、要求多条查询语句的查询的每一列的类型和顺序最好一致\n4、union关键字默认去重，使用union all 可以包含重复项\n\n","tags":["MySQL"],"categories":["数据库"]},{"title":"MySQL概述","url":"/2020/02/20/mysql-01/","content":"\n## 数据库的好处\n\n1.实现数据是持久化\n2.可以实现结构化查询，方便管理<!--more-->\n\n## 数据库相关概念\n\n1.DB : 数据库，用于保存一组有组织的数据的容器；\n2.DBMS : 数据库管理系统，用于管理DB中的数据；\n3.SQL : 结构化查询语言，用来与数据库通信。\n\n## 数据库储存数据的特点\n\n1.将数据放到表中，表在放到库中；\n2.一个数据库有多张表，表名具有唯一性，用于表示自己；\n3.表中有一些特性，这些特性决定了数据在表中如何储存，类似于java中“类”的设计；\n4.表由列组成，也称为字段。所有表都是由一个或多个列组成，每一列类似于java类中\t\t\t的“属性”；\n5.表中的数据是按行储存的，每一行类似于java中的\"对象\"。\n\n## MySQL服务的启动和停止\n\n方式一：计算机---右击管理---服务\n方式二：通过管理员身份运行cmd\n启动服务 ：net start 服务名；\n停止服务：net stop 服务名。\n\n## MySQL服务的登录与退出\n\n方式一：通过mysql自带的客户端，只限于root客户\n方式二：通过window自带的客户端\n登录：mysql -h主机名 -P端口号 -u用户名 -p密码\n退出：exit 或 ctrl+c\n\n## MySQL常见命令\n\n1.查看当前所有的数据库：\n\n​\t\t\tshow databases;\n2.打开指定的数据库：\n​\t\t\tuse 库名;\n3.查看当前库的所有表：\n​\t\t\tshow tables;\n4.查看其他库的所有表：\n​\t\t\tshow tabkes from 库名;\n5.创建表：\n​\t\t\tcreate table(\n​\t\t\t列名 列类型,\n​\t\t\t列名 列类型,\n​\t\t\t.......\n​\t\t\t)；\n6.查看表结构：\n​\t\tdesc 表名;\n7.查看服务器版本：\n​\t\t方式一：登录到mysql服务端：\n​\t\tselect version();\n​\t\t方式二：没有登录\n​\t\tmysql --version 或 mysql -V     \n\n## MySQL语法规范\n\n1.不区分大小写，但建议关键字大写，表名、列名小写；\n2.每条命令最好用  分号结尾；\n3.每条命令可根据需要进行缩进或换行；\n4.单行注释：# 注释文字 或 -- 注释文字\n   多行注释：```/*注释文字*/```\n\n## 数据库三范式\n\n第一范式：列不可分\n第二范式：要有主键\n第三范式：不可存在传递依赖\n比如商品表里面关联商品类别表，那么只需要一个关联字段product_type_id即可，其他字段信息可以通过表关联查询即可得到\n**如果商品表还存在一个商品类别名称字段，如product_type_name，那就属于存在传递依赖的情况，第三范式主要是从空间的角度来考虑，避免产生冗余信息，浪费磁盘空间**。\n\n","tags":["MySQL"],"categories":["数据库"]},{"title":"多线程","url":"/2020/02/17/java-04/","content":"\n## 程序、进程、线程的概念\n\n<img src=\"java-04/program,process,thread.png\" style=\"zoom:70%;\" />\n并行：多个CPU同时执行多个任务。\n并发：一个CPU(采用时间片)”同时“执行多个任务。<!--more-->\n\n## 线程的创建和使用\n\n__创建方式一：继承Thread类__\n\n```java\n// 1.创建一个继承于Thread类的子类\nclass MyThread extends Thread{\n    // 2.重写Thread类的run()方法->将此线程执行的操作声明在run()中\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            if(i%2==0){\n                System.out.println(i);\n            }\n        }\n    }\n}\n\npublic class ThreadTest1 {\n    public static void main(String[] args) {\n        // 3.在主线程中创建Thread类的子类的对象\n        MyThread t1 = new MyThread();\n        // 4.通过此对象调用start()方法：<1>启动当前线程;<2>调用当前线程的run()\n        t1.start();\n        // 以下操作在主线程中执行\n        for (int i = 0; i < 1000; i++) {\n            if(i%2!=0){\n                System.out.println(i);\n            }\n        }\n    }\n}\n```\n\n子线程的创建和启动过程：\n![子线程的创建和启动过程](java-04/thread1.png)\n\n__创建方式二：实现Runnable接口__\n\n```java\n// 1.创建子类实现Runnable接口\nclass MyThread2 implements Runnable{\n    // 2.实现Runnable接口中的run()方法\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(Thread.currentThread().getName()+i);\n        }\n    }\n}\npublic class ThreadTest2 {\n    public static void main(String[] args) {\n        // 3.创建Runnable实现类的对象\n        MyThread2 mThread = new MyThread2();\n        // 4.将此对象作为参数传入Thread类的构造器中，创建Thread()类对象\n        Thread t2 = new Thread(mThread);\n        // 5.通过Thread类对象调用start()方法\n        t2.start();\n\n        // 再启动一个线程 不需要再造实现类对象\n        Thread t3 = new Thread(mThread);\n        t3.start();\n    }\n}\n```\n\n__两种创建方式的比较：__\n\t\t开发中：优先选择实现Runnable接口的方式。\n\t\t原因 ：1.没有类的单继承性的局限性；2.更适合处理多个线程有共享数据的情况。\n\t\t相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中；启动线程都是调用Thread类中的start()方法\n\n## Thread类中常用方法\n\n__void start()：__ 启动线程，并执行对象的run()方法\n__void run()：__线程在被调度时执行的操作\n__String getName()：__ 返回线程的名称\n__void setName(String name)：__设置该线程名称\n__static Thread currentThread()：__ 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类\n__static void yield()：__线程让步\n       <1> 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程\n       <2> 若队列中没有同优先级的线程，忽略此方法\n__join()：__在线程a中调用线程b的 join() 方法时，线程a将被阻塞，直到线程b执行完为止 ;低优先级的线程也可以获得执行。底层调用wait()，会释放锁。\n__static void sleep(long millis)：__(指定时间:毫秒)\n<1> 令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队\n<2> 抛出InterruptedException异常\n__stop()：__强制线程生命期结束，不推荐使用\n__boolean isAlive()：__返回boolean，判断线程是否还活着\n\n## 线程的调度\n\n__调度的策略：__时间片；抢占式。\n\t    __Java的调度方法：__\n\t\t<1> 同优先级线程组成先进先出队列(先到先服务)，使用时间片策略；\n\t\t<2> 对高优先级，使用抢占式策略，高优先级的线程抢占CPU.\n\t\t__线程的优先级等级：__\n\t\tMAX_PRIORITY : 10\n\t\tMIN_PRIORITY : 1\n\t\tNORM_PRIORITY : 5\n\t\t__涉及的方法：__\n\t\tgetPriority() : 返回线程优先级；\n\t\tsetPriority(int newPriority) : 重新设置线程的优先级。\n\t\t**说明：** \n\t\t线程创建时继承父线程的优先级；\n\t\t低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用\n\n##  线程的生命周期\n\n\n![线程生命周期](java-04/threadLift.png)\n\n## 线程的同步\n\n多个线程执行的不确定性会引起结果的不稳定性；\n多个线程对数据的共享，会造成操作的不完整性。\n__方式一：同步代码块__\n\n```java\nsynchronized(/*同步监视器*/){\n    // 需要同步的代码\n}\n```\n\n需要同步的代码：操作共享数据(多个线程共同操作的变量)的代码。\n同步监视器：俗称：锁。任何一个类的对象都可以充当锁。\n要求：多个线程必须要共用同一把锁。\n\n```java\n**\n * @author zyz\n * @description 测试三个窗口同时卖票，采用同步代码块解决线程安全问题\n * @create 2020-02-22 13:57\n */\npublic class TicketTest1 {\n    public static void main(String[] args) {\n        Ticket t = new Ticket();\n\n        Thread t1 = new Thread(t);\n        t1.setName(\"窗口1\");\n        Thread t2 = new Thread(t);\n        t2.setName(\"窗口2\");\n        Thread t3 = new Thread(t);\n        t3.setName(\"窗口3\");\n        \n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n\nclass Ticket implements Runnable {\n    private int ticketNum = 100;// 采用实现Runnable接口方式实现多线程，共享变量无需声明为static\n    Object obj = new Object();// 保证多个线程共用一把锁\n    @Override\n    public void run() {\n        while(true){\n            synchronized(obj){\n                if(ticketNum>0){\n                    System.out.println(Thread.currentThread().getName()+\" 票号：\"+ticketNum);\n                    ticketNum--;\n                }\n                else{\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n\n__方式二：同步方法__\n\t\t1.不需要显式声明同步监视器；\n\t\t2.非静态的同步方法：同步监视器是this;===>对象锁\n\t\t\t静态的同步方法：同步监视器是当前类。===>类锁\n\n```java\npackage multithread;\n\n/**\n * @author zyz\n * @description 采用同步方法解决线程安全问题\n * @create 2020-02-22 16:08\n */\npublic class TicketTest2 {\n    public static void main(String[] args) {\n        Ticket1 t1 = new Ticket1();\n\n        Thread t4 = new Thread(t1);\n        t4.setName(\"窗口1\");\n        Thread t5 = new Thread(t1);\n        t5.setName(\"窗口2\");\n        Thread t6 = new Thread(t1);\n        t6.setName(\"窗口3\");\n\n        t4.start();\n        t5.start();\n        t6.start();\n    }\n}\n\nclass Ticket1 implements Runnable {\n    private int ticketNum = 100;// 采用实现Runnable接口方式实现多线程，共享变量无需声明为static\n    @Override\n    public void run() {\n        while(true){\n            threadRun();\n        }\n    }\n\n    // 将可能出现线程安全问题的代码块封装成一个同步方法\n    private synchronized void threadRun(){ // 采用继承Thread类实现多线程时，需要将此方法声明为static\n            if(ticketNum>0){\n                System.out.println(Thread.currentThread().getName()+\" 票号：\"+ticketNum);\n                ticketNum--;\n            }\n    }\n}\n\n```\n\n__死锁：__不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。\n出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。\n__方式三：Lock__\n\t\t通过显式定义同步锁对象，即Lock对象，来实现同步。\n\t\tReentrantLock类实现了Lock，以及创建锁的lock()方法，释放锁的unlock()方法。\n\n```java\nimport java.util.concurrent.locks.ReentrantLock;\n/**\n * @author zyz\n * @description 采用Lock解决线程安全问题\n * @create 2020-02-23 14:36\n */\npublic class TicketTest3 {\n    public static void main(String[] args) {\n        Ticket2 t = new Ticket2();\n\n        Thread th1 = new Thread(t);\n        th1.setName(\"线程1：\");\n        Thread th2 = new Thread(t);\n        th2.setName(\"线程2：\");\n        Thread th3 = new Thread(t);\n        th3.setName(\"线程3：\");\n\n        th1.start();\n        th2.start();\n        th3.start();\n    }\n}\nclass Ticket2 implements Runnable{\n    private int ticketNum = 100;\n    // 1.实例化ReentrantLock\n    ReentrantLock lock = new ReentrantLock();\n    @Override\n    public void run() {\n        while(true){\n            try{\n                // 2.调用锁定方法lock()\n                lock.lock();\n                if(ticketNum>0){\n                    System.out.println(Thread.currentThread().getName()+ticketNum);\n                    ticketNum--;\n                }\n                else{\n                    break;\n                }\n            }finally{\n                // 3.调用解锁方法unlock()\n                lock.unlock();\n            }\n        }\n    }\n}\n```\n\n_synchronized 与  Lock 的不同点：_\n1.synchronized机制再执行完相应的同步代码后，自动释放同步监视器；\n\tLock需要手动的启动同步(lock())，同时也需要手动的结束同步(unlock())。\n2.Lock只有代码块锁，synchronized有代码块锁和方法锁\t\t\n3.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）\n__优先使用顺序：__\nLock > 同步代码块（已经进入了方法体，分配了相应资源）>同步方法（在方法体之外）\n\n## 线程的通信\n\n__wait()：__一旦线程执行此方法，当前线程就会进入阻塞状态，并释放同步监视器(锁)。\n__notify()：__一旦执行此方法就会唤醒被wait的一个线程。若有多个线程被wait，则唤醒优先级高的。\n__notifyAll()：__唤醒所有被wait的线程。\n\t\t_三个方法必须使用在同步代码块或同步方法中。\n\t\t三个方法的调用者必须是同步代码块或是同步代码块中的同步监视器。\n\t\t三个方法定义在Object类中。_\n\n```java\n/**\n * @author zyz\n * @description 使用两个线程打印1-100。线程1, 线程2 交替打印\n * @create 2020-02-23 17:30\n */\npublic class ThreadCommunicate {\n    public static void main(String[] args) {\n        Number n = new Number();\n\n        Thread th1 = new Thread(n);\n        th1.setName(\"线程1：\");\n        Thread th2 = new Thread(n);\n        th2.setName(\"线程2：\");\n        th1.start();\n        th2.start();\n    }\n}\n\nclass Number implements Runnable {\n    private int num = 1;\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (this) {\n                notify();// 唤醒线程\n                if (num <= 100) {\n                    System.out.println(Thread.currentThread().getName() + num);\n                    num++;\n                    // 线程执行完后就阻塞\n                    try {\n                        wait();// 执行完wait()后释放锁\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n\n_sleep()与wait()的异同点：_\n1.相同点：一旦执行后。线程都会进入阻塞状态\n2.不同点：\n<1>声明的位置不同：sleep()声明在Thread类中，wait()声明在Object类中； \n<2>调用要求不同，wait()只能在同步代码块或同步方法中使用；\n<3>sleep()不会释放锁。\n\n1.锁池（就绪队列）\n所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列进行等待cpu资源分配。\n2.等待池（等待队列）\n当我们调用`wait()`方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了`notify()`或`notifyAll()`后等待池的线程才会开始去竞争锁，`notify()`是随机从等待池选出一个线程放到锁池，而`notifyAll()`是将等待池的所有线程放到锁池当中。\n\n##  JDK5.0新增的线程创建方式\n\n__方式三：实现Callable接口__\n\n使用此方式与前面实现多线程的方式的不同之处在于，可以更方便的获取返回值，前面的方式只能通过共享变量的方式实现值传递。\n\n```java\n/**\n * @author zyz\n * @description 线程创建方式三\n * @create 2020-02-26 14:11\n */\npublic class ThreadTest3  {\n    public static void main(String[] args) {\n        // 创建子线程1\n        // 创建Callable实现类的对象\n        MyThread3 t = new MyThread3();\n        // 实例化FutureTask类，将Callable实现类的对象作为参数传入\n        FutureTask futureTask = new FutureTask(t);\n        FutureTask futureTask1 = new FutureTask(t);\n\n        // Thread(Runnable target)需要传入一个Runnable实现类的对象\n        // 而FutureTask类不仅实现了Future接口，同时也实现了Runnable接口\n        // 因此可将FutureTask类的对象作为参数传入\n        Thread th3 = new Thread(futureTask);\n        th3.setName(\"子线程1：\");\n        th3.start();\n\n        // get()返回Callable实现类的对象重写的call()的返回值\n        try {\n            Object threadName = futureTask.get();\n            System.out.println(threadName);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n        // 创建子线程2\n        Thread th4 = new Thread(futureTask1);\n        th4.setName(\"子线程2：\");\n        th4.start();     \n    }\n}\nclass MyThread3 implements Callable{\n    @Override\n    public Object call() throws Exception {\n        for(int i = 0; i < 100; i++) {\n            System.out.println(Thread.currentThread().getName()+i);\n        }\n        return Thread.currentThread().getName();\n    }\n}\n```\n\n__方式四：使用线程池__\n好处：\n1.提高响应速度(减少了创建新线程的时间)\n2.降低资源消耗(重复利用线程池中的线程，不需要每次都创建)\n3.便于线程管理：\ncorePoolSize：核心池的大小\nmaxinumPoolSize：最大线程数\nkeepAliveTime：线程没有任务是最多保持多长时间后会终止\n\n```java\n/**\n * @author zyz\n * @description 线程的创建方式四\n * @create 2020-02-26 16:03\n */\npublic class ThreadTest4 {\n    public static void main(String[] args) {\n        // 创建线程池 提供指定线程数量\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        // 创建线程并开始线程\n        service.submit(new MyThread4());\n        service.execute(new MyThread4());\n        // 关闭连接池\n        service.shutdown();\n    }\n}\nclass MyThread4 implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(Thread.currentThread().getName()+\":\"+i);\n        }\n    }\n}\n```\n\n\n\n ","tags":["JavaSE"],"categories":["JavaSE"]},{"title":"异常处理","url":"/2020/02/11/java-03/","content":"\n## 异常概述与异常体系结构\n\n**Throwable：**所有异常都继承于Throwable，分为Exception和Error。\n__Error：__Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。\n比如 ：StackOverflowError栈内存溢出和OutOfMemory堆内存溢出。一般不编写针对性的代码进行处理。\n__Exception:__ 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。<!--more-->\n例如：空指针访问，试图读取不存在的文件，网络连接中断，数组角标越界。\n异常分类：\n编译时异常，CheckException及它的子类，例如IOException，FileNotFoundexception,SQLException等；\n运行时异常，RuntimeException类及它的子类，例如NullPointerException，ClassCastException，IndexOutOfBoundException等。\n![](java-03/1.jpg)\n\n## 异常处理机制一\n\n异常的处理：抓抛模型\n__抛出异常：__程序在正常执行的过程中，如果出现异常，就会生成一个异常类的对象，并将此对象提交给java运行时系统。\n__捕获异常：__如果一个方法抛出异常，该异常就会抛出给调用者方法中处理。如果异常没有在调用者方法中处理，继续抛给上层方法，直到<font color= red>异常被处理</font>。\n\n```\ntry{\n    // 可能出现异常的代码    \n}catch(异常类型1 变量名1){\n    // 处理异常的方式1\n}catch(异常类型2 变量名2){\n    // 处理异常的方式2\n}\n...\nfinally{\n    // 不论在try代码块中是否发生了异常事件，catch语句是否执行，是否有异常，是否有return，\n    // finally块中的语句都会被执行。\n}            \n```\n\n( I ) try 代码块：监视代码执行过程 \n\n旦发现异常则直接跳转至 catch ，如果没有 catch ，则直接跳转至 finally\n\n( 2 ) catch 代码块：可选执行的代码块，如果没有任何异常发生则不会执行，如果发现异常则进行处理或向上抛出。这一切都在 catch 代码块中执行。\n\n( 3 ) finally 代码块：必选执行的代码块，不 管是否有异常产 生，即使发生OOM也会执行，通常用于处理善后清理工作。如果 finally 代码块没有执行，那么有三种可能：\n\n- 没有进入try 代码块。\n\n- 进入try代码块，但是代码运行中出现了死循环或死锁状态。\n\n- 进入 try 代码块，但是执行了` System.exit()`操作。\n\n> 注意， finally 是在 return 表达式运行后执行的，此时将要return 的结果已经被暂存起来，finally 代码块执行结束后再将**之前暂存的结果**返回。\n> ```java\n> public static int finallyNotWork () { \n> int temp = 10000 ; \n> try { \n> \tthrow new Exception (); \n> } catch (Exception e ) { \n> \treturn ++temp ;\n> }finally{\n>    \ttemp = 99999;\n> }\n> ```\n> 此方法的结果返回10001，而不是99999！\n> 不要在finally 代码块中使用 return 语句，否则会覆盖掉 try 或 catch 代码块中return的结果。\n\n\n## 异常处理机制二\n\nthrows + 异常类型\n1.写在**方法的声明处**，指明可能抛出的异常类型。一旦方法体执行出现异常时，就会将生成的异常类对象抛给调用者。异常代码后续的代码不再执行。\n2.只是将异常抛给了调用者，并<font color=red>没有将异常处理掉</font>。\n\n## 手动抛出异常\n\nthrow + new Exception(\"提示信息\")，必须在方法声明时用throws出指明可能抛出的异常。\nthrow : 生成一个异常对象。声明在方法体内。\nthrows : 处理异常。声明在方法的声明处。\n\n## 用户自定义异常类\n\n```java\n/**\n * @Description 用户自定义异常类MyException，用于描述数据取值范围错误信息。\n *              用户自己的异常类必须继承现有的异常类。 \n * @author sweetboyZhang\n * @date 2020年2月13日下午3:15:59\n */\npublic class MyException extends Exception {\n\t\n\tstatic final long serialVersionUID = -703489719074899L;// 序列号\n\tprivate int id;// 异常种类\n\tpublic MyException() {\n\t\t\n\t}\n\t\n\tpublic MyException(String msg,int id) {\n\t\tsuper(msg);\n\t\tthis.id = id;\n\t}\n\t\n\tpublic int getId() {\n\t\treturn this.id;\n\t}\n}\n\npublic class MyExceptionTest {\n\tpublic void regist(int num)throws MyException{\n\t\tif(num < 0) {\n\t\t\tthrow new MyException(\"人为负数，不合理\",1);\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"登记人数：\"+num);\n\t\t}\n\t}\n\t\n\tpublic void manager() {\n\t\ttry {\n\t\t\tregist(-100);\n\t\t}catch(MyException e) {\n\t\t\tSystem.out.println(\"登记错误，出错种类：\"+e.getId());\n\t\t}\n\t\tSystem.out.println(\"本次登记操作结束\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMyExceptionTest my1 = new MyExceptionTest();\n\t\tmy1.manager();\n\t}\n}\n```\n","tags":["JavaSE"],"categories":["JavaSE"]},{"title":"面向对象","url":"/2020/01/18/java-02/","content":"\n# Java面向对象学习的三条主线：\n\n1.Java类的成员：属性、方法、构造器；代码块，内部类\n2.面向对象的三大特征：封装性、继承性、多态性、（抽象性）\n3.关键字：this , super , static , final , abstract , interface , package , import<!--more-->\n类：抽象的，概念上的内容。\n对象：实实在在的个体。\n对象是由类派生出来的，是类的实例化。\n\n```java\n/**\n * @Description \n * 一、设计类，其实就是设计类的成员\n * \t属性 = 成员变量 = field = 域、字段\n * \t方法 = 成员方法 = 函数 = method\n * \t创建类的对象 = 类的实例化 = 实例化对象\n * \n * 二、类和对象的使用（面向对象思想落地的实现）\n * \t1、创建类，设计类的成员\n * \t2、创建类的对象\n * \t3、通过\"对象.属性\"或\"对象.方法\"调用对象的结构\n * \n * 三、如果创建一个类的多个对象，则每个类都独立的拥有一套类的属性。（非static）\n * \t修改一个对象的属性a，则不影响另外一个对象的属性a的值\n * @author sweetboyZhang\n * @date 2020年1月18日下午2:12:14\n */\npublic class PersonTest {\n\tpublic static void main(String[] args) {\n\t\t// 对象实例化，创建Person对象\n\t\tPerson p1 = new Person();\n\t\t\n\t\t// 调用对象的结构：属性、方法\n\t\t// 调用属性：\"对象.属性\"\n\t\tp1.name = \"Taylor\";\n\t\tp1.isMale = false;\n\t\tSystem.out.println(p1.name);\n\t\t// 调用方法：\"对象.方法\"\n\t\tp1.eat();\n\t\tp1.sleep();\n\t\tp1.study(\"Java\");\n\t\t\n\t\t// 创建另外一个对象\n\t\tPerson p2 = new Person();\n\t\tp2.name = \"Tony\";\n\t\tSystem.out.println(\"p2.name: \" + p2.name);// p2.name: Tony\n\t\tSystem.out.println(\"p1.name: \" + p1.name);// p1.name: Taylor\n\t}\t\n}\nclass Person{\n\t\t// 属性\n\t\tString name;\n\t\tint age = 1;\n\t\tboolean isMale;\n\t\t\n\t\t// 方法\n\t\tpublic void eat() {\n\t\t\tSystem.out.println(\"吃饭\");\n\t\t}\n\t\t\n\t\tpublic void sleep() {\n\t\t\tSystem.out.println(\"睡觉\");\n\t\t}\n\t\t\n\t\tpublic void study(String language) {\n\t\t\tSystem.out.println(\"学习\" + language);\n\t\t}\n\t\t\n\t}\n```\n\n![对象的内存解析](java-02/oop_1.png)\n\n## 属性（成员变量）与局部变量\n\n__相同点：__\n\t\t\t1.定义变量的格式：数据类型 变量名 = 变量值\n\t\t\t2.先声明，后使用\n\t\t\t3.变量都有其对应的作用域\t\n__不同点:__\n1.声明的位置不同\n\t\t属性：直接定义在类的一对{}内\n\t\t局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量\n2.权限修饰符不同\n\t\t属性：声明时可以使用权限修饰符指明其权限\n\t\t           常见的权限修饰符：private , protected , public ,缺省\n \t\t局部变量：不可使用权限修饰符\n3.默认初始化值不同\n\t\t属性：类的属性根据其类型都**有默认的初始化值**\n\t\t\t      *基本数据类型：*\n\t\t\t\t\t\t整型（byte , short , int , long）: 0\n\t\t\t\t\t\t浮点型（float , double）: 0.0\n\t\t\t\t\t\t字符型（char）: 0（或'\\u0000'）\n\t\t\t\t\t\t布尔型（boolean）: false\n\t\t\t\t  *引用数据类型（类、数组、接口）：*null\n\t\t局部变量：没有初始化值，**<font color=red>调用局部变量之前必须进行初始化</font>**\n**类中实例变量可以不用初始化，使用相应类型的默认值即可；方法中的定义的局部变量必须初始化，否则编译不通过**。\n\n4.在内存中加载的位置不同\n\t\t属性：加载到堆空间中（非static）\n\t\t局部变量：加载到栈空间中\n__属性赋值顺序__：1.默认初始化\n\t\t\t\t\t\t   2.显式初始化/代码块中赋值\n\t\t\t\t\t\t   3.构造器初始化\n\t\t\t\t\t\t   4.通过“对象.方法”或“对象.属性“初始化\n__JavaBean:__ 符合下列标准的Java类：类是公共的，一个无参的构造器，属性以及对应的get,set方法\n\n## 方法\n\n\n__方法的声明：__\n\n```java\n权限修饰符 返回值类型 方法名(参数列表){\n\t方法体\n}\n```\n\n__方法的使用__：可以调用当前类的属性和方法 ，方法中不可以定义方法\n__方法的封装：__\n\n```java\n/**\n * @Description \n * 定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩\nscore(int)。 创建20个学生对象，学号为1到20，年级(1~6)和成绩(0~100)都由随机数确定。\n问题一：打印出3年级(state值为3）的学生信息。\n问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息\n提示：\n1) 生成随机数：Math.random()，返回值类型double; \n2) 四舍五入取整：Math.round(double d)，返回值类型long。\n * @author sweetboyZhang\n * @date 2020年1月20日下午3:40:47\n */\npublic class StudentTest {\n\tpublic static void main(String[] args) {\n\t\t// 创建StudentTest对象，用来调用封装好的方法\n\t\tStudentTest test = new StudentTest();\n\t\t// 创建并初始化对象数组\n\t\tStudent[] stuArr = test.bulidStuArr(20);\n\t\t// 遍历输出\n\t\ttest.print(stuArr);\n\t\tSystem.out.println(\"*****************************\");\n\t\t// 找出年级为3的学生\n\t\ttest.searchState(stuArr, 3);\n\t\tSystem.out.println(\"****************************\");\n\t\t// 使用冒泡排序按学生成绩排序，并遍历所有学生信息\n\t\ttest.bubleSort(stuArr);\n\t\ttest.print(stuArr);\n\t}\n\t\n\t/**\n\t * \n\t * @Description 创建并初始化对象数组\n\t * @author sweetboyZhang\n\t * @date 2020年1月20日下午5:15:19\n\t * @param num\n\t */\n\tpublic Student[] bulidStuArr(int num) {\n\t\tStudent[] stuArr = new Student[num];// 创建对象数组\n\t\tfor(int i = 0;i < num;i++) {\n\t\t\tstuArr[i] = new Student();// 给数组元素赋值\n\t\t\t// 给Student对象的属性赋值\n\t\t\tstuArr[i].number = i + 1;\n\t\t\tstuArr[i].state = (int)(Math.random()*(6-1+1)+1);// Math.random()*(b-a+1)+a\n\t\t\tstuArr[i].score = (int)(Math.random()*(100-0+1));\n\t\t}\n\t\treturn stuArr;\n\t}\n\t/**\n\t * \n\t * @Description 遍历并输出数组\n\t * @author sweetboyZhang\n\t * @date 2020年1月20日下午5:03:40\n\t * @param stuArr\n\t */\n\tpublic void print(Student[] stuArr) {\n\t\tfor(int i = 0;i < stuArr.length;i++) {\n\t\t\tSystem.out.println(stuArr[i].display());\n\t\t}\n\t}\n\t\n\t/**\n\t * \n\t * @Description 根据年级查找学生\n\t * @author sweetboyZhang\n\t * @date 2020年1月20日下午4:58:45\n\t * @param stuArr\n\t * @param state\n\t */\n\tpublic void searchState(Student[] stuArr,int state){\n\t\t// 遍历学生数组  打印出3年级(state值为3）的学生信息。\n\t\tfor(int i = 0;i < stuArr.length;i++) {\n\t\t\tif(stuArr[i].state == state) {\n\t\t\t\tSystem.out.println(stuArr[i].display());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * \n\t * @Description 使用冒泡排序按学生成绩排序\n\t * @author sweetboyZhang\n\t * @date 2020年1月20日下午5:02:08\n\t * @param stuArr\n\t */\n\tpublic void bubleSort(Student[] stuArr) {\n\t\tfor(int i = 0;i < stuArr.length-1;i++){\n\t\t\tfor(int j = 0;j < stuArr.length - 1 - i;j++) {\n\t\t\t\tif(stuArr[j].score > stuArr[j+1].score) {\n\t\t\t\t\tStudent temp = stuArr[j];\n\t\t\t\t\tstuArr[j] = stuArr[j+1];\n\t\t\t\t\tstuArr[j+1] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t}\n}\n\nclass Student{\n\t// 学号number(int)，年级state(int)，成绩score(int)\n\tint number;\n\tint state;\n\tint score;\n\t\n\tpublic String display() {\n\t\treturn \"学号：\" + number + \" 年级：\" + state + \" 成绩：\" + score;\n\t}\n}\n```\n\n\n![对象数组内存解析](java-02/oop_2.png)\n\n``` java\nstus[0] = new Student();\n// 引用类型变量stus[0],stus[1],stus[2]...只能存储null 或地址值 ,不能存储对象的属性。必须new一个对象用来存放该对象的属性，且这个引用类型的变量存放着指向该对象的首地址值。\n```\n```java\n// 匿名对象：创建的一个对象没有显式地赋给一个变量。只能调用一次。\nnew Student().display();\n```\n\n__方法的重载：__在同一个类中，允许存在一个以上的同名方法，只需参数个数或参数类型不同即可\n   \t __可变个数的形参：__方法名(参数的类型名 ... 参数名)\n\t\t__方法参数的值传递机制：__\n\t\t\t\t形参：方法定义时，声明在小括号中的参数\n\t\t\t\t实参：方法调用时，实际传递给形参的数据\n\t\t__方法参数传递的方式：__<font color = \"red\">值传递</font>。即将实际参数值的副本(复制品)传入方法内，而参数本身不受影响。\n\t\t\t\t形参是基本数据类型：将实参基本数据类型变量的“__数据值__”传递给形参\n\t\t\t\t形参是引用数据类型：将实参引用数据类型变量的“__地址值__”传递给形参（含变量的数据类型）\n\n``` java\n/**\n * @Description 基本数据类型的参数传递测试\n * @author sweetboyZhang\n * @date 2020年1月21日下午6:42:36\n */\npublic class CanshuTest {\n\tpublic static void main(String[] args) {\n\t\tint x = 1;\n\t\tSystem.out.println(\"修改前：x = \" + x);// 1\n\t\tchange(x);// 在栈空间中的change()中对变量的值进行了修改，调用完成后change()中的变量出栈，并没有影响到主函数中的变量的值\n\t\tSystem.out.println(\"修改后：x = \" + x);// 1\n\t}\n\t// 声明为静态方法，便于主类直接调用，无需实例化对象\n\tpublic static void change(int x) {\n\t\tSystem.out.println(\"调用方法前：x = \" + x);// 1\n\t\tx = 2;\n\t\tSystem.out.println(\"调用方法后：x = \" + x);// 2\n\t}\n}\n```\n\n```java\n/**\n * @Description 引用类型参数传递测试\n * @author sweetboyZhang\n * @date 2020年1月21日下午7:11:18\n */\npublic class CanshuTest1 {\n\tpublic static void main(String[] args) {\n\t\tPerson1 obj = new Person1();\n\t\tobj.age = 1;\n\t\tSystem.out.println(\"修改前：age = \" + obj.age);// 1\n\t\tchange(obj);// obj指向的在堆空间中的对象的值被修改，影响了最终结果\n\t\tSystem.out.println(\"修改后：age = \" + obj.age);// 2\n\t}\n    // 将实参中存储的地址值传递给形参，形参和实参指向堆空间中的同一个对象\n\tpublic static void change(Person1 obj) {\n\t\tSystem.out.println(\"调用方法前：age = \" + obj.age);// 1\n\t\tobj.age = 2;\n\t\tSystem.out.println(\"调用方法后：age = \" + obj.age);// 2\n\t}\n}\n\nclass Person1{\n\tint age;\n}\n```\n\n## 封装性\n\n__封装性的体现：__\n\t\t1.将类的属性私有化(private)，提供公共的(public)方法来获取(get)和设置(set)属性值\n\t\t2.不对外暴露的私有方法\n\t\t3.单例模式\n\t\t封装性的体现，需要权限修饰符的配合\n\t\tJava中的4种权限修饰符（从小到大）：private , 缺省 ，protected , public\n![权限修饰符的访问权限](java-02/oop_3.png)\n\n4种权限均可以用来修饰类的内部结构：属性(成员变量)，方法，构造器，内部类\n\t\t修饰外部类：缺省，public\t\t\n\t\t局部内部类，局部变量：不能被权限修饰符修饰\n\n1.一个java文件里，public 的类只能出现一个，只能出现一个，只能出现一个，否则，不管你用哪一个类名命名文件名编译器都会报错\n\n2.关于多态。子类继承了父类的所有成员，包括private权限的成员变量，但是继承的子类具有私有变量的拥有权但是没有使用权。\n\n3.private的成员变量，根据权限修饰符的访问控制范围，只有在类内部才能被访问，就算是他的子类，也不能访问。\n\n## 构造器（构造方法）\n\n作用：创建对象 new + 构造器\n\t\t1.若没有显示的定义类的构造器，则系统默认提供一个空参的构造器。\n\t\t2.定义构造器的格式：\n```java\n权限修饰符 类名(形参列表){\n    \n}\n```\n3.一个类中可以定义多个构造器，彼此构成重载\n\n<font color=\"red\">**4.构造函数不能被继承，只能被显式或隐式的调用**</font>\n\n##  this\n\n1.this可修饰或调用：属性，方法，构造器。\n2.this修饰属性和方法：this表示当前对象。\n在类的方法中，使用“ this.属性 ” 或 “ this.方法 ”  ，调用当前对象的属性或方法，通常可以省略。\n方法的形参与类的属性重名时必须使用” this.变量 “显式调用。\n3.this调用构造器：\n在构造器中通过 this(参数列表) 调用本类其他构造器，不能调用自己。\n\n## package\n\n1.更好地实现项目中类的管理\n\t\t2.声明在源文件的首行。声明类或接口所属的包\n\t\t3.属于标识符，遵循标识符的定义规范\n\n## import\n\n1.在源文件中导入指定的包或接口\n2.声明在包的声明和类的声明之间\n3.“ xxx.* ”表示导入xxx包下的所有结构\n4.如果使用的类或接口在java.lang包下定义的，则可以省略\n5.使用本包下定义的类或接口，可以省略\n\n## 继承性\n\n好处：\n\t\t1.减少了代码的冗余，提高了代码的复用性。\n\t\t2.便于功能的扩展\n\t\t3.为多态的使用提供了前提\n\t\t格式：class A extends B{}\n\t\tA:子类，派生类，subclass\n\t\tB:父类，超类，基类，superclass\n\t\t1.一旦子类A继承父类B以后，子类A中就获取了父类B中的结构中所有的属性和方法。\n\t\t父类中的private属性和方法仍然被子类所继承，只是由于封装性的原因使得子类不能直接调用父类的结构而已。\n\t\t2.子类继承父类后，还可以声明自己特有的属性和方法，实现功能的拓展。\n\t\t子类和父类的关系不等同于集合与子集的关系。\n\t\t__Java中继承的规定：__\n\t\t1.一个类可以被多个子类继承。\n\t\t2.单继承：一个类只允许有一个父类。\n\t\t3.子父类的关系是相对的。（直接父类，间接父类）。\n\t\t4.子类一旦继承了父类后，就获取了直接父类以及所有间接父类的属性和方法\n\n__Object类：__\n\t\t1.如果我们没有显式地声明一个类的父类，则此类继承于java.lang.Object类。\n\t\t2.所有java类(除java.lang.Object类外)都直接或间接地继承于java.lang.Object类。\n\t\t3.所有java类都具有java.lang.Object类声明的功能。\n\t\t__Object类中的主要方法：__equal()，toString()\n\t\t<font color = red>equals()与==的区别:</font>\n\t\t==：运算符，\n\t\t1.可以使用在基本数据类型变量和引用数据类型之间(除了boolean类型);\n\t\t2.如果比较的是基本数据类型的变量，比较两个变量保存的值是否相等(不一定要类型相等)；\n\t\t例如：2 == 2.0；'2' == 2；'A' ==65\n\t\t3.如果比较的是引用数据类型的变量，比较两个变量存储的地址值是否相等。\n\t\tequals()：方法,\n\t\t1.通过对象来调用，只能适用于引用数据类型的变量；\n\t\t2.Object类中定义的equals()与 == 相同:\t\n\n```java\npublic boolean equals(Object obj){\n     rerturn (this == obj);\n}\n```\n\n3.String , Date , File , 包装类等都重写了Object类中的equal()方法。比较的不是两个引用的地址，而是比较两\t\t个对象的“实体内容”是否相等；\n\t\t<font color=red>toString():</font>\n\t\t1.输出一个对象的引用时，自动调用；\n\t\t2.在Object类中的定义：\n\n```java\npublic String toString() {\n        return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n    }// 返回类名和内存地址\n```\n\n3.String， Date , File , 包装类等都重写了Object类中的toString()方法。调用对象时返回的时对象的实体内\t\t 容。\n\n__方法的重写：__\n​子类继承父类以后，可以对父类中同名同参数方法进行覆盖操作。\n​应用：重写之后，通过子类对象调用父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。\n​要求：\n​1.子类中重写的方法名和形参列表必须与父类中被重写的方法的方法名和形参列表相同。\n​2.子类中重写的方法的权限修饰符不小于父类中被重写的权限修饰符。(父类中声明为private的方法不能被重\t\t写)\n​3.返回值类型：\n\n- 父类中被重写的方法的返回类型为void或基本数据类型时，子类中的重写方法的返回类型也必须为void或基本数据类型。\n\n- 父类中被重写的方法的返回类型为A类型，子类中重写的方法的返回值类型可以是A类或A的子类。\n\n4.子类重写的方法抛出的异常类型不大于父类被重写方法抛出的异常类型\n\n## super\n\n1.在子类的方法或构造器中，通过“super.属性”或“super.方法”的方式 ，显示地调用父类中的属性或方法，通常省略，子类和父类出现同名的属性时不可省略。\n​\t\t2.在子类构造器的首行显示使用“super(形参列表)”调用父类中指定的构造器，且不能与“this(形参列表)”同时存在。\n​\t\t3.在子类构造器的首行如果没有显示地声明“super(形参列表)”或“this(形参列表)”，默认调用父类中空参的构造器。\n​\t\t4.在子类的多个构造器中至少有一个类的构造器中使用了“super(形参列表)”来调用父类构造器。\n\n## 多态性\n\n1.对象的多态性：父类的引用指向子类对象。\n​\t\t2.多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法。(虚拟方法调用)\n​\t\t在编译期只能调用父类中声明的方法，在运行期实际执行的是子类重写父类的方法。(动态绑定)\n\n```java\nPerson p1 = new Student();// 父类引用指向子类对象\np1.getInfo();// 调用Student类发getInfo()方法\n```\n\n3.使用前提：类的继承关系，方法的重写。\n\t\t4.对象的多态性只使用于方法，不使用于属性。\n__重载与重写的区别：__\n\t\t重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为<font color=red>“早绑定”或“静态绑定”</font>；\n\t\t重写，体现了多态性，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为<font color=red>“晚绑定”或“动态绑定”</font>。\n\n## instanceof\n\na instanceof A :判断对象a是否是类A的实例或子类。若是则返回true，否则返回false.\n使用：\n\n```java\nPerson p1 = new Man();// 声明一个父类Person对象，并指向子类Man对象\n// 向下转型：使用强转符()\n// 向下转型目的：\n//有了对象的多态性以后，内存中实际加载了子类特有的属性和方法，但是变量声明为父类类型，在编译时只能调用父类中声明的属性和方法,\n//为了调用子类对象中特有的属性和方法,使用向下转型\n//Women w1 = (Women)p1;// 抛出异常\nif(p1 instanceof Man){\n    Man m1 = (Man)p1;\n    m1.earnMoney();// 调用子类Man中特有的方法(父类Person没有的方法)时，编译前不会报错\n}\n```\n\n![](java-02/oop_6.png)\n\n## 包装类\n\nJava提供了8种基本数据类型的包装类，使得基本数据类型的变量具有类的特征\n![8种包装类](java-02/oop_4.png)\n\n![基本类型、包装类与String类间的转换](java-02/oop_5.png)\n\n```java\n/**\n * @Description 基本类型、包装类与String类间的转换\n * @author sweetboyZhang \n * @date 2020年2月3日下午2:21:04\n */\npublic class WrapperTest {\n\t@Test// 基本数据类型->包装类 \n\tpublic void test1(){\n\t\tint num1 = 20;\n\t\tInteger num1_Object = new Integer(num1);// 调用包装类的构造器\n\t\tInteger num2_Object = 666;// 自动装箱\n\t\tSystem.out.println(num2_Object.toString());\n\t\tSystem.out.println(num1_Object.toString());\n\t}\n\t\n\t@Test// 包装类->基本数据类型\n\tpublic void test2(){\n\t\tInteger num3_Object = new Integer(1);\n\t\tint num3 = num3_Object.intValue();// 调用xxxValue()\n\t\tint num4 = num3_Object;// 自动拆箱\n\t\tSystem.out.println(num3+1);\n\t\tSystem.out.println(num4+1);\n\t}\n\t\n\t@Test // 基本数据类型，包装类->String类型\n\tpublic void test3() {\n\t\t// 方式一：连接运算\n\t\tint num5 = 6;\n\t\tString str1 = num5 + \"\";\n\t\tSystem.out.println(str1);\n\t\t// 方式二：调用String重载的valueOf()方法\n\t\tfloat num6 = 6.6f;\n\t\tString str2 = String.valueOf(num6);\n\t\tSystem.out.println(str2);\n\t}\n\t\n\t@Test // String类型->基本数据类型，包装类\n\tpublic void test4() {\n\t\t// 调用 包装类的parseXxx()方法\n\t\tString str3 = \"1432132\";\n\t\tint num7 = Integer.parseInt(str3);\n\t\tSystem.out.println(str3);\n\t}\n}\n```\n\n## static\n\n1.可以修饰：属性，方法，代码块，内部类。\n2.使用 static 修饰属性：\n<font color=red>**静态变量只能在类主体中定义，不能在方法中定义。 静态变量属于类所有而不属于方法。**</font>\n按是否使用static修饰分为__静态属性(类变量)__和__非静态属性(实例变量)__;\n__非静态属性__：如果创建多个对象，每个对象都独立拥有一套类中的非静态属性。修改其中一个对象中的非静态属性时，不会导致其他对象中的相同属性发生变化。\n__静态属性__：多个对象共享一个静态属性。当其中一个对象修改静态属性时，会导致其他对象调用此静态属性时，是修改过了的。\n<font color = red>注意</font>：\n<1>.静态变量随着类的加载而加载，可以通过\"类名.静态变量\"的方式进行调用。\n<2>.静态变量的加载早于对象的创建。\n<3>.由于类只会加载一次，则静态变量在内存中也只会存在一份(存在方法区的静态域中)。\n<4>.类能调用类变量，但不能调用实例变量；对象既能调用类变量，又能调用实例变量。\n\n![类变量与实例变量内存解析](java-02/oop_7.png)\n\n3.使用 static 修饰方法：\n\t\t<1>.静态方法随着类的加载而加载，可 通过\"类名.静态方法\"的方式进行调用。\n\t\t<2>.类可以调用静态方法，但不能调用非静态方法；对象既可以调用静态方法，又能调用非静态方法。\n\t\t<3>.静态方法中只能调用静态属性或静态方法；非静态方法中既能调用静态属性又能调用静态方法。\n\t\t<4>.静态方法中不能使用this,super关键字。\n\n4.如何确定一个属性是否要声明为static\n\t\t<1>.属性可以被多个对象所共享，不会随着对象的不同而不同。\n\t\t<2>.类中的常量常常声明为static\n\n5.如何确定一个方法是否要声明为static\n\t\t<1>.操作静态属性的方法通常设置为static;\n\t\t<2>.工具类中的方法，习惯上声明为static,例如Math,Arrays,Collections\n\n##  代码块\n\n作用：初始化类或对象\n\t\t__静态代码块__：static{}\n\t\t<1> 内部可以有输出语句\n\t\t<2> 随着类的加载而执行，而且只执行一次\n\t\t<3> 作用：初始化类的信息\n\t\t<4> 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行\n\t\t<5> 静态代码块的执行优先于非静态代码块的执行\n\t\t<6> 静态代码块内只能调用静态的属性和方法，不可以调用非静态的属性和方法\n\t\t__非静态代码块__：{}\n\t\t<1>  内部可以有输出语句\n\t\t<2> 随着类的创建而执行\n\t\t<3> 每创建一个对象，就执行一次非静态代码块\n\t\t<4> 作用：可以在创建对象时，对对象的属性进行初始化\n\t\t<5>非静态代码块内既能调用静态的属性和方法，又能调用非静态的属性和方法\n\n## final\n\n1.修饰类：表明该类不能被继承。例如：String类，System类，StringBuffer类\n2.修饰方法：表明该方法不能被重写，但是可以被重载。例如：Object类中的getClass()方法\n3.修饰变量：此时的\"变量\"就称为一个常量\n\t<1> final修饰成员变量：显式初始化，声明时直接赋值；代码块中初始化；构造器中初始化。\n\t<2> 修饰局部变量：修饰形参时，可以不用初始化，但是在调用时必须要初始化。给常量形参赋一个实参，以后只能在方法体内使用此形参，但不能重新赋值。\n修饰基本数据类型时，在赋值之后就无法改变；\n修饰引用数据类型时，在赋值后指向的地址无法改变，但是对象的内容可以改变。\n例如：可以对数组中的元素重新赋值，但是不能使数组指向新的地址。\n\nstatic final 修饰属性：全局常量\n\n## abstract\n\n1.abstract修饰类：抽象类\n\t\t<1> 此类不能实例化\n\t\t<2> 抽象类中一定有构造器，便于子类实例化调用\n\t\t<3> 通过提供抽象类的子类，通过实例化子类完成相应的操作\n2.abstract修饰方法：抽象方法(jdk1.8中**默认权限为default**)\n\t\t<1> 抽象方法只有方法的声明，没有方法体\n\t\t<2> 包含抽象方法的类一定是抽象类；抽象类中可以没有抽象方法\n\t\t<3> 若子类重写了父类的所有抽象方法，此子类可以实例化；否则，此子类必须声明为抽象类\n\n## interface\n\n1.在java中，接口与类是并列的两个结构。(**默认权限为public**)\n2.接口中的成员：\n\n   - JDK7及以前：只能定义全局常量(public static final 可以省略)和抽象方法(**默认为public abstract** )\n   - JDK8：还可以定义静态方法(public static 只能通过接口来调用)，**此时被修饰的方法必须带有方法体**。\n\n3.接口中不能定义构造器\n\n4.**非抽象类**实现接口必须重写该接口中的所有抽象方法\n\n5.Java通过实现多个接口，弥补单继承的局限性\n  ```class A extends B implements C,D,E{}```\n 6.接口之间可以继承，而且可以多继承\n\n> 接口和抽象类的区别是什么？\n\n1. 接口的方法默认是`public abstract`，所有方法在接口中不能有实现(Java 8 开始，default、static方法可以有默认实现）；而抽象类可以有非抽象的方法（即普通成员函数），抽象方法可以被public、protected 和default 这些修饰符修饰（抽象方法就是为了被重写所以不能使用private 关键字修饰！）。\n2. 接口中除了`public static ﬁnal` 变量，不能有其他变量；而抽象类中则不一定。\n3. 一个类可以实现多个接口；但只能实现一个抽象类。接口自己本身可以通过extends 关键字扩展\n    多个接口。\n4. 从设计层面来说，抽象是对类本质的抽象，是一种模板设计，为了代码复用，而接口是对行为的抽象，是一种行为的规范，只约束了行为的有无，不对接口的实现做限制。\n\n> 当你关注于一个事物的本质时，使用抽象类；当你关注于一个操作时，使用接口。\n\n## 内部类\n\nJava中允许一个类A声明在另一个类B中，则类A就是内部类，类B就是外部类。\n\t\t1.非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员\n\t\t内部类中才可声明static成员；\n\t\t2.外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式；\n\t\t3.**成员内部类可以直接使用外部类的所有成员，包括私有的数据**；\n\t\t4.当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的；\n\t\t5.局部内部类和匿名内部类只能访问局部`final`变量；因为当外部类方法执行完成后，局部变量就会销毁，而内部类可能没有被销毁（只有没被引用时才被销毁）。\t\n\n**java中的类加载顺序：**\n父类静态变量/父类静态代码块->子类静态变量/子类静态代码块->父类成员变量/父类非静态代码块->父类构造器->子类成员变量/子类非静态代码块->子类构造器\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["JavaSE"],"categories":["JavaSE"]},{"title":"数据类型，运算符，数组","url":"/2020/01/09/java-01/","content":"##  变量的使用\n\n1.变量必须先声明后使用。\n2.变量都定义在其作用域内，在作用域内有效，出了作用域就失效了。\n3.同一个作用域内不能声明两个同名变量。<!--more-->\n\n## 数据类型\n\n![](java-01/1.jpg)\n\n__基本数据类型(primitive type)__\n\t\t整型  byte(1字节) -128~127 , short (2字节), int(4字节) , long(8字节) l或L结尾\n\t\t浮点型  float(4字节) 定义时要以f或F结尾 , double(8字节)\n\t\t字符型  char(2字节)\n\t\t布尔型  boolean 只能取两个值之一 ：true , false\n_7种基本数据类型之间的计算（不包括布尔类型）:_\n        1.自动类型提升：\n       \t\t容量小的数据类型变量与容量大的数据类型做运算时，运算结果自动装换为容量大的。\n      \t\t byte , char , short --> int --> long --> float --> double \n**所有的byte , short , char 类型的值将被提升为int型；**\n**被final 修饰的变量不会自动提升其类型**\n\n​\t\t2.强制类型转换：\n​\t    使用强转符 () ，可能造成精度损失\n__引用数据类型(reference type)__\n​\t\t类 class \n​\t\tString类型：  声明时使用一对\"\"，可以与8种基本数据类型做运算，+ 只能表示连接\n​\t\t接口 interfere\n​\t\t数组 [ ]\n\n## 运算符\n\n​\t__算术运算符__\n​\t\t\t__逻辑运算符__\n​\t\t\t__&&与&的区别：__\n​\t\t\t& : 左边无论真假，右边进行运算\n​\t\t\t&& ： 左边为真，右边参与运算；左边为假，右边不参与运算\n​\t\t\t__|与||的区别：__\n​\t\t    ||：左边为真，右边不参与运算\n​\t\t\t__位运算：__\n​         ![](java-01/1.png)\n\n**运算符优先级：**\n\n单目乘除为(位)关系，逻辑三目后赋值。 \n\n单目：单目运算符+ –(负数) ++ -- 等 \n乘除：算数单目运算符* / % + - \n为（位）：位移单目运算符<< >> \n关系：关系单目运算符> < >= <= == != \n逻辑：逻辑单目运算符&& || & | ^ \n三目：三目单目运算符A > B ? X : Y \n后：无意义，仅仅为了凑字数 \n赋值：赋值=\n\n## 流程控制\n\n__顺序结构__\n__分支结构__\n__循环结构__\n\t    break :  结束当前循环\n\t    continue :  结束当次循环\n\n## 数组\n\n__数组的特点:__\n\t\t\t1.数组是有序排列的\n            2.数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型的变量\n            3.创建数组对象时会在内存中开辟一整块连续的内存空间\n            4.数组的长度一旦确定就不能修改 \n\n__一维数组的使用:__\n\n```java\npublic class ArrayTest {\n\tpublic static void main(String[] args) {\n\tint[] nums;// 声明\n\t// 静态初始化:数组的初始化和数组元素的初始化同时进行\n    // int型数组元素数量小于指定容量时，以0填充\n\tnums = new int[] {1,2,3,4,5,6};\n    // int[] nums = {1,2,3,4,5,6}\n        \n\t// 动态初始化:数组的初始化和数组元素的初始化分开进行\n\tString[] names = new String[6];\n\t\n\t// 通过角标的方式调用指定位置的元素\n\tnames[0] = \"Tom\";\n\tnames[1] = \"Justin\";\n\t\n\t// 获取数组长度： length\n\tSystem.out.println(names.length);\n\t\n\t// 遍历数组\n\tfor(int i = 0;i < nums.length;i++) {\n\t\tSystem.out.println(nums[i]);\n\t\t}\n\t}\n}\n```\n\n__一维数组元素的默认初始值__\n_基本数据类型：_\n整形：0\n浮点型：0.0\nchar型：0（ASCII码值） 而非'0'\nboolean型：false\n引用数据类型：null\n\n__一维数组的内存解析:__\n\n在栈空间中申请一个变量用来存储堆空间中数组的首地址值\n\t\t在堆空间中申请一个数组用来存放数组元素\n\n__多维数组的使用：__\n\n```java\npublic class ArrayTest1 {\n\tpublic static void main(String[] args) {\n\t\t// 静态初始化\n\t\tint[][] arr =  new int [][] {{1,2,3},{4,5},{6}};\n\t\t\n\t\t//动态初始化\n\t\tString [][] arr1 = new String[3][2];\n\t\tString [][] arr2 = new String[3][];\n\t\t\n\t\t// 调用数组指定位置的元素\n\t\tSystem.out.println(arr[0][1]);// 2\n\t\tSystem.out.println(arr1[1][1]);// null\n\t\t\n\t\t// 获取数组的长度\n\t\tSystem.out.println(arr.length);// 3\n\t\t\n\t\t// 遍历二维数组\n\t\tfor(int i = 0;i < arr.length;i++) {\n\t\t\tfor(int j = 0;j < arr[i].length;j++)\n\t\t\t{\n\t\t\t\tSystem.out.print(arr[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t}\n}\n```\n\n__二维数组元素的默认初始值:__\n针对初始化方式一：```String [][] arr1 = new String[3][2];```\n外层元素的初始化值为：地址值   \t        \t\n内层元素的初始化值为：与一维数组的初始化情况相同\n针对初始化方式二：``` \t\tString [][] arr1 = new String[3][];```\n外层元素的初始化值为：null\n内层元素的初始化值为：<font color = \"red\">不能调用，否则报错 </font>\n\n__二位数组的内存解析:__\n在栈空间中申请一个变量用来存储堆空间中数组的首地址值\n在堆空间中申请一个数组用来存放二维数组的外层元素，外层元素中存放着指向存储内层元素数组的首地址\n在堆空间中申请一个数组用来存储内层元\n![](java-01/Array_02.png)\n\n## 数组中涉及的常见算法\n\n__数组元素的赋值__\n\n```java\n/**\n * @Description 打印10行杨辉三角\n * @author sweetboyZhang\n * @date 2020年1月13日上午11:26:21\n */\npublic class YangHui_Test {\n\tpublic static void main(String[] args) {\n\t\t// 声明并动态初始化二位数组\n\t\tint [][] yangHui = new int[10][];// 10行，列数不确定\n\t\t// 给元素赋值\n\t\tfor(int i = 0;i < yangHui.length;i++) {\n\t\t\tyangHui[i] = new int[i+1];// 第i行有i+1个元素\n\t\t\t// 给首末元素赋值\n\t\t\tyangHui[i][0] =yangHui[i][i] = 1;//首末元素为1\n\t\t\t// 给其余元素赋值\n\t\t\tif(i > 1) {\n\t\t\t\tfor(int j = 1;j < yangHui[i].length-1;j++) {\n\t\t\t\t\tyangHui[i][j] = yangHui[i-1][j] + yangHui[i-1][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 遍历输出\n\t\tfor(int i = 0;i < yangHui.length;i++) {\n\t\t\tfor(int j = 0;j < yangHui[i].length;j++) {\n\t\t\t\tSystem.out.print(yangHui[i][j] + \" \");\t\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n__求数值型数组中元素的最大值、最小值、平均数、总和等__\n\n```java\n/**\n * @Description 定义一个int型的一维数组，包含10个元素，分别赋一些随机整数，\n然后求出所有元素的最大值，最小值，和值，平均值，并输出出来。\n要求：所有随机数都是两位数。\n * @author sweetboyZhang\n * @date 2020年1月13日下午2:13:41\n */\npublic class ArrayTest2 {\n\tpublic static void main(String[] args) {\n\t\tint[] arr = new int[10];\n\t\tint min = 100;\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tint average = 0;\n\t\tfor(int i = 0;i < arr.length;i++) {\n\t\t\t// 获取[a,b]范围内的随机数，(int)(Math.random()*(b-a+1)+a)\n\t\t\tarr[i] = (int)(Math.random()*(99-10+1)+10);\n\t\t\tSystem.out.print(arr[i]+ \" \");\n\t\t\tif(min>arr[i]) {\n\t\t\t\tmin = arr[i];\n\t\t\t}\n\t\t\tif(max<arr[i]) {\n\t\t\t\tmax = arr[i];\n\t\t\t}\n\t\t\tsum+=arr[i];\n\t\t\taverage = sum/arr.length;\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"最大值：\" + max);\n\t\tSystem.out.println(\"最小值：\" + min);\n\t\tSystem.out.println(\"和值：\" + sum);\n\t\tSystem.out.println(\"平均值：\" + average);\n\t}\n}\n```\n\n__<font color=\"red\">赋值与复制</font>__\n\n\n赋值：```array2 = array1;// array1指向堆空间的地址赋给array2,不能称为数组的复制```\n\t\t\t对array2修改就是对array1进行修改\n\t\t复制：```for(int i = 0;i < array2.length;i++) {\n\t\t\tarray2[i] = array1[i];\n\t\t}```\n\t\t    对array2修改不会影响到array1\n\n__数组的反转__\n\n```java\nString[] array1 = new String[] {\"Tom\",\"Taylor\",\"Justin\",\"Troye\",\"Swift\"};\nfor(int i = 0;i < array1.length/2;i++) {\n\t\tString temp = array1[i];\n\t\tarray1[i] = array1[array1.length-1-i];\n\t\tarray1[array1.length-1-i] = temp;\n}\n```\n\n__查找__\n\n1. 线性查找\n\n```java\nString[] array1 = new String[] {\"Tom\",\"Taylor\",\"Justin\",\"Troye\",\"Swift\"};\nString dest = \"Justin\";\nboolean isFlag = true;\nfor(int i = 0;i < array1.length;i++) {\n\tif(dest.equals(array1[i])) {\n\t\tSystem.out.println(\"元素Justin的位置为：\" + i);\n\t\tisFlag = false;\n\t\tbreak;\n\t}\t\n}\nif(isFlag) {\n\tSystem.out.println(\"没有找到！\");\t\n}\n```\n\n2. 二分查找\n\n```java\nint [] array3 = new int [] {1,2,3,4,5,6,7,8,9,10};\nint number = 6;\nint head = array3[0];// 初始的首索引\nint end = array3[array3.length -1];// 初始的尾索引\nint middle = (head + end)/2;// 二分\nboolean isFlag1 = true;// 设置标志位，找到元素后置false\nwhile(head <= end) {\n\tif(number == array3[middle]) {\n\t\tSystem.out.println(\"元素6的位置为：\" + middle);\n\t\tisFlag1 = false;\n\t\tbreak;\n\t}else if(number < array3[middle]) {\n\t\t\tend = middle - 1;\n\t}else {\n\t\t\thead = middle + 1;\n\t}\n}   \nif(isFlag1) {\n\tSystem.out.println(\"没有找到该元素！\");\n}\n```\n\n__排序__\n\n__冒泡排序__\n\n排序思想：\n1. 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步\n做完后，最后的元素会是最大的数。\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要\n比较为止。\n\n```java\nint [] array = new int[] {1,2,8,4,6,8,6,5,3,33,1,0};\nfor(int i = 0;i < array.length-1;i++) {\n\tfor(int j = 0;j < array.length-1-i;j++) {\n\t\tif(array[j]>array[j+1]) {\n\t\t\tint temp = array[j];\n\t\t\tarray[j] = array[j+1];\n\t\t\tarray[j+1] = temp;\n\t\t}\n\t}\n}\t\nfor(int i = 0;i < array.length;i++) {\n\tSystem.out.print(array[i] + \" \");\n}\n```\n\n__Arrays工具类__\n\njava.util.Arrays ：操作数组的工具类，定义了许多操作数组的方法\n\n```java\npublic static void main(String[] args) {\n    int[] arr1 = new int[] {1,2,3,4};\n\tint[] arr2 = new int[] {5,4,3,2,1};\n\t// 1.boolean equals(int[] a,int[] b) 判断两个数组是否相等。\n\t\tboolean isEqual =Arrays.equals(arr1, arr2);\n\t\tSystem.out.println(isEqual);// false\n\t\t\n\t// 2.String toString(int[] a) 输出数组信息\n\t\tString arr1Info = Arrays.toString(arr1);\n\t\tSystem.out.println(arr1Info);// [1,2,3,4]\n\t\t\n\t// 3.void fill(int[] a,int val) 将指定值填充到数组之中。\n\t\tArrays.fill(arr1,6);\n\t\tSystem.out.println(Arrays.toString(arr1));// [6,6,6,6]\n\t\t\n\t// 4.void sort(int[] a) 对数组进行排序。\n\t\tArrays.sort(arr2);\n\t\tSystem.out.println(Arrays.toString(arr2));// [1,2,3,4,5]\n\t\t\n\t// 5.int binarySearch(int[] a,int key) 对排序后的数组进行二分法检索指定的值。\n\t\tint index = Arrays.binarySearch(arr2, 4);\n\t\tif(index >= 0 ) {\n\t\t\tSystem.out.println(\"元素4的索引为：\"+ index);\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"未找到该元素！\");\n\t\t}\n    // 6. List<T> asList(T... a) 返回一个List  底层是final数组\n\t}\n```\n\n__数组使用的常见异常__\n\n1.数组脚标越界异常\n\tArrayIndexOutOfBoundsException：访问到了数组中的不存在的脚标时发生。\n\t合理范围：[0,array.length-1]\n\n2.空指针异常\n\tNullPointerException：array引用没有指向实体，却在操作实体中的元素时。\n\n\n\n  \n\n  \n\n\n\n","tags":["JavaSE"],"categories":["JavaSE"]}]